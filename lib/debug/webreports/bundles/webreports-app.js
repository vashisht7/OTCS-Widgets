csui.define('webreports/utils/url.webreports',['csui/lib/underscore','csui/utils/url','csui/utils/contexts/factories/node'], function (_,Url, NodeModelFactory) {

    var UrlWebReports = _.extend({

        appendWebReportParameters: function (query, parameters) {

            // Append any WebReport parameters to the RestURL if present
            if (!_.isUndefined(parameters)) {
                // Currently supported array format generated by the Perspective Manager
                if (_.isArray(parameters)) {
                    query = this.combineQueryString(query, this._serializeWebReportParameters(parameters));
                } else {
                    // Support parameters in legacy format
                    query = this.combineQueryString(query, parameters);
                }
            }

            return query;
        },

        appendCurrentContainer: function (query, context) {

            var csuiContainerID;

            // Append the containerID parameter to the RestURL if present
            if (!_.isUndefined(context)) {
                csuiContainerID = this.getCurrentContainerID(context);

                if (csuiContainerID){
                    query = this.combineQueryString(query, 'csuiContainerID='+ csuiContainerID );
                }
            }

            return query;
        },

        appendSWRCellID: function (query, options) {

            var subWebReportCellID;

            // Append the containerID parameter to the RestURL if present
            if (options && options.data && options.data.swrLaunchCell && options.data.swrLaunchCell.id) {

                subWebReportCellID = parseInt(options.data.swrLaunchCell.id, 10);

                if (typeof subWebReportCellID === "number" && !isNaN(subWebReportCellID)){
                    query = this.combineQueryString(query, 'subwebreport_id='+ subWebReportCellID );
                }
            }

            return query;
        },

        getCurrentContainerID: function (context) {
            var csuiContainerID,
                node = context.getModel(NodeModelFactory);

            if (!_.isUndefined(node)){
                csuiContainerID = node.get('id');
            }
            return csuiContainerID;
        },

        _serializeWebReportParameters: function(parameters){
            var serializedParms = '';

            _.each(parameters, function (parmPair) {
                if ( parmPair.name !== '' ) {
                    if (serializedParms.length) {
                        serializedParms += '&' + parmPair.name + '=' + parmPair.value;
                    } else {
                        serializedParms += parmPair.name + '=' + parmPair.value;
                    }
                }
            });

            return serializedParms;
        },

        /* Converts parameters in the format:
                parameters: [
                    {
                        name: 'myparm1',
                        value: 'val1'
                    },
                    {
                        name: 'myparm2',
                        value: 'val2'
                    }
                ]

           To the format:

                {
                    myparm1: 'val1',
                    myparm2: 'val2'
                }

           This is used to generate an object to pass in as data to a POST API.
        */

        getWebReportParametersAsData: function(parameters){

            var parmsObject = {};

            if (_.isArray(parameters)) {
                _.each(parameters, function (parmPair) {
                    if ( parmPair.name !== '' ) {
                        parmsObject[parmPair.name] = parmPair.value;
                    }
                });
            }

            return parmsObject;
        },

        /*  The inverse of getWebReportParametersAsData( parameters ).

         Converts parameters in the format:
             {
             myparm1: 'val1',
             myparm2: 'val2'
             }

         To the format:
             [
                 {
                     name: 'myparm1',
                     value: 'val1'
                 },
                 {
                     name: 'myparm2',
                     value: 'val2'
                 }
             ]

         Used to pass parameters from the prompt screen into a WR using Widget destinations.
        */
        getDataAsWebReportParameters: function(parameters){


            var parmsArray = [];

            if ( _.isObject(parameters) ){
                _.mapObject( parameters, function (val, key){
                    parmsArray.push({"name":key, "value": val});
                });
            }

            return parmsArray;
        }

    }, Url);

    return UrlWebReports;

});

csui.define('webreports/models/wrtext/wrtext.model',[
  'csui/lib/underscore',
  'csui/lib/backbone',
  'webreports/utils/url.webreports',
  'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, UrlWebReports, ConnectableMixin) {

  var WrTextModel = Backbone.Model.extend({

    // Constructor gives an explicit name to the object in the debugger
    constructor: function WrTextModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

      // Enable this model for communication with the CS REST API
        this.makeConnectable(options);
    },

    // Computes the REST API URL using the connection options
      url: function () {

          var parameters = this.get('parameters'),
              context = this.get('context'),
              query = '';

          // Append any WebReport parameters to the RestURL if present
          query = UrlWebReports.appendWebReportParameters(query, parameters);

          // Append the containerID parameter to the RestURL if present
          query = UrlWebReports.appendCurrentContainer(query, context);

          // Call WebReport API using WebReport format rather than JSON
          return UrlWebReports.combine(this.connector.connection.url + '/nodes/' + this.get('id'),
                  query ? '/output?format=webreport&' + query : '/output?format=webreport');
      },

    // Massage the server response, so that it looks like object attributes
    parse: function (response) {
      // Create an object with the key source and value of the HTML response text
      return {source: response};
    }

  });

  ConnectableMixin.mixin(WrTextModel.prototype);

  return WrTextModel;

});

csui.define('webreports/utils/contexts/factories/wrtext.model.factory',[
  'csui/lib/underscore',
  'csui/utils/contexts/factories/factory',
  'csui/utils/contexts/factories/connector',
  'webreports/models/wrtext/wrtext.model'
], function (_,ModelFactory, ConnectorFactory, WrTextModel) {

  var WrTextModelFactory = ModelFactory.extend({

    // Unique prefix of the default model instance, when this model is assigned
    // to a context it can be shared by multiple widgets
    propertyPrefix: 'wrtext',

    constructor: function WrTextModelFactory(context, options) {
      ModelFactory.prototype.constructor.apply(this, arguments);

      // Obtain the server connector from the application context to share
      // the server connection with the rest of the application; include
      // the options, which can contain settings for dependent factories
      var connector = context.getObject(ConnectorFactory, options);

      // Expose the model instance in the `property` key on this factory
      // instance to be used by the context
      this.property = new WrTextModel(options.wrtext.attributes, {
        connector: connector
      });
    },

    fetch: function (options) {

      // Expect HTML from the model not JSON
      if (options){
        _.extend(options,{dataType:'html'});
      } else {
        options = {dataType:'html'};
      }

      // Just fetch the model exposed by this factory
      return this.property.fetch(options);
    }

  });

  return WrTextModelFactory;

});

csui.define('webreports/mixins/webreports.view.mixin',['csui/lib/underscore', 'webreports/utils/url.webreports'
], function (_, Url) {
    "use strict";

    var WebReportsViewMixin = {

        mixin: function (prototype) {
            return _.extend(prototype, {
                setCommonModelOptions: function(options){

                    var parameters,
                        modelOptions = {};

                    if (options && options.data) {

                        // Widgets can pass in WebReport parameters to append to the URL
                        if (_.has(options.data, 'parameters')) {
                            parameters = options.data.parameters;
                            if(!_.isUndefined(parameters) && typeof parameters === "object") {
                                _.extend(modelOptions,{parameters: parameters});

                                // Flatten the parameters and add them directly to the modelOptions
                                // This is needed so that the unique key generated for the collection in the context takes the parameters into account
                                // Nested objects don't get taken into account.
                                _.extend( modelOptions, Url.getWebReportParametersAsData(parameters));
                            }
                        }

                        // Add the id to the modelOptions
                        if (options.data.id) {
                            _.extend(modelOptions,{id: options.data.id});
                        }

                        // If the widget is loaded in a container context then we can get the id
                        // from the page context
                        if (options.context) {
                            _.extend(modelOptions,{context: options.context});
                        }

                    }

                    return modelOptions;
                }
            });
        }

    };

    return WebReportsViewMixin;
});

// Lists explicit locale mappings and fallbacks

csui.define('webreports/widgets/tilereport/impl/nls/tilereport.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/widgets/tilereport/impl/nls/root/tilereport.lang',{
  dialogTitle: 'Tile Report'
});



/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/tilereport/impl/tilereport',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n        <div class=\"tile-title\">\r\n            <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n        </div>\r\n\r\n        <div class=\"tile-controls\"></div>\r\n\r\n    </div>\r\n\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"tile-type-icon\">\r\n                <span class=\"icon title-icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n            </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "    <div class=\"webreports-tilereport-spacer\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "\r\n\r\n\r\n<div class=\"tile-content\"></div>\r\n\r\n<div class=\"tile-footer\"></div>\r\n";
}});
Handlebars.registerPartial('webreports_widgets_tilereport_impl_tilereport', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/tilereport/impl/tilereport',[],function(){});

csui.define('css!webreports/style/webreports',[],function(){});
// WebReports TileReport widget view. This renders a standard csui tile with HTML content returned from a WebReport.
csui.define('webreports/widgets/tilereport/tilereport.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/tile/tile.view',
  'webreports/utils/contexts/factories/wrtext.model.factory',
  'webreports/mixins/webreports.view.mixin',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'i18n!webreports/widgets/tilereport/impl/nls/tilereport.lang',
  'hbs!webreports/widgets/tilereport/impl/tilereport',
  'csui/lib/perfect-scrollbar',
  'css!webreports/widgets/tilereport/impl/tilereport',
  'css!webreports/style/webreports.css'
], function (_, $, Marionette, base, TileView, WrTextModelFactory, WebReportsViewMixin,
    PerfectScrollingBehavior, lang, template) {

    // Custom region that will execute <script> blocks that are in the WebReport output when they are appended
    // to the parent container. Without this, any script blocks that are in the WebReport's response are not
    // executed until the perspective is fully appended to the document.  In external systems (and the Widget Carousel)
    // this allows the scripts to execute without additional appends.
    var ScriptExecutingRegion = Marionette.Region.extend({
        attachHtml: function(view) {
            this.$el.html('').append(view.el);
        }
    });

    // This view is rendered by the main view and inserted into the appropriate content div in the template
    var ContentView = Marionette.ItemView.extend({

       className: 'webreports-tilereport-content',

       render: function () {

            var source;

            if (this.model){
                source = this.model.get('source');
                if(!_.isUndefined(source)) {
                    this.$el.html(source);
                }
            }

            return this;
        }
    });

      var TileReportView = TileView.extend({

          // Constructor gives an explicit name to the object in the debugger and
          // can update the options for the parent view, which `initialize` cannot
          constructor: function TileReportView(options) {


              if (options && options.data) {

                  // Check if the header is disabled using `header: false` in the options.
              var header = ( _.has(options.data, 'header')) && _.isBoolean(options.data.header) ? options.data.header : true,
                  // Check if scrolling is disabled using `scroll: false` in the options.
                  scroll = (_.has(options.data, 'scroll')) && _.isBoolean(options.data.scroll) ? options.data.scroll : true,
                  modelOptions;

                  options.data.header = header;
                  options.data.scroll = scroll;

                  modelOptions = this.setCommonModelOptions(options);

                  // Set up the model using the WRTextModelFactory
                  // This will return a model rather than a collection.
                  // This model executes a WebReport with response type of text/html and stores the
                  // responseText in a single property called 'source'.
                 options.model = options.context.getModel(WrTextModelFactory, { attributes: modelOptions } );

                  // Whenever properties of the model change, re-render the view
                  // This ensures the WebReport output is rendered to the view when the data
                  // has been fetched.
                  this.listenTo(options.model, 'change', this.render);

                  // TODO: Does the scroll-bar really need to be re-rendered?
                  this.listenTo(options.model, 'change', this._updateScrollbar);

                  // Set the options for ContentView so the main content pain has the context when it renders.
                  // These options are checked and loaded in the _renderContentView function of TileView
                  // before show is called for the view.
                  this.contentViewOptions = options;

              }

              // Call the parent constructor to ensure the object is built with all the inherited features.
              TileView.prototype.constructor.apply(this, arguments);
          },

          _updateScrollbar: function () {
              this.triggerMethod('update:scrollbar', this);
          },


          regionClass: ScriptExecutingRegion,

          contentView: ContentView,

          template: template,

          templateHelpers: function () {

              var helpers = {
                  title: base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle),
                  icon: this.options.data.titleBarIcon || 'title-webreports'
              };

              // Check if the header is disabled using `header: false` in the options.
              if (this.options.data.header === true){
                  _.extend(helpers,{header:this.options.data.header});
              }

              return helpers;

          },

          behaviors: {

              PerfectScrolling: {
                  behaviorClass: PerfectScrollingBehavior,
                  contentParent: '> .tile-content',
                  suppressScrollX: true,
                  // Required to prevent toolbar loading even when content doesn't overflow.
                  scrollYMarginOffset: 15,
                  scrollingDisabled: function () {
                      return !this.options.data.scroll;
                  }
              }

          },


          onRender: function () {

              // You can get issues when re-rendering the view
              // if contentView has already been instantiated.
              // Need to reset this to the constructor function before the contentView render is triggered
              // This is a shim and will probably need to be fixed elsewhere.
              // TODO: Check if this needs fixing in core `TileView`

              if (this.contentView && typeof this.contentView === "object"){
                  this.contentView = this.contentView.constructor;
              }

              if (this.options.data.header === false){

                  this.$(".tile-content")
                                      // Content originally set to 90% of the div because of the header
                                      // Need to reset the height
                                        .height("100%")
                                      // Need to override the 5px top margin assigned to the content
                                      // as this breaks the tile alignment when the header is removed
                                        .css('margin-top','0px');
              }
          }

      });

    // Add the mixin functionality to the target view
    WebReportsViewMixin.mixin(TileReportView.prototype);

      return TileReportView;

});


csui.define('json!webreports/widgets/tilereport/tilereport.manifest.json',{
  "$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
  "title": "{{widgetTitle}}",
  "description": "{{widgetDescription}}",
  "kind": "header",
  "supportedKinds": ["tile", "header", "fullpage"],
  "schema": {
    "type": "object",
    "properties": {
      "title": {
        "title": "{{tileTitle}}",
        "description": "{{tileDescription}}",
        "type": "object"
      },
      "titleBarIcon": {
        "title": "{{iconTitle}}",
        "description": "{{iconDescription}}",
        "type": "string"
      },
      "header": {
        "title": "{{headerTitle}}",
        "description": "{{headerDescription}}",
        "type": "boolean",
        "enum": [
          true,
          false
        ],
        "default": true
      },
      "scroll": {
        "title": "{{scrollTitle}}",
        "description": "{{scrollDescription}}",
        "type": "boolean",
        "enum": [
          true,
          false
        ],
        "default": true
      },
      "id": {
        "title": "{{idTitle}}",
        "description": "{{idDescription}}",
        "type": "integer"
      },
      "parameters": {
        "type": "array",
        "title": "{{firstParamTitle}}",
        "description": "{{firstParamDescription}}",
        "items": {
          "type": "object",
          "title": "{{secondParamTitle}}",
          "description": "{{secondParamDescription}}",
          "properties": {
            "name": {
              "type": "string",
              "title": "{{paramNameTitle}}",
              "description": "{{paramNameDescription}}"
            },
            "value": {
              "type": "string",
              "title": "{{paramValTitle}}",
              "description": "{{paramValDescription}}"
            }
          }
        }
      }
    },
    "required": ["id"]
  },  
  "options": {
    "fields": {
      "id": {
        "type": "otcs_node_picker",
        "type_control": {
          "parameters": {
            "select_types": [30303]
          }
        }
      },
      "title": {
        "type": "otcs_multilingual_string"
      }
    }
  }
});

csui.define('webreports/widgets/tilereport/impl/nls/tilereport.manifest',{
	// Always load the root bundle for the default locale (en-us)
	"root": true,
	// Do not load English locale bundle provided by the root bundle
	"en-us": false,
	"en": false
});

csui.define('webreports/widgets/tilereport/impl/nls/root/tilereport.manifest',{
	"widgetTitle": "HTML WebReport",
	"widgetDescription": "Returns the HTML output of a WebReport and inserts it into a tile",
	"tileTitle": "Title",
	"tileDescription": "Title for the tile",
	"iconTitle": "Icon class",
	"iconDescription": "CSS class supplying the icon in the tile header",
	"headerTitle": "Header",
	"headerDescription": "Boolean stating whether the header should be included or not",
	"scrollTitle": "Scroll",
	"scrollDescription": "Boolean stating whether the scrollbar should be included or not",
	"idTitle": "WebReport ID",
	"idDescription": "DataID for the WebReport which contains the HTML",
	"firstParamTitle": "WebReport Parameters",
	"firstParamDescription": "Key/Value pairs of parameters to be passed into the WebReport.",
	"secondParamTitle": "WebReport Parameters",
	"secondParamDescription": "Key/Value pairs of parameters to be passed into the WebReport.",
	"paramNameTitle": "Parameter Name",
	"paramNameDescription": "The name of the URL parameter.",
	"paramValTitle": "Parameter Value",
	"paramValDescription": "The value of the URL parameter."
});

// Expands the limited view by showing the full one in a modal dialog
csui.define('webreports/widgets/nodeslistreport/impl/expanding.behavior',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/dialog/dialog.view', 'csui/behaviors/expanding/expanding.behavior'
], function (_, Backbone, Marionette, DialogView, ExpandingBehavior) {

  var ServerExpandingBehavior = ExpandingBehavior.extend({

    constructor: function ServerExpandingBehavior(options, view) {
      ExpandingBehavior.prototype.constructor.apply(this, arguments);
    },

    // Need to override this function because we're using server-side pagination and filtering
    // The original behavior assumes client-side and checks for the completeCollection object which
    // we aren't using
    onExpand: function () {
      var collection = this.view.collection.clone();

      var expandedViewValue = this.getOption('expandedView'),
          expandedViewClass = expandedViewValue.prototype instanceof Backbone.View ?
                              expandedViewValue :
                              expandedViewValue.call(this.view),
          expandedViewOptions = getOption(this.options, 'expandedViewOptions', this.view);
      this.expandedView = new expandedViewClass(_.extend({
        context: this.view.options.context,
        collection: collection,
        orderBy: getOption(this.options, 'orderBy', this.view),
        limited: false
      }, expandedViewOptions));
      this.dialog = new DialogView({
        iconLeft: getOption(this.options, 'titleBarIcon', this.view) ||
                  getOption(this.view.options, 'titleBarIcon', this.view),
        imageLeftUrl: getOption(this.options, 'titleBarImageUrl', this.view),
        imageLeftClass: getOption(this.options, 'titleBarImageClass', this.view),
        title: getOption(this.options, 'dialogTitle', this.view),
        iconRight: getOption(this.options, 'dialogTitleIconRight', this.view),
        className: getOption(this.options, 'dialogClassName', this.view),
        largeSize: true,
        view: this.expandedView
      });
      this.listenTo(this.dialog, 'before:hide', this._expandOtherView);
      this.listenTo(this.dialog, 'hide', this.view._onCollapseExpandedView);  // Workaround until LPAD-53271 is implemented:  callback on original view when the expandedview is collapsed
      this._expandOtherView(false);
      this.dialog.show();
    }

  });

  // TODO: Expose this functionality and make it generic for functiona objects too.
  function getOption(object, property, context) {
    if (object == null) {
      return void 0;
    }
    var value = object[property];
    return _.isFunction(value) ? object[property].call(context) : value;
  }

  return ServerExpandingBehavior;

});

csui.define('webreports/models/nodestablereport/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/models/nodestablereport/impl/nls/root/lang',{
  size: 'Size'
});

csui.define('webreports/models/nodestablereport/nodestablereport.model',['module','csui/lib/underscore', 'csui/lib/backbone', 'webreports/utils/url.webreports',
    'csui/models/nodechildrencolumn', 'csui/models/nodechildrencolumns', 'csui/models/node/node.model',
    'csui/models/mixins/connectable/connectable.mixin', 'csui/models/mixins/fetchable/fetchable.mixin',
  'csui/models/mixins/commandable/commandable.mixin',
    'csui/models/browsable/browsable.mixin', 'csui/models/browsable/v1.request.mixin','csui/models/browsable/v2.response.mixin',
    'csui/models/mixins/v2.expandable/v2.expandable.mixin',
	'i18n!webreports/models/nodestablereport/impl/nls/lang'
], function (module, _, Backbone, UrlWebReports, NodeChildrenColumnModel, NodeChildrenColumnCollection, NodeModel,
             ConnectableMixin, FetchableMixin, CommandableMixin, BrowsableMixin, BrowsableV1RequestMixin,BrowsableV2ResponseMixin,ExpandableV2Mixin, lang ) {

    var config = module.config();
    _.defaults(config, {
        defaultPageSize: 30
    });

    var NodesTableReportColumnModel = NodeChildrenColumnModel.extend({});

    var NodesTableReportColumnCollection = NodeChildrenColumnCollection.extend({

        model: NodesTableReportColumnModel,

        // private
        getColumnModels: function (columnKeys, definitions) {
            var columns = NodeChildrenColumnCollection.prototype.getColumnModels.call(
                this, columnKeys, definitions);
            _.each(columns, function (column) {
                var columnKey = column['column_key'];
                if (columnKey === 'type' || columnKey === 'name' || columnKey === 'modify_date') {
                    column.sort = true;
                }
            }, this);
            return columns;
        },

        // private: convert v2 'metadata' to v1 'definitions' for backward code compatibility and
        //          reuse purpose
        getV2Columns: function (response) {

            // Note: from a long discussion with the server developer, use the common 'metadata' (or
            // called 'definitions' in v1) in the first element. Elements in the collection can have
            // different extended metadata (definitions).  If a business case arises that
            // extended definitions are needed, will discuss again with them and add that support.

            var definitions = (response.results && response.results[0] &&
                response.results[0].metadata && response.results[0].metadata.properties) || {};

            // For v2 calls, the 'size' column is not available.  Either the 'container_size' or
            // 'file_size' is available.  Create a 'size' definition here for compatibility with existing
            // code.
            if (!definitions.size &&
                (definitions.container_size ||
                (definitions.versions && definitions.versions.file_size))) {
                definitions.size = definitions.container_size || definitions.versions.file_size;
                definitions.size.align = 'right';
                definitions.size.key = 'size';
                definitions.size.name = lang.size;
                definitions.size.sort = true;
            }

            var columnKeys = _.keys(definitions);

            return this.getColumnModels(columnKeys, definitions);
        }

    });

    var NodesTableReportModel = NodeModel.extend({

        parse: function (response, options) {
            var node, node_version;
            if (response.data && response.data.properties) {
                node = response.data.properties;
                node_version = (!_.isUndefined(response.data.versions)) ? response.data.versions : undefined;
            } else {
                node = response;
                node_version = (!_.isUndefined(response.versions)) ? response.versions : undefined;
            }
            node.short_name = node.name; // node.name.length > 20 ? node.name.substr(0, 20) + '...' : node.name;
            if (!node.size) {
                if (node.container) {
                    node.size = node.container_size;
                } else if (node_version) {
                    node.size = node_version.file_size;
                    // The size table cell expects size_formatted to be defined correctly or undefined. The server global
                    // we call, incorrectly sets this as 0KB for documents. Setting this to undefined works around this
                    // and allows the formatted value to be derived from the size later on during table cell render.
                    node.size_formatted = undefined;
                }
            }
            if (!node.mime_type && node_version && node_version.mime_type) {
                node.mime_type = node_version.mime_type;
            }
            return NodeModel.prototype.parse.call(this, response, options);
        }

    });

    var NodesTableReportCollection = Backbone.Collection.extend({

			model: NodesTableReportModel,

			constructor: function NodesTableReportCollection(attributes, options) {
				Backbone.Collection.prototype.constructor.apply(this, arguments);

				//if (!this.connector) {
				//    this.connector = options.connector;
				//}

				if (_.isUndefined(options)){
					options = {};
				}

				if (options && options.id && !this.id) {
					this.id = options.id;
				}

				this.options = options;

				this.makeConnectable(options)
					.makeFetchable(options)
					.makeCommandable(options)
					.makeBrowsable(options)
					.makeBrowsableV1Request(options)
					.makeBrowsableV2Response(options)
                    .makeExpandableV2(options);

				this.skipCount = options.skip || 0;
				this.topCount = options.pageSize || config.defaultPageSize;
				this.filters = options.filter || {};
				this.orderBy = options.orderBy || 'name';

				this.columns = new NodesTableReportColumnCollection();
			},

			clone: function () {
                // Provide the options; they may include connector and other parameters
                var clone = new this.constructor(this.models, this.options);

                // Clone sub-models not covered by Backbone
                if (this.columns) {
                    clone.columns.reset(this.columns.toJSON());
                }

                // Clone additional properties set directly on the collection
                clone.actualSkipCount = this.actualSkipCount;
                clone.totalCount = this.totalCount;
                clone.filteredCount = this.filteredCount;
                clone.skipCount = this.skipCount;
                clone.filters = this.filters;

                return clone;
			},

			url: function () {
				var query = '',
					context = this.options.context || undefined,
					parameters = this.options.parameters || undefined;

				query = UrlWebReports.combineQueryString(
					query,
					this.getBrowsableUrlQuery(),
                    this.getExpandableResourcesUrlQuery()
				);

				// Append any WebReport parameters to the RestURL if present
				query = UrlWebReports.appendWebReportParameters(query, parameters);

				// Append the containerID parameter to the RestURL if present
				query = UrlWebReports.appendCurrentContainer(query, context);

				return UrlWebReports.combine(this.connector.connection.url + '/nodes/' + this.id,
					query ? '/output?format=webreport&' + query : '/output?format=webreport');
			},

			parse: function (response, options) {
				var webReportBrowseData;

				this.columns && this.columns.resetColumnsV2(response, options);
				this.parseBrowsedState(response, options);
				webReportBrowseData = this.parseBrowsedItems(response, options);
				return webReportBrowseData;
			},

			_renameColumnKeys: function (columns) {

				var newColumns = {};

				_.each(columns, function (value, key) {
					key = value.key;
					newColumns[key] = value;
				} );
				return newColumns;
			}
		}
    );

    BrowsableMixin.mixin(NodesTableReportCollection.prototype);
    ConnectableMixin.mixin(NodesTableReportCollection.prototype);
    FetchableMixin.mixin(NodesTableReportCollection.prototype);
	CommandableMixin.mixin(NodesTableReportCollection.prototype);
    BrowsableV1RequestMixin.mixin(NodesTableReportCollection.prototype);
    BrowsableV2ResponseMixin.mixin(NodesTableReportCollection.prototype);
    ExpandableV2Mixin.mixin(NodesTableReportCollection.prototype);

    var originalSetFilter = NodesTableReportCollection.prototype.setFilter;

    NodesTableReportCollection.prototype.setFilter = function (value, attributes, options){

        // If the filter has changed, reset the skipCount so the page reverts to 1.
        this.skipCount = 0;

        return originalSetFilter.apply(this, [value, attributes, options]);
    };

    return NodesTableReportCollection;

});

csui.define('webreports/utils/contexts/factories/nodestablereport',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'csui/utils/contexts/factories/connector',
  'webreports/models/nodestablereport/nodestablereport.model', 'csui/utils/commands',
  'csui/utils/deepClone/deepClone','csui/utils/contexts/factories/node'
], function (module, _, Backbone, CollectionFactory, ConnectorFactory, NodesTableReportCollection, commands) {
  'use strict';

  var NodesTableReportCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'nodestablereport',

    constructor: function NodesTableReportCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      // Obtain the server connector from the application context to share
      // the server connection with the rest of the application; include
      // the options, which can contain settings for dependent factories

      var nodestablereport = this.options.nodestablereport || {};

      if (!(nodestablereport instanceof Backbone.Collection)) {
		var connector = context.getObject(ConnectorFactory, options);
        var config = module.config();
        nodestablereport = new NodesTableReportCollection(nodestablereport.models, _.extend({
        connector: connector}, nodestablereport.attributes, config.options,
            NodesTableReportCollectionFactory.getDefaultResourceScope(),
		{
          // Prefer refreshing the entire table to rendering one row after another.
          autoreset: true
        }));
      }
      this.property = nodestablereport;
    },

    fetch: function (options) {
      return this.property.fetch(options);
    }

  }, {

    getDefaultResourceScope: function () {
      return _.deepClone({
        // The latest version properties can be considered common properties
        // too (the MIME type is there, for example)
        fields: {
          properties: [],
          'versions.element(0)': []
        },
        // Get property definitions to support table columns
        includeResources: ['metadata'],
        // Ask the server to check for permitted actions
        commands: commands.getAllSignatures()
      });
    }

  });

  return NodesTableReportCollectionFactory;

});

csui.define('webreports/utils/contexts/factories/nodestablereportcolumns',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'webreports/utils/contexts/factories/nodestablereport'
], function (module, _, Backbone, CollectionFactory, NodesTableReportCollectionFactory) {

  var NodesTableReportColumnsCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'nodestablereport_columns',

    constructor: function NodesTableReportColumnsCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      var columns = this.options.columns || {};
      var nodestablereport_columns = this.options.nodestablereport_columns || {};
      if (!(columns instanceof Backbone.Collection)) {
        var children = context.getCollection(NodesTableReportCollectionFactory, { attributes: nodestablereport_columns.attributes });
        columns = children.columns;
      }
      this.property = columns;
    }

  });

  return NodesTableReportColumnsCollectionFactory;

});

csui.define('webreports/models/nodestablereport/impl/nodestablereport.columns',["csui/lib/backbone"], function (Backbone) {

  var TableColumnModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  var TableColumnCollection = Backbone.Collection.extend({

    model: TableColumnModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new TableColumnCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    }


  });

  // Fixed (system) columns have sequence number < 100, dynamic columns
  // have sequence number > 1000

  var tableColumns = new TableColumnCollection([
    {
      key: 'type',
      sequence: 10,
      titleIconInHeader: 'mime_type',
    },
    {
      key: 'name',
      sequence: 20
    },
    {
      key: 'reserved',
      sequence: 30,
      noTitleInHeader: true // don't display a column header
    },
    {
      key: 'size',
      sequence: 40
    },
    {
      key: 'modify_date',
      sequence: 50
    },
    {
      key: 'favorite',
      sequence: 910,
      noTitleInHeader: true, // don't display a column header
      permanentColumn: true // don't wrap column due to responsiveness into details row
    }
  ]);

  return tableColumns;

});


csui.define('webreports/controls/nodestablereport/impl/nodestablereport.toolbaritems',['csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory'
], function (_, lang, ToolItemsFactory) {

  var toolbarItems = {
    tableHeaderToolbar: new ToolItemsFactory({
      main: [
        {
          signature: "Properties",
          name: lang.ToolbarItemInfo,
          icon: "icon icon-toolbar-metadata"
        },
        {signature: "Edit", name: lang.ToolbarItemEdit},
        {signature: "EmailLink", name: lang.ToolbarItemShare},
        {signature: "Download", name: lang.ToolbarItemDownload},
        {signature: "InlineEdit", name: lang.ToolbarItemRename, onlyInTouchBrowser: true},
        {signature: "ReserveDoc", name: lang.ToolbarItemReserve},
        {signature: "UnreserveDoc", name: lang.ToolbarItemUnreserve},
        {signature: "Copy", name: lang.ToolbarItemCopy},
        {signature: "Move", name: lang.ToolbarItemMove},
        {signature: "AddVersion", name: lang.ToolbarItemAddVersion}
      ],
      shortcut: [
        {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
        {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
        {signature: "OriginalReserveDoc", name: lang.ToolbarItemOriginalReserve},
        {signature: "OriginalUnreserveDoc", name: lang.ToolbarItemOriginalUnreserve},
        {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
        {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
        {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
        {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
      ]
    }),

    inlineActionbar: new ToolItemsFactory({
          other: [
            {
              signature: "Properties", name: lang.ToolbarItemInfo,
              icon: "icon icon-toolbar-metadata"
            },
            {signature: "Edit", name: lang.ToolbarItemEdit, icon: "icon icon-toolbar-edit"},
            {signature: "EmailLink", name: lang.ToolbarItemShare, icon: "icon icon-toolbar-share"},
            {
              signature: "Download", name: lang.ToolbarItemDownload,
              icon: "icon icon-toolbar-download"
            },
            {
              signature: "ReserveDoc", name: lang.ToolbarItemReserve,
              icon: "icon icon-toolbar-reserve"
            },
            {
              signature: "UnreserveDoc",
              name: lang.ToolbarItemUnreserve,
              icon: "icon icon-toolbar-unreserve"
            },
            {signature: "Copy", name: lang.ToolbarItemCopy, icon: "icon icon-toolbar-copy"},
            {signature: "Move", name: lang.ToolbarItemMove, icon: "icon icon-toolbar-move"},
            {
              signature: "AddVersion",
              name: lang.ToolbarItemAddVersion,
              icon: "icon icon-toolbar-add-version"
            },
            {
              signature: "InlineEdit", name: lang.ToolbarItemRename,
              icon: "icon icon-toolbar-rename"
            }
          ]
        },
        {
          maxItemsShown: 5,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more"
        }),

    // Menu list for the Item Name's dropdown menu in Properties view
    dropdownMenuListInProperties: new ToolItemsFactory({
          main: [
            {signature: "Edit", name: lang.ToolbarItemEdit},
            {signature: "EmailLink", name: lang.ToolbarItemShare},
            {signature: "Download", name: lang.ToolbarItemDownload},
            {signature: "ReserveDoc", name: lang.ToolbarItemReserve},
            {signature: "UnreserveDoc", name: lang.ToolbarItemUnreserve},
            {signature: "Copy", name: lang.ToolbarItemCopy},
            {signature: "Move", name: lang.ToolbarItemMove},
            {signature: "AddVersion", name: lang.ToolbarItemAddVersion}
          ],
          shortcut: [
            {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
            {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
            {signature: "OriginalReserveDoc", name: lang.ToolbarItemOriginalReserve},
            {signature: "OriginalUnreserveDoc", name: lang.ToolbarItemOriginalUnreserve},
            {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
            {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
            {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
            {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
          ]
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-expandArrowDown"
        }
    )

  };

  return toolbarItems;

});

csui.define('webreports/controls/nodestablereport/impl/nodestablereport.toolbaritems.masks',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  // Keep the keys in sync with csui/widgets/nodestable/toolbaritems
  var toolbars = ['tableHeaderToolbar', 'inlineActionbar'];

  function ToolbarItemsMasks() {
    var config = module.config(),
        globalMask = new GlobalMenuItemsMask();
    // Create and populate masks for every toolbar
    this.toolbars = _.reduce(toolbars, function (toolbars, toolbar) {
      var mask = new ToolItemMask(globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        source = source[toolbar];
        if (source) {
          mask.extendMask(source);
        }
      });
      // Enable restoring the mask to its initial state
      mask.storeMask();
      toolbars[toolbar] = mask;
      return toolbars;
    }, {});
  }

  ToolbarItemsMasks.toolbars = toolbars;

  return ToolbarItemsMasks;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/controls/nodestablereport/impl/nodestablereport',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "\r\n        <div class=\"tile-title\">\r\n             <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n        </div>\r\n\r\n    </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"tile-type-icon\">\r\n                <span class=\"icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n            </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"5":function(depth0,helpers,partials,data) {
    var helper;

  return "                <div class=\"tile-type-image "
    + this.escapeExpression(((helper = (helper = helpers.imageClass || (depth0 != null ? depth0.imageClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageClass","hash":{}}) : helper)))
    + "\">\r\n                    <img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageUrl","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\">\r\n                </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n<div class=\"webreports-nodestablereport-view\">\r\n    <div id=\"tableview\"></div>\r\n    <div id=\"paginationview\"></div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_controls_nodestablereport_impl_nodestablereport', t);
return t;
});
/* END_TEMPLATE */
;
// Lists explicit locale mappings and fallbacks

csui.define('webreports/controls/nodestablereport/impl/nls/nodestablereport.lang',{
    // Always load the root bundle for the default locale (en-us)
    "root": true,
    // Do not load English locale bundle provided by the root bundle
    "en-us": false,
    "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/controls/nodestablereport/impl/nls/root/nodestablereport.lang',{
    dialogTitle: 'Nodes Table Report'
});



csui.define('css!webreports/controls/nodestablereport/impl/nodestablereport',[],function(){});
csui.define('webreports/controls/nodestablereport/nodestablereport.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/handlebars', 'csui/lib/marionette',  // 3rd party libraries
    'module',
    'csui/utils/contexts/factories/connector',
    'csui/controls/table/table.view',
    'csui/controls/pagination/nodespagination.view',
    'csui/controls/toolbar/toolbar.view',
    'csui/utils/commands',
    'csui/utils/base',
    'csui/controls/toolbar/toolbar.command.controller',
    'csui/controls/tableactionbar/tableactionbar.view',
    'csui/behaviors/default.action/default.action.behavior',
    'csui/controls/progressblocker/blocker',
    'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
    'webreports/utils/contexts/factories/nodestablereportcolumns',
    'webreports/utils/contexts/factories/nodestablereport',
    'webreports/models/nodestablereport/impl/nodestablereport.columns',
    'webreports/controls/nodestablereport/impl/nodestablereport.toolbaritems',
    'webreports/controls/nodestablereport/impl/nodestablereport.toolbaritems.masks',
    'webreports/mixins/webreports.view.mixin',
    'hbs!webreports/controls/nodestablereport/impl/nodestablereport',
    'i18n!webreports/controls/nodestablereport/impl/nls/nodestablereport.lang',
    'css!webreports/controls/nodestablereport/impl/nodestablereport',
    'css!webreports/style/webreports.css'
], function (_, $, Handlebars, Marionette, module,ConnectorFactory, TableView, PaginationView, ToolbarView, commands, base, ToolbarCommandController, TableActionBarView, DefaultActionBehavior, BlockingView, LayoutViewEventsPropagationMixin, NodesTableReportColumnCollectionFactory, NodesTableReportCollectionFactory, nodesTableReportColumns, toolbarItems, ToolbarItemsMasks, WebReportsViewMixin, template, lang) {
    "use strict";

    var config = module.config();
    _.defaults(config, {
        defaultPageSize: 30,
        defaultPageSizes: [30, 50, 100],
        showInlineActionBarOnHover: true,
        forceInlineActionBarOnClick: false,
        inlineActionBarStyle: "csui-table-actionbar-bubble",
        clearFilterOnChange: true,
        resetOrderOnChange: false,
        resetLimitOnChange: true,
        fixedFilterOnChange: false
    });

    var NodesTableReportView = Marionette.LayoutView.extend({

        template: template,

        regions: {
            tableRegion: '#tableview',
            paginationRegion: '#paginationview'
        },

        behaviors: {

            DefaultAction: {
                behaviorClass: DefaultActionBehavior
            }

        },

        constructor: function NodesTableReportView(options) {

            // Set up the options with correctly initialized values
            options = this._processOptions(options);

            // Prepare the options to pass onto the collection
            var modelOptions = this.setCommonModelOptions(options);

            // Allow blocking with the spinner indicator
            BlockingView.imbue(this);

            // Set up Marionette prototype chain
            Marionette.LayoutView.prototype.constructor.call(this, options);

            // Ensure regions correctly respond to any actions show callbacks when called against the layout view
            this.propagateEventsToRegions();

            this.collection = this.options.collection || this.context.getCollection(NodesTableReportCollectionFactory, { attributes: modelOptions });
            // Set the RestAPI expand options for node fields.
            this.collection.setExpand('properties', ['parent_id', 'reserved_user_id']);
            this.columns = this.options.columns || this.context.getCollection(NodesTableReportColumnCollectionFactory, { attributes: modelOptions });

        },

        onRender: function () {

            if (this.collection) {

                this._setTableView(this.options);
                this._setPagination();

            }

            this.tableRegion.show(this.tableView);
            this.paginationRegion.show(this.paginationView);

        },

        templateHelpers: function () {
            var helpers = {
                title: base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle),
                icon: this.options.data.titleBarIcon || 'title-webreports'
            };

            // Check if the header is disabled using `header: false` in the options.
            if (this.options.data.header !== false){
                _.extend(helpers,{header: true});
            }

            return helpers;
        },

        _processOptions: function(options){

            if (_.isUndefined(options)){
                options = {};
            }

            // Process options and set some default values
            _.defaults(options, {
                data: {},
                pageSize: config.defaultPageSize,
                ddItemsList: config.defaultPageSizes,
                toolbarItems: toolbarItems,
                clearFilterOnChange: config.clearFilterOnChange,
                resetOrderOnChange: config.resetOrderOnChange,
                resetLimitOnChange: config.resetLimitOnChange,
                fixedFilterOnChange: config.fixedFilterOnChange
            });

            // Set page size values for pagination control
            var pageSize  = options.data.pageSize || options.pageSize,
                pageSizes = options.data.pageSizes || options.ddItemsList;

            if (!_.contains(pageSizes, pageSize)) {
                pageSizes.push(pageSize);
                options.data.pageSizes = pageSizes.sort();
            }

            // Set the title bar icon for the control.
            options.data.titleBarIcon = ( _.has(options.data, 'titleBarIcon')) ? 'title-icon '+ options.data.titleBarIcon : 'title-icon title-webreports';

            // Process the context and connector
            this.context = options.context;
            if (!options.connector) {
                options.connector = this.context.getObject(ConnectorFactory);
            }
            this.connector = options.connector;

            // Process the table columns
            this.tableColumns = options.tableColumns || nodesTableReportColumns.deepClone();

            // Process the commands that show in the header and inline action bar
            this.commands = options.commands || commands;
            this.commandController = new ToolbarCommandController({commands: this.commands});

            // Process any toolbarItemMasks
            // TODO: this isn't fully implemented for this table yet. At the moment this code is here to prevent errors and do some basic setup.
            if (!options.toolbarItemsMasks) {
                options.toolbarItemsMasks = new ToolbarItemsMasks();
            }

            this.options = options;

            return options;
        },

        _setTableView: function (options) {
            options || (options = {});

            var args = _.extend({
                context: this.options.context,
                connector: this.connector,
                collection: this.collection,
                columns: this.columns,
                tableColumns: this.tableColumns,
                pageSize: this.options.data.pageSize || this.options.pageSize,
                originatingView: this,
                columnsWithSearch: ["name"],
                orderBy: this.options.data.orderBy || this.options.orderBy,
                filterBy: this.options.filterBy,
                actionItems: this.defaultActionController.actionItems,
                commands: this.defaultActionController.commands,
                blockingParentView: this,
                parentView: this,
                clientSideDataOperation: false,
                alternativeHeader: {
                    viewClass: ToolbarView,
                    options: {
                        toolbarItems: this.options.toolbarItems,
                        toolbarItemsMask: this.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
                        toolbarCommandController: this.commandController
                    }
                },
                inlineBar: {
                    viewClass: TableActionBarView,
                    options: _.extend({
                        collection: this.options.toolbarItems.inlineActionbar,
                        toolItemsMask: this.options.toolbarItemsMasks.toolbars.inlineActionbar,
                        delayedActions: this.collection.delayedActions,
                        container: this.container,
                        containerCollection: this.collection
                    }, this.options.toolbarItems.inlineActionbar.options, {
                        inlineBarStyle: config.inlineActionBarStyle,
                        forceInlineBarOnClick: config.forceInlineActionBarOnClick,
                        showInlineBarOnHover: config.showInlineActionBarOnHover
                    })
                }
            }, options);

            this.tableView = new TableView(args);

            this._setTableViewEvents();
        },

        _setPagination: function () {
            this.paginationView = new PaginationView({
                collection: this.collection,
                pageSize: this.options.data.pageSize || this.options.pageSize
            });
            return true;
        },

        _setTableViewEvents: function(){

            // Listen for the node click and execute the default action
            this.listenTo(this.tableView, 'execute:defaultAction', function (node) {
                var args = {node: node};
                this.trigger('before:defaultAction', args);
                if (!args.cancel) {
                    var self = this;
                    this.defaultActionController.executeAction(node, {
                        context: this.options.context,
                        originatingView: this
                    }).done(function () {
                        self.trigger('executed:defaultAction', args);
                    });
                }
            });

        }

    });

    _.extend(NodesTableReportView.prototype, LayoutViewEventsPropagationMixin);

    // Add the mixin functionality to the target view
    WebReportsViewMixin.mixin(NodesTableReportView.prototype);

    return NodesTableReportView;
});
csui.define('webreports/widgets/nodeslistreport/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/widgets/nodeslistreport/impl/nls/root/lang',{
  dialogTitle: 'WebReports NodesList',
  searchPlaceholder: 'Search NodesList Report',
  emptyListText: 'No results found.'
});


// Shows a list of nodes returned by a WebReport
csui.define('webreports/widgets/nodeslistreport/nodeslistreport.view',['csui/lib/underscore',
    'csui/lib/marionette',
    'csui/utils/base',
    'csui/controls/list/list.view',
    'csui/controls/listitem/listitemstandard.view',
    'csui/controls/progressblocker/blocker',
    'webreports/widgets/nodeslistreport/impl/expanding.behavior',
    'csui/behaviors/default.action/default.action.behavior',
    'webreports/utils/contexts/factories/nodestablereport',
    'webreports/controls/nodestablereport/nodestablereport.view',
    'csui/controls/node-type.icon/node-type.icon.view',
    'webreports/mixins/webreports.view.mixin',
    'i18n!webreports/widgets/nodeslistreport/impl/nls/lang',
    'css!webreports/style/webreports.css'
], function (_, Marionette, base, ListView, StandardListItem, BlockingView,
             ServerExpandingBehavior, DefaultActionBehavior, NodesTableReportChildrenCollectionFactory,
             NodesTableReportView, NodeTypeIconView, WebReportsViewMixin, lang) {

    var NodesListReportView = ListView.extend({

        constructor: function NodesListReportView(options) {
            options || (options = {});
            options.data || (options.data = {});
            options.data.titleBarIcon = ( _.has(options.data, 'titleBarIcon') && options.data.titleBarIcon !== "") ? 'title-icon '+ options.data.titleBarIcon : 'title-icon title-webreports';
            // This option gets passed onto the NodesTableView on expand to prevent getting two headers loaded.
            options.data.header = false;

            BlockingView.imbue({
                parent: this
            });

            ListView.prototype.constructor.apply(this, arguments);
        },

        events: function(){
            return _.extend({},ListView.prototype.events,{
                'click @ui.moreLink': 'onMoreLinkClick',
                'keyup @ui.searchBox': 'onSearchKeyUp',
                'keydown @ui.searchBox': 'onSearchKeyDown'
            });
        },

        ui: function(){
            return _.extend({},ListView.prototype.ui,{
                'moreLink': '.cs-more.tile-expand'
            });
        },

        initialize: function() {

            var options = this.options,
                modelOptions;

            modelOptions = this.setCommonModelOptions(options);

            this.collection = this.options.collection ||
                this.options.context.getCollection(NodesTableReportChildrenCollectionFactory, { attributes: modelOptions });

            // Ensure a check is done for an empty collection so the expand button is hidden.

            this.listenTo(this.collection, 'reset', this.enableMoreLink);

            // Handle name filtering in the search box
            // This will use server-side name filtering

            this.listenTo(this, 'change:filterValue', this.synchronizeCollections);

            // Watch for requests going to the server and back to implement the loading indicator.
            this.listenTo(this.collection, 'request', this.waitingOnServer);
            this.listenTo(this.collection, 'sync error', this.responseFromServer);
        },

        enableMoreLink: function () {
            var enable = !this.isEmpty();
            // Hide the expand button if no results were returned from the server.
            this.ui.moreLink[enable ? 'removeClass' : 'addClass']('hidden');
        },

        isEmpty: function () {
            return this.collection.fetched && this.collection.models.length === 0 && !this.blocking;
        },

        waitingOnServer: function() {
            this.blocking = true;
            this.blockActions();
        },

        responseFromServer: function() {
            this.blocking = false;
            this.unblockActions();
            this.render();
        },

        emptyViewOptions: {
            text: lang.emptyListText
        },

        childEvents: {
            'click:item': 'onClickItem',
            'render': 'onRenderItem',
            'before:destroy': 'onBeforeDestroyItem'
        },

        templateHelpers: function () {
            return {
                title: base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle),
                icon: this.options.data.titleBarIcon,
                searchPlaceholder: base.getClosestLocalizedString(this.options.data.searchPlaceholder, lang.searchPlaceholder)
            };
        },

        childView: StandardListItem,

        childViewOptions: {
            templateHelpers: function () {
                return {
                    name: this.model.get('name'),
                    enableIcon: true
                };
            }
        },

        blocking: false,

        emptySearch: false,

        behaviors: {

            ExpandableList: {
                behaviorClass: ServerExpandingBehavior,
                expandedView: NodesTableReportView,
                expandedViewOptions: function () {
                    return this.options;
                },

                orderBy: 'name asc',
                titleBarIcon: function () {
                    return this.options.data.titleBarIcon;
                },
                dialogTitle: function () {
                    return base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle);
                },
                dialogTitleIconRight: "icon-tileCollapse",
                dialogClassName: 'webreports-nodeslistreport-table'
            },

            DefaultAction: {
                behaviorClass: DefaultActionBehavior
            }

        },

        // the prototype function in list.view.js assumes client-side data, so every change updates the collection
        // we are making REST request which needs to happen only after end of input.
        // so the following 4 functions take care of that
         filterNodeList: function(filterValue) {
             this.options.filterValue = filterValue;
             this.trigger('change:filterValue');
             this.ui.searchInput.focus();
         },

         onSearchKeyUp: function(event) {
             clearTimeout(this.keyTimer);
             if (event.which === 27) {
                // ESC key should clear field
                this.searchFieldClearerClicked();
             }
             else {
                this.keyTimer = setTimeout(_.bind(this.filterNodeList,this,this.ui.searchInput.val()),600);
             }
         },

         onSearchKeyDown: function(event) {
             if (event.which === 13) {
                 // RETURN key should be ignored to prevent a page reload
                 event.preventDefault();
                 return false;
             }
             clearTimeout(this.keyTimer);
         },

         searchFieldClearerClicked: function () {
             this.ui.searchInput.val('');
             this.emptySearch = true;
             this.filterNodeList('');
         },

        filterChanged: function (event) {
            // disabled (see previous comment)
            return false;
        },

        // Workaround for until LPAD-53271 is implemented:
        // Lets the carousel widget know when the expandedView is collapsed
        _onCollapseExpandedView: function(){
            this.view.triggerMethod('collapse');
        },

        onBeforeDestroyItem: function (childView) {
            if (childView._nodeIconView) {
                childView._nodeIconView.destroy();
            }
        },

        onClickItem: function (target) {
            this.triggerMethod('execute:defaultAction', target.model);
        },

        onClickHeader: function( target) {
            // Only expand the view when the header is clicked
            // if results were returned from the server.
            if ( !this.isEmpty() ){
                this.triggerMethod('expand');
            }
        },

        onMoreLinkClick: function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.triggerMethod('expand');
        },

        onRender: function () {
            var listViewOnRender = ListView.prototype.onRender;

            if ( listViewOnRender ) {
                // Call prototype onRender so we get the events correctly bound.
                listViewOnRender.apply(this, arguments);
            }

            if (_.has(this.collection.filters, "name") || this.emptySearch) {

                // ListView onRender hides and toggles off these elements. Need to revert this.
                this.ui.searchInput.show();
                this.ui.clearer.toggle(true);

                this.ui.searchInput.val(this.collection.filters.name);
                this.ui.searchInput.focus();
                this.ui.headerTitle.toggle();
                this.emptySearch = false;

            }

            this.collection.setExpand('properties', ['parent_id', 'reserved_user_id']);
        },

        onRenderItem: function (childView) {
            childView._nodeIconView = new NodeTypeIconView({
                el: childView.$('.csui-type-icon').get(0),
                node: childView.model
            });
            childView._nodeIconView.render();
        },

        synchronizeCollections: function () {
            var keyword = this.options.filterValue;
            // If a name filter is applied and the keyword is blank then
            // we need to clear the filter
            if (!keyword.length && _.has(this.collection.filters, "name")) {
                this.collection.clearFilter();
                this.emptySearch = true;
            }
            if (keyword.length >= 3) {
                this.collection.setFilter({name: keyword});
                this.collection.reset();
            } else {
                this.collection.reset(this.collection.models);
            }
        }


    });

    // Add the mixin functionality to the target view
    WebReportsViewMixin.mixin(NodesListReportView.prototype);

    return NodesListReportView;

});


csui.define('json!webreports/widgets/nodeslistreport/nodeslistreport.manifest.json',{
  "$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
  "title": "{{widgetTitle}}",
  "description": "{{widgetDescription}}",
  "kind": "tile",
  "supportedKinds": ["tile"],
  "schema": {
    "type": "object",
    "properties": {
      "title": {
        "title": "{{tileTitle}}",
        "description": "{{tileDescription}}",
        "type": "object"
      },
      "titleBarIcon": {
        "title": "{{iconTitle}}",
        "description": "{{iconDescription}}",
        "type": "string"
      },
      "searchPlaceholder": {
        "title": "{{placeHolderTitle}}",
        "description": "{{placeHolderDescription}}",
        "type": "object"
      },
      "id": {
        "title": "{{idTitle}}",
        "description": "{{idDescription}}",
        "type": "integer"
      },
      "parameters": {
        "type": "array",
        "title": "{{reportParamTitle1}}",
        "description": "{{reportParamDescription1}}",
        "items": {
          "type": "object",
          "title": "{{reportParamTitle2}}",
          "description": "{{reportParamDescription2}}",
          "properties": {
            "name": {
              "type": "string",
              "title": "{{paramNameTitle}}",
              "description": "{{paramNameDescription}}"
            },
            "value": {
              "type": "string",
              "title": "{{paramValTitle}}",
              "description": "{{paramValDescription}}"
            }
          }
        }
      }
    },
    "required": ["id"]
  },  
  "options": {
    "fields": {
      "id": {
        "type": "otcs_node_picker",
        "type_control": {
          "parameters": {
            "select_types": [30303]
          }
        }
      },
      "title": {
        "type": "otcs_multilingual_string"
      },
      "searchPlaceholder": {
        "type": "otcs_multilingual_string"
      }
    }
  }
});

csui.define('webreports/widgets/nodeslistreport/impl/nls/nodeslistreport.manifest',{
	// Always load the root bundle for the default locale (en-us)
	"root": true,
	// Do not load English locale bundle provided by the root bundle
	"en-us": false,
	"en": false
});

csui.define('webreports/widgets/nodeslistreport/impl/nls/root/nodeslistreport.manifest',{
	"widgetTitle": "Nodes List WebReport",
	"widgetDescription": "Loads an expandable Nodes List based on the output of a WebReport",
	"tileTitle": "Title",
	"tileDescription": "Title for the tile",
	"iconTitle": "Icon class",
	"iconDescription": "CSS class supplying the icon in the tile header",
	"placeHolderTitle": "Search Placeholder",
	"placeHolderDescription": "Specify custom string to be used when the user clicks search",
	"idTitle": "WebReport ID",
	"idDescription": "DataID for the WebReport which contains the HTML",
	"reportParamTitle1": "WebReport Parameters",
	"reportParamDescription1": "Key/Value pairs of parameters to be passed into the WebReport.",
	"reportParamTitle2": "WebReport Parameters",
	"reportParamDescription2": "Key/Value pairs of parameters to be passed into the WebReport.",
	"paramNameTitle": "Parameter Name",
	"paramNameDescription": "The name of the URL parameter.",
	"paramValTitle": "Parameter Value",
	"paramValDescription": "The value of the URL parameter."
});

csui.define('webreports/models/widget.carousel/folder.model',[
    'csui/lib/underscore',
    'csui/lib/backbone',
    'webreports/utils/url.webreports',
    'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, UrlWebReports, ConnectableMixin) {

    //todo:  use models/node/node.model instead?

    var CarouselFolderModel = Backbone.Model.extend({

        // Constructor gives an explicit name to the object in the debugger
        constructor: function CarouselFolderModel(attributes, options) {
            Backbone.Model.prototype.constructor.apply(this, arguments);

        }

    });

    return CarouselFolderModel;

});

csui.define('webreports/models/widget.carousel/folder.collection',[
    'csui/lib/underscore', 'csui/lib/backbone', // 3rd party libraries
    'webreports/utils/url.webreports',
    'webreports/models/widget.carousel/folder.model',
    'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, UrlWebReports, CarouselFolderModel, ConnectableMixin) {

    //todo:  use models/node/node.model instead?

    var CarouselFolderCollection = Backbone.Collection.extend({

        // Constructor gives an explicit name to the object in the debugger
        constructor: function CarouselFolderCollection(models, options) {
            Backbone.Collection.prototype.constructor.apply(this, arguments);

            if (_.isUndefined(options)){
                options = {};
            }

            // todo: this should be source_folder_id or similar:
            if (options && options.id && !this.id) {
                this.id = options.id;
            }

            /* Required options:
                source_folder_id => The parentID that contains the types you want to show:
                max_items  => the maximum number of items returned by the restAPI, which affect how many slides end up in the carousel
                mime_type =>  Integer, subtype of the type of nodes to return.  This might just affect HTML/img/video mimetypes, might be programmatically set?
                sort => controls the sort column
                sort_dir => controls sort direction: "asc" or "desc"
            */
            this.options = options;

            // Enable this model for communication with the CS REST API
            this.makeConnectable(options);
        },

        model: CarouselFolderModel,


        // Computes the REST API URL using the connection options
        url: function () {

            var query = '',
                context = this.options.context || undefined,
                parameters = this.options.parameters || undefined;

            // Append any WebReport parameters to the RestURL if present
            //query = UrlWebReports.appendWebReportParameters(query, parameters);

            // Append the containerID parameter to the RestURL if present
           // query = UrlWebReports.appendCurrentContainer(query, context);

            // This will ultimately depend on the content types of the slide.
            // For now, start with getting the contents of a CS folder:

            // example:
            //      .../cs.exe/api/v1/nodes/97823/nodes?extra=false&commands=default&limit=100&sort=asc_create_date
            return UrlWebReports.combine(this.connector.connection.url + '/nodes/' + this.id,
                '/nodes?extra=false&commands=default&limit=100&sort=asc_create_date');
        },

        // Massage the server response, so that it looks like object attributes
        parse: function (response) {
            return response.data;
        }

    });

    ConnectableMixin.mixin(CarouselFolderCollection.prototype);

    return CarouselFolderCollection;

});

csui.define('webreports/utils/contexts/factories/carousel.collection.factory',[
    'module',
    'csui/lib/underscore',
    'csui/lib/backbone',
    'csui/utils/contexts/factories/factory',
    'csui/utils/contexts/factories/connector',
    'webreports/models/widget.carousel/folder.collection'
], function (module,_, Backbone, CollectionFactory, ConnectorFactory, CarouselFolderCollection) {

    var CarouselFolderCollectionFactory = CollectionFactory.extend({

        // Unique prefix of the default collection instance, when this collection is assigned
        // to a context it can be shared by multiple widgets
        propertyPrefix: 'carousel',

        constructor: function CarouselFolderCollectionFactory(context, options) {
            CollectionFactory.prototype.constructor.apply(this, arguments);

            // Obtain the server connector from the application context to share
            // the server connection with the rest of the application; include
            // the options, which can contain settings for dependent factories
            var connector = context.getObject(ConnectorFactory, options);
            options.connector = connector;
            var carousel = this.options.carousel || {};

            if (!(carousel instanceof Backbone.Collection)) {
                var config = module.config();
                carousel = new CarouselFolderCollection(carousel.models, _.extend({
                    connector: connector}, carousel.attributes, config.options, {
                    // Prefer refreshing the entire collection to rendering one row after another.
                    autoreset: true
                }));
            }

            // Expose the collection instance in the `property` key on this factory
            // instance to be used by the context
            this.property = carousel;
        },

        fetch: function (options) {
            // Just fetch the collection exposed by this factory
            return this.property.fetch(options);
        }

    });

    return CarouselFolderCollectionFactory;

});

// Lists explicit locale mappings and fallbacks

csui.define('webreports/controls/carousel/impl/nls/carousel.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/controls/carousel/impl/nls/root/carousel.lang',{
  dialogTitle: 'Carousel'
});



csui.define('css!webreports/controls/carousel/impl/carousel',[],function(){});
csui.define('webreports/controls/carousel/impl/carousel.indicator.item.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette','csui/lib/backbone', // 3rd party libraries
    'csui/controls/tile/behaviors/perfect.scrolling.behavior',
    'webreports/utils/contexts/factories/carousel.collection.factory',
    'i18n!webreports/controls/carousel/impl/nls/carousel.lang',
    'css!webreports/controls/carousel/impl/carousel'
], function (_, $, Marionette, Backbone, PerfectScrollingBehavior, CarouselCollectionFactory, lang) {

    var CarouselIndicatorItemView = Marionette.ItemView.extend({

        // Constructs a DOM element that looks like this:
        //      <li class="{{activeClass}}" data-binf-target="#carousel-main-data-container" data-binf-slide-to="{{index}}"></li>

        // No template needed as the data is defined here:
        template: false,

        tagName: "li",

        // Define the additional data-attrs:
        attributes: function () {
            return {
                "data-binf-target": "#carousel-main-data-container",
                "data-binf-slide-to": this.model.collection.indexOf( this.model )
            };
        },

        // Dynamically set the class:
        className: function () {

            var activeClass = ( this.model.collection.indexOf( this.model) === 0 )? 'binf-active' : '';

            return activeClass;
        }

    });

    return CarouselIndicatorItemView;

});

csui.define('webreports/controls/carousel/impl/carousel.indicator.collection.view',[
	'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone',// 3rd party libraries
	'csui/controls/tile/behaviors/perfect.scrolling.behavior',
	'webreports/controls/carousel/impl/carousel.indicator.item.view',
	'i18n!webreports/controls/carousel/impl/nls/carousel.lang',
	'css!webreports/controls/carousel/impl/carousel'
], function (_, $, Marionette, Backbone, PerfectScrollingBehavior, IndicatorItemView, lang) {
	
	var CarouselIndicatorCollectionView = Marionette.CollectionView.extend({

		childView: IndicatorItemView,

		tagName: "ol",

		className: "binf-carousel-indicators",

		childViewOptions: function (model, index) {

			return {
				starting_index: this.options.data.starting_index
			};
		},

		constructor: function CarouselIndicatorCollectionView(options) {

			var attributes;

			if (options && options.data) {
				
				attributes = {
					id: options.data.id,
					models: options.data.requestedWidgetModels
				};
				
			}

			// Call the parent constructor to ensure the object is built with all the inherited features.
			Marionette.CollectionView.prototype.constructor.apply(this, arguments);
		}
	});

	return CarouselIndicatorCollectionView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/controls/carousel/impl/carousel.slide.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"slide-container\" data-src=\"\">\r\n	<div class=\"slide\"></div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_controls_carousel_impl_carousel.slide.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/controls/carousel/impl/carousel.slide.item.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette','csui/lib/backbone', // 3rd party libraries
    'csui/controls/tile/behaviors/perfect.scrolling.behavior',
    'webreports/utils/contexts/factories/carousel.collection.factory',
    'i18n!webreports/controls/carousel/impl/nls/carousel.lang',
    'hbs!webreports/controls/carousel/impl/carousel.slide.item',
    'css!webreports/controls/carousel/impl/carousel'
], function (_, $, Marionette, Backbone, PerfectScrollingBehavior, CarouselCollectionFactory, lang, template) {
	
    var CarouselSlideItemView = Marionette.ItemView.extend({
        
        className: function () {
            // Check if this is the first model in the collection and mark it as active
            var activeClass = ( typeof this.model !== "undefined" && this.model.collection.indexOf( this.model ) === 0 ) ? " binf-active" : "";
            return "binf-item" + activeClass;
        },

        template: template,

        templateHelpers: function () {

            var dataURL = ( typeof this.model !== "undefined"  ) ? this.model.get("id") : "";

            return {
                dataURL:  dataURL,
                index: this._index
                };
        },
        
        onRender: function (){
            // Trigger getting content of the starting slide:
            if (this._index === this.options.starting_index) {
                this.trigger("starting:slide:added", this.$el );
            }
        }

    });

    return CarouselSlideItemView;

});

csui.define('webreports/controls/carousel/impl/carousel.slide.collection.view',[
	'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone', // 3rd party libraries
	'csui/controls/tile/behaviors/perfect.scrolling.behavior',
	'webreports/controls/carousel/impl/carousel.slide.item.view',
	'i18n!webreports/controls/carousel/impl/nls/carousel.lang',
	'css!webreports/controls/carousel/impl/carousel'
], function (_, $, Marionette, Backbone, PerfectScrollingBehavior, SlideItemView, lang) {
	
	var CarouselSlideCollectionView = Marionette.CollectionView.extend({

		childView: SlideItemView,

		childViewContainer: ".carousel-slides-container",

		className: "binf-carousel-inner",

		childViewOptions: function (model, index) {

			return {
				starting_index: this.options.data.starting_index
			};
		},

		childEvents: {
			"starting:slide:added": "onStartingChildAdded"
		},

		onStartingChildAdded: function (item) {
			this.trigger('starting:slide:added', item);
		},

		constructor: function CarouselSlideCollectionView(options) {

			if (options && options.data) {
				
				var attributes = {
							id: options.data.id,
							models: options.data.requestedWidgetModels
						};

			}

			// Call the parent constructor to ensure the object is built with all the inherited features.
			Marionette.CollectionView.prototype.constructor.apply(this, arguments);
		},

		ui: {
			carousel_container: "#carousel-main-data-container"
		},

		onRender: function () {
			// Assign the carousel listbox roll to the wrapper div
			this.$el.attr("role", "listbox");
		}
	});

	return CarouselSlideCollectionView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/controls/carousel/impl/carousel.generic',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<!-- Indicators -->\r\n<span class=\"carousel-indicators-container\"></span>\r\n\r\n<!-- Wrapper for slides -->\r\n<span class=\"carousel-slides-container\"></span>";
}});
Handlebars.registerPartial('webreports_controls_carousel_impl_carousel.generic', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/controls/carousel/carousel.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone',  // 3rd party libraries
	'csui/lib/binf/js/binf',
	'csui/utils/base',
	'csui/controls/tile/behaviors/perfect.scrolling.behavior',
	'webreports/utils/contexts/factories/carousel.collection.factory',
	'webreports/controls/carousel/impl/carousel.indicator.collection.view',
	'webreports/controls/carousel/impl/carousel.slide.collection.view',
	'i18n!webreports/controls/carousel/impl/nls/carousel.lang',
	'hbs!webreports/controls/carousel/impl/carousel.generic',
	'css!webreports/controls/carousel/impl/carousel'
], function (_, $, Marionette, Backbone, BINF, base, PerfectScrollingBehavior, CarouselCollectionFactory, IndicatorCollectionView, SlideCollectionView,  lang, template) {

	var CarouselContentView = Marionette.LayoutView.extend({

		currentSlideIndex: 0,
		nextSlideIndex: 0,
		isCycling: false,

		defaults: {
			title : "",
			titleBarIcon: "",
			header: false,
			auto_cycle: true,
			interval: 5000,
			pause_on_hover: "hover",
			wrap: true
		},

		template: template,

		tagName: "div",

		className: "binf-carousel binf-slide lazy",

		attributes: {
			"id": "carousel-main-data-container"
		},

		regions: {
			indicator_container: ".carousel-indicators-container",
			slide_container: ".carousel-slides-container"
		},

		constructor: function CarouselContentView(options) {
			// Carousel options:
			options.data.title = ( _.has( options.data, "title") ) ? base.getClosestLocalizedString(options.data.title, this.defaults.title) : this.defaults.title;
			options.data.titleBarIcon = (  _.has( options.data, "titleBarIcon") ) ? options.data.titleBarIcon : this.defaults.titleBarIcon;
			options.data.header = (  _.has( options.data, "header") ) ? options.data.header : this.defaults.header;
			options.data.behavior.auto_cycle = ( _.has( options.data, "behavior") && _.has( options.data.behavior, "auto_cycle") ) ? options.data.behavior.auto_cycle : this.defaults.auto_cycle;
			options.data.behavior.interval = ( _.has( options.data, "behavior") && _.has( options.data.behavior, "interval") ) ? options.data.behavior.interval : this.defaults.interval;
			options.data.behavior.pause_on_hover = ( _.has( options.data, "behavior") && _.has( options.data.behavior, "pause_on_hover") ) ? ((options.data.behavior.pause_on_hover) ? "hover" : false ): this.defaults.pause_on_hover;
			options.data.behavior.wrap = ( _.has( options.data, "behavior") && _.has( options.data.behavior, "wrap") ) ? options.data.behavior.wrap : this.defaults.wrap;

			// Call the parent constructor to ensure the object is built with all the inherited features.
			Marionette.LayoutView.prototype.constructor.apply(this, arguments);

			_.bindAll( this, "onAfterSlide", "onBeforeSlide", "loadSlide");
		},


		onRender: function() {
			this.getRegion('indicator_container').show(new IndicatorCollectionView(this.options));
			this.getRegion('slide_container').show(new SlideCollectionView(this.options));

			// Load the first slide:
			this.loadSlide(0);
		},

		onShow: function () {
			// set the starting state of the carousel:
			if (this.options.data.behavior.auto_cycle) {
				this.startCarousel();
			}

			// Hook for code that needs to happen during onShow:
			this.onShowCarousel(this.$el);
		},

		onDestroy: function(){
			if (this.isCycling) {
				this.pauseCarousel();
			}
		},

		events: {
			"click #carousel_play_button": "startCarousel",
			"click #carousel_pause_button": "pauseCarousel",
			"slide.binf.carousel": "onBeforeSlide",  	// Executes just before the slide transitions into the stage.
			"slid.binf.carousel": "onAfterSlide"		// Executes right after the slide has transitioned onto the stage.
		},

		onBeforeSlide: function (event) {
			// Code to run just before the slide transitions onto the stage
		},

		onAfterSlide: function ( event ){
			// Code to run after the slide has transitioned
		},

		startCarousel: function () {
			this.isCycling = true;
			this.$el.binf_carousel({
				interval: this.options.data.behavior.interval,
				pause: this.options.data.behavior.pause_on_hover,
				wrap: this.options.data.behavior.wrap
			});
		},

		pauseCarousel: function () {
			this.isCycling = false;
			this.$el.binf_carousel('pause');
		},

		onShowCarousel: function (parentEl) {
			// Hook for extra code to run between showing the carousel widget and loading the first slide.
		},

		loadSlide: function (index) {
			// Code that loads content for a slide.
		}
		
	});

	return CarouselContentView;

});
csui.define('webreports/models/widget.carousel/widget.carousel.model',[
    'csui/lib/underscore',
    'csui/lib/backbone',
    'csui/models/widget/widget.model',
    'webreports/utils/url.webreports',
    'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, WidgetModel, UrlWebReports, ConnectableMixin) {

    // todo:  this might not be necessary, look into using the csui widgetModel:
    var CarouselWidgetModel = WidgetModel.extend({
        defaults: {
            type: "",
            options: [],
            widget_loaded: false
        }
    });

    return CarouselWidgetModel;

});

csui.define('webreports/widgets/widget.carousel/widget.carousel.layout.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone',  // 3rd party libraries
	'csui/lib/binf/js/binf',
	'csui/controls/tile/behaviors/perfect.scrolling.behavior',
	'webreports/controls/carousel/carousel.view',
	'webreports/models/widget.carousel/widget.carousel.model'
], function (_, $, Marionette, Backbone, BINF, PerfectScrollingBehavior, GenericCarousel,  WidgetModel) {

	/* Widget Carousel:
			- Uses Bootstrap/binf carousel component.
			- Widget options include an array of widgets as they are configured in a normal perspective
				- Each widget in this array becomes a slide of the carousel
			- There are 2 collections here:
	 			#1) a collection of the requested widgets as per the perspective config ("WidgetSlidesCollection" = options.collection),
	 			#2) a collection of the corresponding widget models from CSUI frameworks WidgetCollection ("CSUIWidgetCollection").
	  			These aren't a 1-to-1 relationship:
					- the WidgetSlidesCollection (options.collection) will have 1 model for each slide in the carousel, containing the type (aka: path) of widget that's used and the options for that widget.
					- the CSUIWidgetCollection will  have 1 model for each unique widget type, and contains the main views/manifest for that widget.
			- A region is created on each slide to hold the widget output.
			- When a slide loads, the actual Widget is retrieved from the WidgetCollection, and its View is instantiated/collection fetched using the options passed in. It is shown to the slide's region.
			- When the current slide has completely loaded its Widget and widget content, it does the same thing for the next slide to lazy load it in the background.
	*/

	var CarouselContentView = GenericCarousel.extend({

		activeSlideIndex: 0,  // Index of the slide that's currently on the stage.
		CSUIWidgetCollection: new Backbone.Collection(),
		currentlyLoadingSlideIndex: 0, // Index of the slide that's being loading.
		currentWidgetID: null,
		currentWidgetOptions: null,
		currentWidgetContext: null,
		previousSlideIndex: 0, // Index of the slide that originally loaded and kicked off lazy-loading of the next slide (low-water mark)
		maxSlidesNum: 10,
		allSlidesSynced: false,

		constructor: function CarouselContentView(options) {

			// Verify the requested widgets:
			if (_.has(options.data, "widgets") ){

				// Max slides check:
				if (options.data.widgets.length > this.maxSlidesNum){
					options.data.widgets.splice(this.maxSlidesNum);
					console.warn( "The maximum number of widgets allowed in the carousel is " + options.data.widgets.length +".  The additional widgets have been removed from the carousel." );
				}

				// Convert options type and field names from the requested widgets to be used by the core WidgetCollection:
				_.each( options.data.widgets, function(options, index, list){

					if ( (typeof options.options ) === "string") {
						options.options = JSON.parse(options.options);
					}

					// Check if this is a CI widget.
					// If it's not a WR widget OR it's the carousel widget itself, don't add a slide for the widget:
					if ( options.type.slice( 0, options.type.indexOf("/")).toLowerCase() !== "webreports" || options.type === "webreports/widgets/carousel") {
						list.splice(index, 1);
						console.warn( "The "+ options.type +" widget is not supported in the carousel.  It has been removed." );
					}
				});

			} else {
				options.data.widgets = [];
			}

			// Create the widgetSlidesCollection:
			_.extend( options, { collection: new Backbone.Collection(options.data.widgets) });

			// Call the parent constructor to ensure the object is built with all the inherited features.
			GenericCarousel.prototype.constructor.apply(this, arguments);

			_.bindAll( this, "onAfterSlide", "onBeforeSlide", "loadSlide", "loadWidget", "fetchWidget", "postWidgetLoad");
		},

		events: {
			"slide.binf.carousel": "onBeforeSlide",
			"slid.binf.carousel": "onAfterSlide",
			"click ol.binf-carousel-indicators > li" : "onIndicatorClick"
		},

		// loads and renders a widget for a given slide index:
		onBeforeSlide: function (event) {
			var index =  $( event.relatedTarget).index();

			this.loadSlide( index );
		},

		onAfterSlide: function (event) {
			var index =  $( event.relatedTarget).index(),
				region = this.regionManager.get("slide" + index),
				currentWidget = this.collection.at(index);

			// Special case for VisualData widgets:
			// 		Force them to re-render in order for the svg to get the correct height/widget.
			if ( _.has(region, "currentView") && _.has(region.currentView, "contentView") && currentWidget.get("type").indexOf("visual.data") !== -1 && (!region.isChartRenderedInCarousel)) {

				// This is a VisualData widget, so fire its dom:refresh event to reset and render the svg:
				region.currentView.contentView.isChartRendered = false;
				region.currentView.contentView.triggerMethod("dom:refresh");
				region.isChartRenderedInCarousel = true;  // flag so this only runs the first time the slide transitions onto the stage

				// Bind events to the expandedView button:
				this.bindChartExpandedViewEvents(region.currentView);
			}
		},

		onIndicatorClick: function (event) {

			if ( !(this.allSlidesSynced)) {
				console.warn("Carousel controls are disabled until all slides are fully loaded");
				event.preventDefault();
				return false;
			}

		},

		onShowCarousel: function (parentEl) {

			var allSlides = parentEl.find(".carousel-slides-container .binf-carousel-inner").children();

			if ( this.options.data.widgets.length > 0 ) {

				// Create regions for each slide:
				for (var i = 0; i < allSlides.length; i++) {
					this.regionManager.addRegion( "slide" + i, new Marionette.Region({
						el: allSlides[i]
					}));
				}

			} else {
				// No widgets supplied, so pause the carousel:
				console.warn("The carousel is empty, please add some widgets");
				this.pauseCarousel();
			}

			// Pause the carousel until all slides are completely loaded:
			if (this.options.data.behavior.auto_cycle && this.isCycling ) {
				this.pauseCarousel();
			}

			// Hide the UI controls until all the slides are loaded:
			this.regionManager.get('indicator_container').$el.find("li").addClass("carousel-content-loading");

		},

		onDomRefresh: function(){

			// Special case for visual data widgets.
			// If the first slide contains a chart widget, this will re-render the svg:
			var firstSlideView,
				firstSlideRegion = this.regionManager.get("slide0"),
				currentWidget = this.collection.at(0);

			if (_.has(firstSlideRegion, "currentView") && currentWidget.get("type").indexOf("visual.data") !== -1 ){

				firstSlideView = firstSlideRegion.currentView;

				if (_.has(firstSlideView, "contentView") && (!firstSlideView.contentView.isChartRendered)){

					// Fire the dom:refresh for the contentView:
					firstSlideView.contentView.triggerMethod("dom:refresh");

					// Flag for later:
					firstSlideRegion.isChartRenderedInCarousel = true;

					// Bind events to the expandedView button:
					this.bindChartExpandedViewEvents(firstSlideView );
				}
			}

		},

		// Used to bind events to the expand and collapse buttons for the standard ExpandingBehavior:
		bindChartExpandedViewEvents: function( view ){

			// Bind events to the expandedView button:
			view.$el.find(".icon-tileExpand,.tile-header").on("click", {view: view, carouselView: this}, function(e){

				// Pause the Carousel:
				e.data.carouselView.onExpandWidget();


				// TODO: need an LPAD to do this in a more structured way:
				// Wait for the Collapse button to exist and hang an event off it:
				var waitForCollapseIcon = setInterval( function() {
						if ( $('.icon-tileCollapse').length > 0) {

							// Bind an event to when the Collapse icon is clicked:
							$('.icon-tileCollapse').on("click", {view: e.data.view, carouselView: e.data.carouselView}, function(e){

								// Re-render the chart:
								e.data.view.contentView.triggerMethod("dom:refresh");

								// Start the Carousel again:
								e.data.carouselView.onCollapseWidget();

							});
							clearInterval(waitForCollapseIcon);
						}
					}, 150);
			});

		},

		loadSlide: function (index) {

			var widgetPath,
				slideModel,
				slideCollection = this.regionManager.get("slide_container").currentView.collection;

			// Keep the indexes for later reference:
			this.previousSlideIndex = this.currentlyLoadingSlideIndex;
			this.currentlyLoadingSlideIndex = index;

			// Make sure we have data to work with:
			if ( !_.isUndefined( slideCollection )) {

				slideModel = slideCollection.at(index);

				if ( !_.isUndefined( slideModel )) {

					// Has this slide already been loaded?
					if ( !slideModel.get("widget_loaded") ){

                        widgetPath = slideModel.get("type");

						// capture the widget options for callbacks:
						this.currentWidgetOptions = slideModel.get("options"); // passed when constructing the widget View later on
						this.currentWidgetID = widgetPath;

						this.loadWidget(widgetPath).done(this.fetchWidget);
						
					} else {
						// Slide is already loaded, but run the wrap up function:
						this.postWidgetLoad();
					}
				}
			}
		},

		// Gets the CSUI widget model from the widget collection:
		loadWidget: function (id) {

			var widgetModel;

			widgetModel = new WidgetModel(
				{
					id: id
				},
				{
					includeView: true,
					includeManifest: false,
					includeServerModule: false,
					includeToolItems: false
				});

			this.CSUIWidgetCollection.add(widgetModel);

			return widgetModel.fetch(); // This can take some time if the widget has a lot of collateral (views/templates/controls/etc)
		},

		// Loads the view for the widget into the slide region, and fetches the widget contents:
		fetchWidget: function () {

			var key,
				view,
				childWidgetDataObject,
				newFactories,
				newFactoryKeys,
				filteredFactories = {},
				originalFactories = _.clone(this.options.context._factories),
				originalWidgetOptions = this.collection.at(this.currentlyLoadingSlideIndex).get("options"),
				region = this.regionManager.get("slide" + this.currentlyLoadingSlideIndex),
				widgetModel = this.CSUIWidgetCollection.get(this.currentWidgetID),
				WidgetView = widgetModel.get('view');

			// Construct the WidgetView:
			view = new WidgetView({
				context: this.options.context,
				data: originalWidgetOptions
			});

			// Check for the expand behaviour in the view:
			// For now, only check the top level view for the behavior and not any child views.
			if (_.has( view, "behaviors") && _.has( view.behaviors, "ExpandableList")){

				// Most likely the NodesList report that has an ExpandableList behaviour.
				this.listenTo(view, "expand", this.onExpandWidget);
				this.listenTo(view, "collapse", this.onCollapseWidget);

			}

			// Listen to the child widget to see when it's data is changed (aka response comes back from the server):
			if ( _.has(view, "model")){
				childWidgetDataObject = view.model;
			} else if (_.has(view, "collection")){
				childWidgetDataObject = view.collection;
			} else if ( _.has(view, "contentView") ) {
				// Special case for widgets that have their model/collection in a child contentView:
				// aka - visual data widget
				this.listenTo( view, "render", _.bind( this.onChildContentViewRender, this, view, this.currentlyLoadingSlideIndex) );
			}

			// Attach callback for when data from the child widget is sync'd:
			if (typeof childWidgetDataObject !== "undefined"){
				this.listenTo( childWidgetDataObject, "sync", _.bind( this.onChildSync, this, view, this.currentlyLoadingSlideIndex ) );
			}

			// Show the view in the slide's region.
			// This renders the child/contentViews as well:
			region.show(view);


			// LPAD-53273:  workaround until api/methods are available to get widget data after the perspective has loaded without re-loading everything
			// Filter out any factories in the context that have already been loaded to prevent ALL of them being
			// fetched each time a new widget is loaded into the carousel.
			if ( (_.isEmpty( originalFactories)) ) {

				// If the factories are empty, we're loading the first widget so just capture the existing factories:
				filteredFactories = view.options.context._factories;

			} else {

				// There were some objects in the factory.
				// Filter out any factories that have already been loaded:
				newFactories = this.options.context._factories;
				newFactoryKeys = _.keys(newFactories);

				for ( var i=0; i<newFactoryKeys.length; i++ ) {
					if ( !(newFactoryKeys[i] in originalFactories ) ){
						filteredFactories[newFactoryKeys[i]] = newFactories[newFactoryKeys[i]];
					}
				}
			}

			// Fetch the filteredFactories only, not the entire context:
			for ( key in filteredFactories ){
				if ( _.isFunction(filteredFactories[key].fetch ) ) {
					filteredFactories[key].fetch( _.extend( _.clone( originalWidgetOptions ) ) );
				}
			}

			this.postWidgetLoad();

		},

		/* Called after the widget is entirely loaded, which isn't directly after the slide transitions due to deferred actions.
		 We want to load the next slide if:
		 - It isn't already loaded,
		 - It's the 'next' slide, and not the slides after the next slide.
		 This needs to be called after all deferred events/actions of the widget are complete, not necessarily after the slide transition events.
		 */
		postWidgetLoad: function() {

			var nextWidgetModel,
				isLastSlide = ( this.collection.length === (this.currentlyLoadingSlideIndex + 1) ),
				currentWidget = this.collection.at(this.currentlyLoadingSlideIndex);

			if (this.currentlyLoadingSlideIndex === 0){
                // Put blip back to its normal state for the first slide
                this._restoreIndicators("li.binf-active");
			}

			// Flag the model to indicate that the slide has been loaded already:
			if (!currentWidget.get("widget_loaded")) {
				currentWidget.set("widget_loaded", true);
			}

			// We're not on the last slide, so continue:
			if (!isLastSlide){

				nextWidgetModel = this.collection.at( this.currentlyLoadingSlideIndex + 1 );

				// Load the next slide and its content:
				if ( nextWidgetModel.get("widget_loaded") !== true ) {
					this.loadSlide( this.currentlyLoadingSlideIndex + 1 );
				}

			}
		},

		_restoreIndicators: function(selector) {
			if (selector) {
                // Put blips back to their normal state:
                this.regionManager.get('indicator_container').$el.find(selector).animate({
                    "height": "16px",
                    "margin-bottom": "0px"
                }).removeClass("carousel-content-loading");
			}
		},

		// Called whenever a contentView in a child report is rendered:
		onChildContentViewRender: function(view, index) {

			var childWidgetDataObject,
				childView;

			if ( _.has(view, "contentView" ) ){

				childView = view.contentView;

				if (_.has(childView, "collection")){
					childWidgetDataObject = childView.collection;
				} else if ( _.has(childView, "model")) {
					childWidgetDataObject = childView.model;
				}
			}

			// Attach a callback for when the data for this child contentView is sync'd and dom:refresh'd:
			if (typeof childWidgetDataObject !== "undefined") {
				this.listenTo(childWidgetDataObject, "sync", _.bind(this.onChildSync, this, view, index));
			}
		},

		onChildSync: function(view, index) {

			var syncCheck,
				requestedWidget = this.collection.at(index),
				widgetType = requestedWidget.get("type");


			// Mark the child widget to indicate it's been sync'd:
			requestedWidget.set("widget_synced", true);

			// Stop listening to sync events to avoid firing unnecessary callbacks for subsequent syncs after the initial load.
			// Only on the VisualDataWidget for now, to prevent this from running each time a filter is changed after it's initially loaded, and it goes to the server for new data.
			if ( widgetType.indexOf("visual.data") !== -1 ) {

				if (_.has(view, "contentView" ) && _.has(view.contentView, "collection") ) {
					this.stopListening( view.contentView.collection, "sync");
				}

			}

			// If this is a NodesList, bind an event for when they open the Search form so the
			// Carousel doesn't cycle while they're using the search/filter control:
			if (widgetType.indexOf("nodeslistreport") !== -1 ) {
				this.listenTo(view,"change:filterValue", _.bind(this.onChildFilterValueChange, this, view) );
			}

			// Check to see if all the other models have completed their sync:
			syncCheck = this.collection.where({"widget_synced": true});

			if (syncCheck.length === this.collection.length) {
				// All the widgets are synced:
				this.onAllSlidesSynced();
			}

		},

		onAllSlidesSynced: function() {

			// Start the carousel according to config now that all slides are loaded:
			if (this.options.data.behavior.auto_cycle) {
				this.startCarousel();
			}

			// Put blips back to their normal state:
            this._restoreIndicators("li:not('.binf-active')");

			// Flag for later checks:
			this.allSlidesSynced = true;
		},

		// Called for NodesListReports:
		onChildFilterValueChange: function(view) {
			if ( view.ui.searchInput.val() === "" ) {
				// The search has been cleared, start the Carousel accordingly:
				this.onCollapseWidget();
			} else {
				// Something is still in the search bar, so pause the Carousel accordingly:
				this.onExpandWidget();
			}
		},

		onExpandWidget: function() {
			// Pause the carousel while the expandedView is open:
			if (this.isCycling) {
				this.pauseCarousel();
			}
		},

		onCollapseWidget: function() {
			// Restart the carousel once the expandedView is collapsed:
			if ( (!this.isCycling) && this.options.data.behavior.auto_cycle ){
				this.startCarousel();
			}
		}

	});

	return CarouselContentView;

});
// Lists explicit locale mappings and fallbacks

csui.define('webreports/widgets/widget.carousel/impl/nls/widget.carousel.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/widgets/widget.carousel/impl/nls/root/widget.carousel.lang',{
  dialogTitle: 'Widget Carousel'
});



/* START_TEMPLATE */
csui.define('hbs!webreports/controls/carousel/impl/carousel.tile',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n        <div class=\"tile-title\">\r\n             <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n        </div>\r\n\r\n        <div class=\"tile-controls\"></div>\r\n\r\n    </div>\r\n\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"tile-type-icon\">\r\n                <span class=\"icon title-icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n            </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "    <div class=\"webreports-tilereport-spacer\"></div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    return " carousel-tile-content";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "\r\n\r\n\r\n<div class=\"tile-content"
    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"unless","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\"></div>\r\n\r\n<div class=\"tile-footer\"></div>\r\n";
}});
Handlebars.registerPartial('webreports_controls_carousel_impl_carousel.tile', t);
return t;
});
/* END_TEMPLATE */
;
// WebReports Carousel widget view. This renders a standard csui tile to house the carousel.
csui.define('webreports/widgets/widget.carousel/widget.carousel.view',[
    'csui/lib/underscore',
    'csui/utils/base',
    'csui/controls/tile/tile.view',
    'webreports/widgets/widget.carousel/widget.carousel.layout.view',
    'i18n!webreports/widgets/widget.carousel/impl/nls/widget.carousel.lang',
    'hbs!webreports/controls/carousel/impl/carousel.tile',
    'css!webreports/controls/carousel/impl/carousel',
    'css!webreports/style/webreports.css'
], function (_, base, TileView, CarouselView, lang, template) {

    var CarouselTileView = TileView.extend({

        contentView: CarouselView,

        template: template,

        constructor: function CarouselTileView(options) {

            if (options.data && options.data.contentView){
                this.contentView = options.data.contentView;
            }

            // These options are checked and loaded in the _renderContentView function of TileView
            // before show is called for the view.
            this.contentViewOptions = options;

            // Call the parent constructor to ensure the object is built with all the inherited features.
            TileView.prototype.constructor.apply(this, arguments);
        },
        
        templateHelpers: function () {

            var helpers = {
                title: base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle),
                icon: this.options.data.titleBarIcon || 'title-webreports'
            };

            // Check if the header is disabled using `header: false` in the options.
            if (this.options.data.header === true){
                _.extend(helpers,{header:this.options.data.header});
            }

            return helpers;

        },

        onRender: function(){
            if (this.options.data.header === false){

                this.$(".tile-content")
                    // Content originally set to 90% of the div because of the header
                    // Need to reset the height
                    .height("100%")
                    // Need to override the 5px top margin assigned to the content
                    // as this breaks the tile alignment when the header is removed
                    .css('margin-top','0px');
            }
        }

    });

    return CarouselTileView;

});


csui.define('json!webreports/widgets/widget.carousel/widget.carousel.manifest.json',{
	"$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
	"title": "{{widgetTitle}}",
	"description": "{{widgetDescription}}",
	"kind": "header",
	"supportedKinds": ["tile", "header", "fullpage"],
	"schema": {
		"type": "object",
		"properties": {
			"header": {
				"title": "{{headerTitle}}",
				"description": "{{headerDescription}}",
				"type": "boolean",
				"enum": [
					true,
					false
				],
				"default": false
			},
			"title": {
				"title": "{{tileTitle}}",
				"description": "{{tileDescription}}",
				"type": "object"
			},
			"titleBarIcon": {
				"title": "{{headerIconTitle}}",
				"description": "{{headerIconDescription}}",
				"type": "string"
			},
			"behavior": {
				"type": "object",
				"title": "{{behaviorTitle}}",
				"description": "{{behaviorDescription}}",
				"properties": {
					"auto_cycle": {
						"title": "{{cycleTitle}}",
						"description": "{{cycleDescription}}",
						"type": "boolean",
						"enum": [
							true,
							false
						],
						"default": true
					},
					"interval": {
						"title": "{{intervalTitle}}",
						"description": "{{intervalDescription}}",
						"type": "integer",
						"default": 5000
					},
					"pause_on_hover": {
						"title": "{{hoverTitle}}",
						"description": "{{hoverDescription}}",
						"type": "boolean",
						"enum": [
							true,
							false
						],
						"default": true
					},
					"wrap": {
						"title": "{{loopTitle}}",
						"description": "{{loopDescription}}",
						"type": "boolean",
						"enum": [
							true,
							false
						],
						"default": true
					}
				}
			},

			"widgets": {
				"type": "widgetarray",
				"title": "{{childTitle}}",
				"description": "{{childDescription}}"
			}
		}
	},
	"options": {
		"fields": {
			"title": {
				"type": "otcs_multilingual_string"
			}
		}
	}
});

csui.define('webreports/widgets/widget.carousel/impl/nls/widget.carousel.manifest',{
	// Always load the root bundle for the default locale (en-us)
	"root": true,
	// Do not load English locale bundle provided by the root bundle
	"en-us": false,
	"en": false
});

csui.define('webreports/widgets/widget.carousel/impl/nls/root/widget.carousel.manifest',{
	"widgetTitle": "Widget Carousel",
	"widgetDescription": "This widget cycles through up to 10 slides, each of which can contain a different child widget from the Content Server WebReports widget group.",
	"headerTitle": "Show header",
	"headerDescription": "Select whether the tile will include a header that contains the title and title icon.",
	"tileTitle": "Title",
	"tileDescription": "Enter the title for the Widget Carousel.",
	"headerIconTitle": "Icon class",
	"headerIconDescription": "Enter the CSS class for the icon that will appear in the header.",
	"behaviorTitle": "Behavior",
	"behaviorDescription": "Control how the Widget Carousel behaves.",
	"cycleTitle": "Cycle automatically",
	"cycleDescription": "Select whether the Carousel rotates through the slides after loading or waits for the user to click navigation.",
	"intervalTitle": "Interval",
	"intervalDescription": "If cycling, the time in milliseconds that each slide appears before advancing to the next one.",
	"hoverTitle": "Pause on hover",
	"hoverDescription": "If cycling, select whether the slides stop advancing when the user points to the current slide or continue advancing regardless of the cursor position.",
	"loopTitle": "Loop",
	"loopDescription": "If cycling, select whether slides rotate in an endless loop or only appear once.",
	"childTitle": "Child widgets",
	"childDescription": "Add up to 10 slides, in order, by dragging a child widget from the Content Server WebReports widget group to the Child Widget Drop Area. Click each child widget to configure its options. "
});



csui.define('webreports/utils/table.validate',[
    'module',
    'csui/lib/underscore'
], function (module, _) {

    var config = module.config();
    _.defaults(config, {
        defaultPageSize: 30,
        defaultPageSizeOptions: [30, 50, 100],
        maxPageSize: 100
    });

    var tableValidate = _.extend({

        checkPageSize: function (pageSize, pageSizeOptions) {

            //if pageSize provided but no pageSizeOptions, default pageSizeOptions are used
            if (pageSize && !pageSizeOptions) {
                pageSizeOptions = config.defaultPageSizeOptions;
            }

            // check to ensure pageSize falls within available pageSizeOptions
            if (_.contains(pageSizeOptions, pageSize)) {
                return pageSize;
            }
            else {
                pageSize = config.defaultPageSize;
            }
            return pageSize;
        },

        checkPageSizeOptions: function (pageSizeOptions, pageSize) {
            
            //if pageSize provided but no pageSizeOptions, default pageSizeOptions are used
            if (pageSizeOptions && !pageSize) {
                pageSizeOptions = config.defaultPageSizeOptions;
            }

            //limit pageSizeOptions parameter to fall between 1 and the maxPageSize value
            pageSizeOptions = _.reject(pageSizeOptions, function (num) {
                return num < 1 || num > config.maxPageSize;
            });

            //verify that the provided pageSize value is contained within the pageSizeOptions array
            if (_.contains(pageSizeOptions, pageSize)) {
                return pageSizeOptions;
            }
            else {
                pageSizeOptions = config.defaultPageSizeOptions;
            }
            return pageSizeOptions;
        }

    });

    return tableValidate;
});

csui.define('webreports/models/tablereport/tablereport.model',['module', 'csui/lib/underscore', 'csui/lib/backbone', 'webreports/utils/url.webreports', 'webreports/utils/table.validate',
	'csui/models/nodechildrencolumn', 'csui/models/nodechildrencolumns', 'csui/models/node/node.model',
	'csui/models/mixins/connectable/connectable.mixin', 'csui/models/mixins/fetchable/fetchable.mixin',
	'csui/models/browsable/browsable.mixin', 'csui/models/browsable/v1.request.mixin', 'csui/models/browsable/v2.response.mixin'
], function (module, _, Backbone, UrlWebReports, tableValidate, NodeChildrenColumnModel, NodeChildrenColumnCollection, NodeModel,
	ConnectableMixin, FetchableMixin, BrowsableMixin, BrowsableV1RequestMixin, BrowsableV2ResponseMixin) {

	var TableReportColumnModel = Backbone.Model.extend({

		idAttribute: "column_key",

		constructor: function TableReportColumnModel(attributes, options) {

			Backbone.Model.prototype.constructor.apply(this, arguments);

		}

	});

	var TableReportColumnCollection = Backbone.Collection.extend({

		model: TableReportColumnModel,

		constructor: function TableReportColumnCollection(models, options) {

			Backbone.Collection.prototype.constructor.apply(this, arguments);

		}
	});

	var TableReportCollection = Backbone.Collection.extend({

		// Constructor gives an explicit name to the object in the debugger
		constructor: function TableReportCollection(attributes, options) {

			Backbone.Collection.prototype.constructor.apply(this, arguments);
			this.columns = new TableReportColumnCollection();

			//validate pageSize and pageSizeOption values
			if (options.data.pageSize || options.data.pageSizeOptions) {
				options.data.pageSize = tableValidate.checkPageSize(options.data.pageSize, options.data.pageSizeOptions);
				options.data.pageSizeOptions = tableValidate.checkPageSizeOptions(options.data.pageSizeOptions, options.data.pageSize);
			}

			if (options.data.sortBy && options.data.sortOrder) {
				// Direct calls to the model by the SDK won't have the orderBy in the options.
				if (!options.data.orderBy) {
					options.data.orderBy = options.data.sortBy + " " + options.data.sortOrder;
				}

				// This is needed for the mixins to process sorting correctly.
				options.orderBy = options.data.sortBy + " " + options.data.sortOrder;
			}

			this.orderBy = options.data.orderBy;
			this.options = options;

			// Enable this model for communication with the CS REST API
			this.makeConnectable(options)
				.makeBrowsable(options)
				.makeBrowsableV1Request(options)
				.makeBrowsableV2Response(options)
				.makeFetchable(options);
		},
		url: function () {
			var query = '',
				context = this.options.context || undefined,
				parameters = this.options.data.parameters || undefined;

			query = UrlWebReports.combineQueryString(
				query,
				this.getBrowsableUrlQuery()
			);

			// Append any WebReport parameters to the RestURL if present
			query = UrlWebReports.appendWebReportParameters(query, parameters);

			// Append the containerID parameter to the RestURL if present
			query = UrlWebReports.appendCurrentContainer(query, context);

			// Append the SWRCellID parameter to the RestURL if present
			query = UrlWebReports.appendSWRCellID(query, this.options);

			return UrlWebReports.combine(this.connector.connection.url + '/nodes/' + this.options.data.id,
				query ? '/output?format=webreport&' + query : '/output?format=webreport');
		},

		parse: function (response) {

			this.parseBrowsedState(response, this.options);

			this.columns.reset(this._processColumns(response));
			return response.data;
		},

		_processColumns: function (response) {

			var firstSortableColumn;

			// If no default sort column has been set, set this based on the first sortable column from the server
			if (this.orderBy === "") {
				firstSortableColumn = _.findWhere(response.columns, { sort: true });
				if (!_.isUndefined(firstSortableColumn)) {
					this.orderBy = firstSortableColumn.column_key + " ASC";
				}
			}

			return _.map(response.columns, _.bind(function (column) {

				var options,
					swrLaunchCell;

				if (column.name_formatted && column.name_formatted !== "") {
					column.name = column.name_formatted;
				}

				if (column.column_key === 'subwebreportid') {
					options = this.options;
					if (options && options.data && options.data.swrLaunchCell) {
						swrLaunchCell = options.data.swrLaunchCell;
						if (swrLaunchCell.iconClass) {
							column.iconClass = swrLaunchCell.iconClass;
						}
						if (swrLaunchCell.hoverText) {
							column.hoverText = swrLaunchCell.hoverText;
						}
					}
				}

				return column;

			}, this));
		}

	});

	BrowsableMixin.mixin(TableReportCollection.prototype);
	ConnectableMixin.mixin(TableReportCollection.prototype);
	BrowsableV1RequestMixin.mixin(TableReportCollection.prototype);
	BrowsableV2ResponseMixin.mixin(TableReportCollection.prototype);
	FetchableMixin.mixin(TableReportCollection.prototype);

	var originalSetFilter = TableReportCollection.prototype.setFilter;

	TableReportCollection.prototype.setFilter = function (value, attributes, options) {

		// If the filter has changed, reset the skipCount so the page reverts to 1.
		this.skipCount = 0;

		return originalSetFilter.apply(this, [value, attributes, options]);
	};

	return TableReportCollection;

});

csui.define('webreports/utils/contexts/factories/table.report.factory',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'csui/utils/contexts/factories/connector',
  'webreports/models/tablereport/tablereport.model','csui/utils/contexts/factories/node'
], function (module, _, Backbone, CollectionFactory, ConnectorFactory, TableReportCollection) {

  var TableReportCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'tablereport',

    constructor: function TableReportCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      // Obtain the server connector from the application context to share
      // the server connection with the rest of the application; include
      // the options, which can contain settings for dependent factories

      var connector = context.getObject(ConnectorFactory, options);
      options.connector = connector;
      var tablereport = this.options.tablereport || {};

      if (!(tablereport instanceof Backbone.Collection)) {
        var config = module.config();
        tablereport = new TableReportCollection(tablereport.models, _.extend({
        connector: connector}, tablereport.attributes, config.options, {
          // Prefer refreshing the entire table to rendering one row after another.
          autoreset: true
        }));
      }
      this.property = tablereport;
    },

    fetch: function (options) {
      return this.property.fetch(options);
    }

  });

  return TableReportCollectionFactory;

});

csui.define('webreports/controls/table.report/impl/table.report.columns',["csui/lib/backbone"], function (Backbone) {
	var TableColumnModel = Backbone.Model.extend({

		idAttribute: "key",

		defaults: {
			key: null,  // key from the resource definitions
			sequence: 0 // smaller number moves the column to the front
		}

	});
	var TableColumnCollection = Backbone.Collection.extend({

		model: TableColumnModel,
		comparator: "sequence"

	});
	var	tableColumns = new TableColumnCollection();
	return tableColumns;
});

/* START_TEMPLATE */
csui.define('hbs!webreports/controls/table.report/impl/table.report',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "\r\n        <div class=\"tile-title\">\r\n             <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n        </div>\r\n\r\n    </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"tile-type-icon\">\r\n                <span class=\"icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n            </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"5":function(depth0,helpers,partials,data) {
    var helper;

  return "                <div class=\"tile-type-image "
    + this.escapeExpression(((helper = (helper = helpers.imageClass || (depth0 != null ? depth0.imageClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageClass","hash":{}}) : helper)))
    + "\">\r\n                    <img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageUrl","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\">\r\n                </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n<div class=\"webreports-tablereport-view\">\r\n    <div id=\"tableview\"></div>\r\n    <div id=\"paginationview\"></div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_controls_table.report_impl_table.report', t);
return t;
});
/* END_TEMPLATE */
;
// Lists explicit locale mappings and fallbacks

csui.define('webreports/controls/table.report/impl/nls/table.report.lang',{
    // Always load the root bundle for the default locale (en-us)
    "root": true,
    // Do not load English locale bundle provided by the root bundle
    "en-us": false,
    "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/controls/table.report/impl/nls/root/table.report.lang',{
    dialogTitle: 'Table Report'
});



csui.define('css!webreports/controls/table.report/impl/table.report',[],function(){});
csui.define('webreports/controls/table.report/table.report.view',['csui/lib/underscore','csui/lib/handlebars', 'csui/lib/marionette',
	'csui/utils/contexts/factories/connector',
	'csui/controls/table/table.view',
	'csui/controls/pagination/nodespagination.view',
    'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
	'webreports/utils/contexts/factories/table.report.factory',
	'webreports/utils/table.validate',
	'webreports/controls/table.report/impl/table.report.columns',
	'hbs!webreports/controls/table.report/impl/table.report',
    'i18n!webreports/controls/table.report/impl/nls/table.report.lang',
    'css!webreports/controls/table.report/impl/table.report',
    'css!webreports/style/webreports.css'
], function (_, Handlebars, Marionette, ConnectorFactory, TableView, PaginationView, LayoutViewEventsPropagationMixin, TableReportCollectionFactory, tableValidate, TableColumns, template, lang) {
	"use strict";

	var TableReportView = Marionette.LayoutView.extend({

		template: template,

		regions: {
			tableRegion: '#tableview',
			paginationRegion: '#paginationview'
		},


		constructor: function TableLayoutView(options) {

			if(_.has(options.data, "columnsWithSearch")){
				if(typeof options.data.columnsWithSearch === "string") {

					options.data.columnsWithSearch = [options.data.columnsWithSearch];
				}
			}

            if (options.data.sortBy && options.data.sortOrder) {
                options.data.orderBy = options.data.sortBy + " " + options.data.sortOrder;
            }

			if (!this.options.tableColumns){
                this.options.tableColumns = TableColumns;
			}

            // Set the title bar icon for the control.
            options.data.titleBarIcon = ( _.has(options.data, 'titleBarIcon')) ? 'title-icon '+ options.data.titleBarIcon : 'title-icon title-webreports';


			Marionette.LayoutView.prototype.constructor.call(this, options);

            // Ensure regions correctly respond to any actions show callbacks when called against the layout view
            this.propagateEventsToRegions();

		},

		initialize: function(){
			this.collection = this.options.collection ||
				this.options.context.getCollection(TableReportCollectionFactory, {attributes: this.options});
			this.columns = this.options.context.getCollection(TableReportCollectionFactory, {attributes: this.options});

		},

		onRender: function () {


			if (this.collection) {
				this.tableView = new TableView({
					context: this.options.context,
					connector: this.options.context.getObject(ConnectorFactory),
					collection: this.collection,
					columns: this.collection.columns,
					tableColumns: this.options.tableColumns,
					selectRows: this.options.data.selectRows || 'none',
					columnsWithSearch: this.options.data.columnsWithSearch || [],
					orderBy: this.options.data.orderBy || '',
					selectColumn: false
				});
				this.setPagination();

			} else if (this.tableView) {
				this.stopListening(this.tableView);
				delete this.tableView;
			}

			this.tableRegion.show(this.tableView);
			this.paginationRegion.show(this.paginationView);


		},

        templateHelpers: function () {
            var helpers = {
                title: this.options.data.title || lang.dialogTitle,
                icon: this.options.data.titleBarIcon || 'title-webreports'
            };

            // Check if the header is disabled using `header: false` in the options.
            if (this.options.data.header !== false){
                _.extend(helpers,{header: true});
            }

            return helpers;
        },

		setPagination: function () {

			var pageSize = tableValidate.checkPageSize(this.options.data.pageSize, this.options.data.pageSizeOptions);
			var pageSizeOptions = tableValidate.checkPageSizeOptions(this.options.data.pageSizeOptions, pageSize);

			this.paginationView = new PaginationView({
				collection: this.collection,
				defaultDDList: pageSizeOptions,
				pageSize: pageSize
			});
			return true;

		}
	});

    _.extend(TableReportView.prototype, LayoutViewEventsPropagationMixin);

	return TableReportView;
});


// Lists explicit locale mappings and fallbacks

csui.define('webreports/widgets/table.report/impl/nls/table.report.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/widgets/table.report/impl/nls/root/table.report.lang',{
  dialogTitle: 'Table Report'
});



/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/table.report/impl/table.report.tile',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"tile-type-icon\">\r\n            <span class=\"icon title-icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n        </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n    <div class=\"tile-title\">\r\n        <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n    </div>\r\n\r\n    <div class=\"tile-controls\"></div>\r\n\r\n</div>\r\n\r\n<div class=\"tile-content\"></div>\r\n\r\n<div class=\"tile-footer\"></div>\r\n";
}});
Handlebars.registerPartial('webreports_widgets_table.report_impl_table.report.tile', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/widgets/table.report/table.report.view',[
	'csui/lib/underscore',
	'csui/controls/tile/tile.view',
	'webreports/controls/table.report/table.report.view',
	'webreports/controls/nodestablereport/nodestablereport.view',
	'i18n!webreports/widgets/table.report/impl/nls/table.report.lang',
	'hbs!webreports/widgets/table.report/impl/table.report.tile',
	'css!webreports/style/webreports.css'
], function (_, TileView, TableReportView, NodesTableReportView, lang, template) {

	var TableReportTileView = TileView.extend({

		contentView: TableReportView,

		template: template,

		constructor: function TableReportTileView(options) {

			if (options.data){
				// Since we're rendering a header in the tile we don't need it in the table controls
                options.data.header = false;

                if (options.data.sortBy && options.data.sortOrder) {
                	options.data.orderBy = options.data.sortBy + " " + options.data.sortOrder;
				}
			}

			// These options are checked and loaded in the _renderContentView function of TileView
			// before show is called for the view.
			this.contentViewOptions = options;

			// Call the parent constructor to ensure the object is built with all the inherited features.
			TileView.prototype.constructor.apply(this, arguments);
		},

		templateHelpers: function () {

			var helpers = {
				title: this.options.data.title || lang.dialogTitle,
				icon: this.options.data.titleBarIcon || 'title-webreports'
			};

			return helpers;

		}

	});

	return TableReportTileView;

});


csui.define('json!webreports/widgets/table.report/table.report.manifest.json',{
	"$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
	"title": "{{widgetTitle}}",
	"description": "{{widgetDescription}}",
	"kind": "fullpage",
	"supportedKinds": [
		"fullpage"
	],
	"schema": {
		"type": "object",
		"properties": {
			"title": {
				"title": "{{tileTitle}}",
				"description": "{{tileDescription}}",
				"type": "string"
			},
			"id": {
				"title": "{{sourceTitle}}",
				"description": "{{sourceDescription}}",
				"type": "integer"
			},
			"titleBarIcon": {
				"title": "{{headerIconTitle}}",
				"description": "{{headerIconDescription}}",
				"type": "string"
			},
			"columnsWithSearch": {
					"title": "{{columnFilterTitle}}",
					"description": "{{columnFilterDescription}}",
				"type": "string"
			},
			"sortBy": {
				"title": "{{sortTitle}}",
				"description": "{{sortDescription}}",
				"type": "string"
			},
			"sortOrder": {
				"title": "{{directionTitle}}",
				"description": "{{directionDescription}}",
				"type": "string",
				"enum": ["desc","asc"],
				"default": "desc"
			},
			"pageSize": {
				"title": "{{pageSizeTitle}}",
				"description": "{{pageSizeDescription}}",
				"type": "integer",
				"enum": "pageSizeOptions",
				"default": 30
			},
			"pageSizeOptions": {
				"title": "{{pageSizeOptionsTitle}}",
				"description": "{{pageSizeOptionsDescription}}",
				"type": "array",
				"default": [30, 50, 100]
			},
			"swrLaunchCell": {
				"type": "object",
				"title": "{{swrLaunchCellTitle}}",
				"description": "{{swrLaunchCellDescription}}",
				"properties": {
					"id": {
						"title": "{{swrLaunchCellIDTitle}}",
						"description": "{{swrLaunchCellIDDescription}}",
						"type": "integer"
					},
					"iconClass": {
						"title": "{{swrLaunchCellIconClassTitle}}",
						"description": "{{swrLaunchCellIconClassDescription}}",
						"type": "string"
					},
					"hoverText": {
						"title": "{{swrLaunchCellHoverTextTitle}}",
						"description": "{{swrLaunchCellHoverTextDescription}}",
						"type": "string"
					}
				}
			},
			"parameters": {
				"type": "array",
				"title": "{{parametersArrayTitle}}",
				"description": "{{parametersArrayDescription}}",
				"items": {
					"type": "object",
					"title": "{{parameterObjectTitle}}",
					"description": "{{parameterObjectDescription}}",
					"properties": {
						"name": {
							"type": "string",
							"title": "{{parameterNameTitle}}",
							"description": "{{parameterNameDescription}}"
						},
						"value": {
							"type": "string",
							"title": "{{parameterValueTitle}}",
							"description": "{{parameterValueDescription}}"
						}
					}
				}
			}
		}
	},
	"required": ["id", "sortBy", "sortOrder" ],
	"options": {
		"fields": {
			"id": {
				"type": "otcs_node_picker",
				"type_control": {
					"parameters": {
						"select_types": [
							30303
						]
					}
				}
			},
			"sortOrder": {
				"type": "select",
				"optionLabels": ["{{optionsSortOrderDsc}}", "{{optionsSortOrderAsc}}"]
			},
			"swrLaunchCell": {
				"fields": {
					"id": {
						"type": "otcs_node_picker",
						"type_control": {
							"parameters": {
								"select_types": [30303]
							}
						}
					}
				}
			}
		}
	}
});

csui.define('webreports/widgets/table.report/impl/nls/table.report.manifest',{
	// Always load the root bundle for the default locale (en-us)
	"root": true,
	// Do not load English locale bundle provided by the root bundle
	"en-us": false,
	"en": false
});

csui.define('webreports/widgets/table.report/impl/nls/root/table.report.manifest',{
	"widgetTitle": "Table Report",
	"widgetDescription": "This basic widget will take information from various sources and organize them into a table format",
	"tileTitle": "Title",
	"tileDescription": "Enter the title for the Table Report",
	"sourceTitle": "Source WebReport",
	"sourceDescription": "Browse to select the WebReport that retrieves the data that you want to render as a table",
	"headerIconTitle": "Icon class",
	"headerIconDescription": "Enter the CSS class for the icon that will appear in the header",
	"columnFilterTitle": "Name of searchable column",
	"columnFilterDescription": "Enter the name for the column that allows searching in the table header",
    "optionsSortOrderDsc": "Descending",
    "optionsSortOrderAsc": "Ascending",
    "directionTitle": "Sort Direction",
    "directionDescription": "Select whether to sort the column in Ascending or Descending order",
	"pageSizeTitle": "Page Size",
	"pageSizeDescription": "Set the number of objects that will be returned per page.",
	"pageSizeOptionsTitle": "Page Size Options",
	"pageSizeOptionsDescription": "Sets the available page size options",
	"sortTitle": "Sort By",
    "sortDescription": "Enter the column name of the default sort column",
    "swrLaunchCellTitle": "Launch WebReport Column",
	"swrLaunchCellDescription": "Show an icon in a table column to launch a WebReport",
	"swrLaunchCellIDTitle":"Icon WebReport ID",
	"swrLaunchCellIDDescription":"The ID of the WebReport that will launch when the icon is clicked",
	"swrLaunchCellIconClassTitle":"Icon Class",
	"swrLaunchCellIconClassDescription":"A CSS class to apply to the icon. Allows a custom icon to be defined",
	"swrLaunchCellHoverTextTitle":"Icon Hover Text",
	"swrLaunchCellHoverTextDescription":"Specify custom hover text to show when loading the icon",
    "parametersArrayTitle": "Source Parameters",
    "parametersArrayDescription": "Specify one or more Key/Value pairs of parameters to pass into the Source WebReport, as required",
    "parameterObjectTitle": "Source Parameters",
    "parameterObjectDescription": "Specify one or more Key/Value pairs of parameters to pass into the Source WebReport, as required",
    "parameterNameTitle": "Parameter Name",
    "parameterNameDescription": "The name of the URL parameter",
    "parameterValueTitle": "Parameter Value",
    "parameterValueDescription": "The value of the URL parameter"
});




/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "		<span class=\"icon arrow_back cs-go-back\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.go_back_tooltip || (depth0 != null ? depth0.go_back_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"go_back_tooltip","hash":{}}) : helper)))
    + "\" role=\"link\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-title-container\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.back_button : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "	<span id=\"\" class=\"title\">"
    + this.escapeExpression(((helper = (helper = helpers.webreport_name || (depth0 != null ? depth0.webreport_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"webreport_name","hash":{}}) : helper)))
    + "</span>\r\n</div>";
}});
Handlebars.registerPartial('webreports_widgets_parameter.prompt.form_impl_header_parameter.prompt.header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/widgets/parameter.prompt.form/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/widgets/parameter.prompt.form/impl/nls/root/lang',{
  goBackTooltip: 'Go back',
  runWebReport: "Run WebReport",
  cancel: "Cancel"
});



csui.define('css!webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header',[],function(){});
csui.define('webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
	'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
	'hbs!webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header',
	'i18n!webreports/widgets/parameter.prompt.form/impl/nls/lang',
	'css!webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header'
], function (_, $, Backbone, Marionette, ViewEventsPropagationMixin,
			 template, lang) {

	var PromptHeaderView = Marionette.ItemView.extend({

		className: 'webreport-parameter-prompt-header',

		template: template,

		ui: {
			backArrow: '.cs-go-back'
		},

		triggers: {
			"click @ui.backArrow": "onClickBackArrow"
		},

		constructor: function PromptHeaderView(options) {
			options || (options = {});
			this.options = options;

			Marionette.ItemView.prototype.constructor.call(this, options);

		},

		templateHelpers: function () {
			
			var model = (_.has( this.model, "models")) ? this.model.models[0] : this.model,
				showBackIcon = ( _.has(this.options, "showBackIcon") ) ? this.options.showBackIcon : true;

			return {
				webreport_name: model.get("name"),
				go_back_tooltip: lang.goBackTooltip,
				back_button: showBackIcon
			};
		},

		onClickHeader: function (event) {
			event.preventDefault();
			event.stopPropagation();
		}
	});

	return PromptHeaderView;
});

/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<button type=\"button\" class=\"binf-btn binf-btn-primary submitWR\">"
    + this.escapeExpression(((helper = (helper = helpers.runWebReport || (depth0 != null ? depth0.runWebReport : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"runWebReport","hash":{}}) : helper)))
    + "</button>\r\n<button type=\"button\" class=\"binf-btn binf-btn-secondary cancelWR\">"
    + this.escapeExpression(((helper = (helper = helpers.cancel || (depth0 != null ? depth0.cancel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel","hash":{}}) : helper)))
    + "</button>";
}});
Handlebars.registerPartial('webreports_widgets_parameter.prompt.form_impl_footer_parameter.prompt.footer', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer',[],function(){});
csui.define('webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
	'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
	'csui/utils/commands',
	'hbs!webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer',
	'i18n!webreports/widgets/parameter.prompt.form/impl/nls/lang',
	'css!webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer'
], function (_, $, Backbone, Marionette, ViewEventsPropagationMixin,
			 Commands,
			  template, lang) {

	var PromptFooterView = Marionette.ItemView.extend({

		className: 'webreport-parameter-prompt-footer',

		template: template,

		templateHelpers: function () {
			return {
				cancel: lang.cancel,
				runWebReport: lang.runWebReport
			};
		},

		ui: {
			"submitWR": "button.submitWR",
			"cancelWR": "button.cancelWR"
		},

		triggers: {
			"click @ui.submitWR": "submitWR",
			"click @ui.cancelWR": "cancelWR"
		},

		constructor: function PromptFooterView(options) {
			options || (options = {});
			this.options = options;
			this.node = this.options.model;
			Marionette.ItemView.prototype.constructor.call(this, options);
		}

	});

	return PromptFooterView;
});
csui.define('webreports/models/run.webreport.pre/run.webreport.pre.model',[
	'csui/lib/jquery',
	'csui/lib/underscore',
	'csui/lib/backbone',
	'csui/utils/base',
	'csui/models/form',
	'csui/models/mixins/connectable/connectable.mixin'
], function ($, _, Backbone, base, FormModel, ConnectableMixin) {
	'use strict';

	var RunWRPreModel = FormModel.extend({

		parametersModel: undefined,
		destinationModel: undefined,

		constructor: function RunWRPreModel(attributes, options) {

			this.options = options || (options = {});

			Backbone.Model.prototype.constructor.apply(this, arguments);

			this.makeConnectable(options);

		},

		url: function () {
			var path = "forms/nodes/run",
				connector = this.connector,
				params = {
					id: this.options.id
				},
				resource = path + '?' + $.param(params);
			return base.Url.combine( connector.connection.url, resource);
		},

		parse: function (response) {
			this.parametersModel = new Backbone.Model( response.data.parameters_data );
			this.destinationModel = new Backbone.Model( response.data.destination_data );
			return response.forms[0];
		}

	});

	ConnectableMixin.mixin(RunWRPreModel.prototype);

	return RunWRPreModel;

});

csui.define('webreports/utils/contexts/factories/run.webreport.pre.factory',[
	'csui/lib/underscore',
	'csui/utils/contexts/factories/factory',
	'csui/utils/contexts/factories/connector',
	'webreports/models/run.webreport.pre/run.webreport.pre.model'
], function (_,ModelFactory, ConnectorFactory, RunWRPreModel) {

	var runWebReportPreFactory = ModelFactory.extend({

		// Unique prefix of the default model instance, when this model is assigned
		// to a context it can be shared by multiple widgets
		propertyPrefix: 'runwebreportpre',

		constructor: function runWebReportPreFactory(context, options) {

			// Don't pass the attributes into the model:
			if (_.has(options,"attributes")){
				delete options.attributes;
			}
			if (_.has(options, this.propertyPrefix) && _.has(options[this.propertyPrefix], "attributes")){
				delete options[this.propertyPrefix].attributes;
			}

			ModelFactory.prototype.constructor.apply(this, arguments);

			// Obtain the server connector from the application context to share
			// the server connection with the rest of the application; include
			// the options, which can contain settings for dependent factories
			var connector = context.getObject(ConnectorFactory, options),
				modelOptions = _.extend( options.options, {
				connector: connector
			});

			// Expose the model instance in the `property` key on this factory
			// instance to be used by the context
			this.property = new RunWRPreModel( {}, modelOptions );
		}

	});

	return runWebReportPreFactory;

});
csui.define('webreports/utils/commands/open.classic.webreport',['csui/lib/underscore', 'csui/utils/commandhelper', 'csui/utils/commands/open.classic.page'
], function (_, CommandHelper, OpenClassicPageCommand) {

    var OpenClassicWebReportCommand = OpenClassicPageCommand.extend({

        defaults: {
            signature: 'OpenClassicWebReport',
            scope: "single"
        },
        
        enabled: function (status) {
            var node = CommandHelper.getJustOneNode(status);
            return node && node.get('type') === 30303;
        },

        getUrlQueryParameters: function (node, options) {
            var additionalParms,
                baseParms = {
                func: 'll',
                objAction: 'RunReport',
                objId: node.get('id'),
                nexturl: location.href
            };

            if ( _.has(options, "parameters") ) {
                // blend any parms entered in the prompt forms:
                baseParms = _.extend( baseParms, options.parameters );
            }

            return baseParms;
        }

    });

    return OpenClassicWebReportCommand;

});
csui.define('webreports/models/run.webreport/run.webreport.model',[
	'csui/lib/underscore',
	'csui/lib/backbone',
	'csui/utils/base',
	'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, base, ConnectableMixin ) {

	var RunWebReportModel = Backbone.Model.extend({

		constructor: function RunWebReportModel(attributes, options) {
			this.options = options || {};
			Backbone.Model.prototype.constructor.apply(this, arguments);

			this.makeConnectable(this.options);
		},

		url: function () {
			var parms,
				options = this.options,
				id = options.id,
				connector = this.connector,
				path = "nodes/"+ id +"/output";

			// Add in any prompt parameter values to the query:
			if (_.has(options, "parameters")) {

				// Support for name/value pairs in a single object only, not an array of objects:
				if ( !_.isArray(options.parameters) && _.isObject(options.parameters)){
					parms = options.parameters;
					path = path + "?" + base.Url.combineQueryString(parms);
				}

			}

			return base.Url.combine( connector.connection.url, path );

		},

		parse: function(resp, options) {
			// update the destinationModel with the resolved/current destination_data:
			if (_.has(options, "destinationModel")){
				options.destinationModel.set( resp.data.destination_data, options);
			} else {
				options.destinationModel = new Backbone.Model(resp.data.destination_data);
			}

			return resp;
		},

		// Removes any parameters passed on the model:
		clearParameters: function () {
			if ( _.has(this, "options") && _.has(this.options, "parameters") ) {
				delete( this.options.parameters);
			}
		}
		
	});

	ConnectableMixin.mixin(RunWebReportModel.prototype);

	return RunWebReportModel;

});
csui.define('webreports/utils/contexts/factories/run.webreport.factory',[
	'csui/lib/underscore',
	'csui/utils/contexts/factories/factory',
	'csui/utils/contexts/factories/connector',
	'webreports/models/run.webreport/run.webreport.model'
], function (_,ModelFactory, ConnectorFactory, RunWRModel) {

	var RunWRModelFactory = ModelFactory.extend({

		// Unique prefix of the default model instance, when this model is assigned
		// to a context it can be shared by multiple widgets
		propertyPrefix: 'runwrmodel',

		constructor: function RunWRModelFactory(context, options) {
			
			// Don't pass the attributes into the model:
			if (_.has(options,"attributes")){
				delete options.attributes;
			}
			if (_.has(options, this.propertyPrefix) && _.has(options[this.propertyPrefix], "attributes")){
				delete options[this.propertyPrefix].attributes;
			}


			ModelFactory.prototype.constructor.apply(this, arguments);

			var connector = context.getObject(ConnectorFactory, options),
				modelOptions = _.extend( options.options, {
					connector: connector
				});


			// Pass through any populated parameters:
			if (_.has(options,"parameters") ) {
				modelOptions = _.extend( modelOptions, {
					parameters: options.parameters
				});
			}

			// Expose the model instance in the `property` key on this factory
			// instance to be used by the context
			this.property = new RunWRModel({}, modelOptions);
		}

	});

	return RunWRModelFactory;

});

csui.define('webreports/controls/run.webreport.pre/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/controls/run.webreport.pre/impl/nls/root/lang',{
  WebReportParameters: "WebReport Parameters",
  RunWebReport: "Run WebReport",
  Cancel: "Cancel",
  WebReportExecutedSuccessfully: "WebReport executed successfully",
  WebReportExecutingInBackground: "WebReport is executing in background",
  anErrorOccurredExecutingTheWebReport: "An error occurred executing the WebReport",
  okLabel: "OK"
});


csui.define('webreports/utils/commands/execute.webreport',['csui/lib/underscore', 'csui/lib/jquery',
	'csui/utils/base',
	'csui/utils/commandhelper', 'csui/models/command',
	'csui/controls/globalmessage/globalmessage',
	'webreports/utils/contexts/factories/run.webreport.factory',
	'i18n!webreports/controls/run.webreport.pre/impl/nls/lang'
], function (_, $,
			 base,
			 CommandHelper, CommandModel,
			 GlobalMessage,
			 RunWRModelFactory,
			 lang ){

	var ExecuteWebReport = CommandModel.extend({

		defaults: {
			signature: 'ExecuteWebReport',
			scope: "single"
		},

		enabled: function (status) {
			var node = CommandHelper.getJustOneNode(status);
			return node && node.get('type') === 30303;
		},

		// Converts a json object of parameters into form data for POSTing:
		convertParametersToFormData: function(parameters){
			
			var serializedParms = '';
			
			if ( _.isObject( parameters ) && !_.isArray( parameters) ){

				_.each( parameters, function(value, key, list){

					var parm,
						val;

					parm = encodeURI(key);
					val = encodeURI(value);

					if (serializedParms.length) {

						serializedParms += '&' + parm + '=' + val;

					} else {

						serializedParms += parm + '=' + val;

					}

				});

			}

			return serializedParms;
		},

		execute: function (status, options) {

			// Generate a request to execute the WebReport on the server:
			var executeWRModel,
				requestAttrs,
				crud_method = "read", // GET default
				deferred = $.Deferred(),
				destinationModel = options.destinationModel,
				http_method = destinationModel.get("http_method"),
				lower_http_method = http_method.toLowerCase(),
				runInBackground = destinationModel.get("run_in_background"),
				executeOptions = {
					attributes: {
						id: options.node.get("id")
					},
					options: {
						id: options.node.get("id")
					}
				},
				hasParameters = ( _.has( options, "parameters" ) );


			executeWRModel = options.context.getModel( RunWRModelFactory, executeOptions );


			if (lower_http_method === "get") {

				// Set the CRUD value:
				crud_method = "read";

				// Pass the current parameters through the model, which are added as query parameters:
				if ( hasParameters && _.has(executeWRModel, "options" ) ) {
					executeWRModel.options =  _.extend( executeWRModel.options, {
						parameters: options.parameters
					});
				}

			} else {

				// Set the CRUD value:
				switch ( lower_http_method ) {

					case "post":
						crud_method = "create";
						break;

					case "put":
						crud_method = "update";
						break;

					case "patch":
						crud_method = "patch";
						break;

					case "delete":
						crud_method = "delete";
						break;
				}

				if ( hasParameters ) {
					// Convert the parameters object into form data for the POST:
					requestAttrs = this.convertParametersToFormData( options.parameters );
				}

			}

			// Make a request that will execute the WR:
			// 		- The success functions stores the response data as attrs, similar to the Backbone.save().
			executeWRModel
				.sync( crud_method, executeWRModel, {
					data: requestAttrs,
					success: function(resp) {
						 // store the response as the model's attrs:
						 if (resp) {
							 var serverAttrs = executeWRModel.parse(resp, options);
							 executeWRModel.set(serverAttrs, options);
						 }
						// Clear out the passed parms so they don't linger in the context:
						executeWRModel.clearParameters();
						deferred.resolve( arguments, executeWRModel );
					 },
					error: function(request, statusText, errorThrown ){
						var error = new base.Error(request);
						GlobalMessage.showMessage("error", error.message, error.errorDetails);
						executeWRModel.clearParameters();
						deferred.reject();
					}
				});


			if (runInBackground){
				// resolve right away in order to show the Status Screen now instead of after the WR has executed:
				deferred.resolve( [{}, "success"], executeWRModel, true );
			}

			return deferred.promise();

		}

	});

	return ExecuteWebReport;

});
csui.define('webreports/controls/run.webreport.pre/run.webreport.pre.controller',['csui/lib/underscore', 'csui/lib/jquery',
	'csui/models/nodes',
	'csui/utils/command.error',
	'csui/controls/globalmessage/globalmessage',
	'csui/controls/progressblocker/blocker',
	'webreports/utils/contexts/factories/run.webreport.pre.factory',
	'webreports/utils/commands/open.classic.webreport',
	'webreports/utils/commands/execute.webreport',
	'i18n!webreports/controls/run.webreport.pre/impl/nls/lang'
], function (_, $,
			 NodeCollection,
			 CommandError,
			 GlobalMessage,
			 BlockingView,
			 RunWRPreModelFactory,
			 OpenClassicWebReport,
			 ExecuteWebReportCommand,
			 lang) {
	'use strict';

	function RunWebReportPreController() {
	}

	_.extend(RunWebReportPreController.prototype, {

		runWRPreModel: undefined,
		destinationModel: undefined,
		parametersModel: undefined,


		_getCommandStatus: function(){
			var status;
			if (typeof this.commandStatus === "undefined") {
				status = {
					nodes: new NodeCollection(this.options.node)
				};
			} else {
				status = this.commandStatus;
			}

			return status;
		},

		/////////////////////////////////
		// Moved from OpenWebReport cmd
		//////////////////////////////////
		switchToPromptView: function(initialStatus, options) {

			var nodes,
				context,
				originatingView,
				self = this,
				deferred = $.Deferred(),
				status = this._getCommandStatus(),
				selected = status.nodes,
				container = status.container,
				navigationView = true;

			if (selected && selected.first() === container) {
				// The container properties were requested for the container
				selected = container;
				navigationView = false;
			} else {
				nodes = this._getAtLeastOneNode(status);
			}

			context = status.context || options && options.context;

			originatingView = status.originatingView || options.originatingView;

			// WR node executed from a list view.
			// Render the prompt view in situ:
			csui.require([ 'csui/lib/marionette', 'csui/lib/backbone',
				'webreports/widgets/parameter.prompt.form/parameter.prompt.form.view',
				'csui/controls/dialog/dialog.view',
				'csui/utils/contexts/factories/next.node',
				'csui/utils/contexts/factories/previous.node',
				'csui/utils/contexts/factories/node',
				'csui/widgets/nodestable/nodestable.view'
			], function ( Marionette, Backbone, PromptView, DialogView, NextNodeFactory, PreviousNodeFactory, NodeFactory, NodesTableWidget) {

				var attrs,
					parm,
					promptView,
					newAttrs = {},
					previousNode = context.getModel(PreviousNodeFactory),
					nextNode = context.getModel(NextNodeFactory),
					thisNode = context.getModel(NodeFactory),
					promptViewOptions = {
						RunWRController: self,
						model: selected,
						originatingView: originatingView,
						context: context,
						showCloseIcon: originatingView ? false : true,
						showBackIcon: originatingView ? true : false
					};

				// Set the previousNode to the current node so we come back here:
				previousNode.clear({silent: true});
				previousNode.set(thisNode.attributes);

				// Clear out the nextNode, as the user might hit the back button to Cancel:
				nextNode.clear({silent:true});

				// Pre-populate any parameters on the WR node with any passed values:
				if (_.has(self.options, "parameters")){

					// The parms stored on the WR node:
					attrs = self.runWRPreModel.attributes.data;

					// Loop through any parms passed in:
					for (parm in self.options.parameters) {

						// Only allow passing parms that are defined on the WR itself:
						if ( _.has( attrs, parm) ){
							newAttrs[parm] = self.options.parameters[parm];
						}

					}

					self.runWRPreModel.set("data", newAttrs );

				}

				promptView = new PromptView( promptViewOptions );

				// replace the originatingView with sliding left/right animation if it's coming from a NodesTable widget:
				if (originatingView instanceof NodesTableWidget) {

					var _showOriginatingView,
						$wrPrompts,
						$originatingView = originatingView.$el,
						ntWidthVal = $originatingView.width(),
						ntWidth = ntWidthVal + 'px';

					$originatingView.parent().append("<div class='wr-prompt-parameters-wrapper'></div>");
					$wrPrompts = $($originatingView.parent().find('.wr-prompt-parameters-wrapper')[0]);
					$wrPrompts.hide();

					promptView.render();
					Marionette.triggerMethodOn(promptView, 'before:show');
					$wrPrompts.append(promptView.el);

					$originatingView.hide('blind', {
						direction: 'left',
						complete: function () {
							$wrPrompts.show('blind',
								{
									direction: 'right',
									complete: function () {
										Marionette.triggerMethodOn(promptView, 'show');
									}
								},
								100);
						}
					}, 100);

					$originatingView.promise().done(function() {
						originatingView.isDisplayed = false;
						deferred.resolve();
					});

					_showOriginatingView = function () {
						$wrPrompts.hide('blind', {
							direction: 'right',
							complete: function () {
								$originatingView.show('blind',
									{
										direction: 'left',
										complete: function () {
											originatingView.triggerMethod('dom:refresh');
											originatingView.isDisplayed = true;
											//reset required switch to default.
											!!status.collection && (status.collection.requireSwitched = false);
										}
									},
									100);
								promptView.destroy();
								$wrPrompts.remove();
								deferred.resolve();
							}
						}, 100);

					};

					Backbone.listenTo(promptView, 'promptView:close', _.bind(_showOriginatingView, self));
					Backbone.listenTo(promptView, 'promptView:close:without:animation', function () {
						$originatingView.show('blind',
							{
								direction: 'left',
								complete: function () {
									originatingView.triggerMethod('dom:refresh');

									//reset required switch to default.
									!!status.collection && (status.collection.requireSwitched = false);
								}
							},
							100);
						promptView.destroy();
						$wrPrompts.remove();
						deferred.resolve();
					});

				} else {  // show PromptView in a modal dialog

					self.dialog = new DialogView({
						className: 'wr-prompt-parameters',
						largeSize: true,
						view: promptView
					});

					self.dialog.show();

					// UX specs does not have header bar
					self.dialog.ui.header.hide();
					self.dialog.listenTo(promptView, 'promptView:close', function () {
						self.dialog.destroy();
						deferred.resolve();
					});

					self.dialog.listenTo(promptView, 'promptView:close:without:animation', function () {
						self.dialog.destroy();
						deferred.resolve();
					});

				}


			}, function (error) { // error require-ing;
				deferred.reject(new CommandError(error));
			});




			return deferred.promise();
		},

		// Modified version of CommandHelper.getAtLeastOneNode:
		_getAtLeastOneNode: function (status) {
			if (!status.nodes) {
				return new NodeCollection();
			}

			if (status.nodes.length === 1 && status.collection) {
				return status.collection;
			} else {
				return status.nodes;
			}

		},

		//////////////////////////////////////
		//  end Moved from OpenWebReport cmd
		//////////////////////////////////////

		// Entry point for checking if a WR has prompt parms:
		checkForPromptParameters: function (options) {
			
			var showPrompts,
				runWRmodel,
				self = this,
				deferred = $.Deferred();

			this.options = options;
			this._blockParentActions();

			runWRmodel = this.getRunWRPreModel(options)
				.done( function(){
					showPrompts = self._checkPrompts();
					deferred.resolve(showPrompts);
				})
				.fail( function(){
					self._unblockParentActions();
					deferred.reject();
				});

			return deferred.promise();

		},

		// Returns a form view for the WR that can be shown in a number of places:
		getFormView: function (options) {

			var i,
				existingParms,
				parm,
				formView,
				schema,
				WRRunModel = ( _.has(this, "runWRPreModel")) ? this.runWRPreModel : (_.has(options, "promptModel")) ? options.promptModel : undefined, // 2nd case is for special scenarios like test pages
				deferred = $.Deferred();


			// Check if we still don't have a model:
			if ( typeof WRRunModel !== "undefined") {

				schema = WRRunModel.get( "schema" );

				// Clear out the title property on the schema model, so it doesn't show up in the Form view
				// Otherwise, it shows up twice (once in the FormView, and once in the Dialog window):
				schema.title = "";
				WRRunModel.set("schema", schema);
				
				csui.require([
					'csui/controls/form/form.view'
				], function (FormView) {
					// Create a FormView using the WR Prompt parameters model:
					formView = new FormView({
						context: options.context,
						model: WRRunModel
					});

					deferred.resolve(formView);

				}, function (error) {
					deferred.reject();
				});

			} else {
				// No model to use:
				deferred.reject();
			}

			return deferred.promise();

		},

		// Invoke to actually execute the WR:
		executeWR: function ( parms ){

			var executeWRCommand,
				executionMethod,
				status,
				statusScreenDialog,
				self = this,
				node = this.options.node,
				options = _.extend( this.options, {
					destinationModel: this.destinationModel
				}),
				destinationModel = this.destinationModel,
				outputDestination = destinationModel.get("output_destination"),
				useClassic = true;


			// Check where we need to send the user:
			executionMethod = this._checkExecutionRoute();

			if ( executionMethod === "classic") {

				// Need to open the WR in classic:
				this.openInClassic( parms );
				this._unblockParentActions();

			} else {

				// This WR can be executed in the smartUI.
				executeWRCommand = new ExecuteWebReportCommand();

				status = this.commandStatus;

				// Add the entered parameters into the query and make sure the originatingView is still blocked:
				if (typeof parms !== "undefined") {
					_.extend(parms, {"prompting": "done"}); // let the server know that prompting is complete.
					this.options.parameters = parms;
					this._blockParentActions();
				}

				// Make sure the command is enabled:
				if (executeWRCommand.enabled(status)) {

					// Execute the WR:
					executeWRCommand
						.execute(status, this.options )
						.done(function( results, executeModel, runInBackground ){

							var executionResults,
								destination_data,
								response = results[0],
								status = results[1];


							if (self.destinationModel.get("show_status_screen") === true ){

								self.statusScreenOptions = _.extend(self.options, {
									executeModel: executeModel,
									runInBackground: runInBackground
								});

								// Show the status screen right away:
								self.showStatusScreen();

							} else {

								// WR is configured NOT to show the Status Screen
								self._unblockParentActions();

							}

						})
						.fail(function() {
							self._unblockParentActions();
						});

				}

			}
			
		},

		// Handoff to the classic WR opener:
		openInClassic: function (parms) {

			var status,
				OpenClassic = new OpenClassicWebReport();

			// Add the entered parameters into the query:
			if (typeof parms !== "undefined") {
				_.extend(parms, {"prompting": "done"}); // let the classic UI know that prompting is complete.
				this.options.parameters = parms;
			}

			// If there's a status, it's invoked via a Command:
			if (typeof this.commandStatus !== "undefined") {

				status = this.commandStatus;

				OpenClassic.execute(status, this.options);

			} else {

				// Not launched from a command, could be a test page.
				return false;

			}

		},

		// Gets the RunWRPre model:
		getRunWRPreModel: function(options) {

			var self = this,
				attributes = options,
				deferred = $.Deferred();

			this.runWRPreModel = options.context.getModel(RunWRPreModelFactory, {
				attributes: {
					id: options.node.get("id")
				},
				options: {
					id: options.node.get("id")
				}
			});

			this.runWRPreModel
				.fetch()
				.done( function(data, status, jqxhr){
					self.destinationModel = self.runWRPreModel.destinationModel;
					self.parametersModel = self.runWRPreModel.parametersModel;
					deferred.resolve();
				});

			return deferred.promise();

		},


		// Map to the additional models we need to lookup for the status screen for each destination type:
		additionalModelMap: {
			node: {
				primary: "outputData.node_id",
				secondary: "destination_data.destination_specific.create_in_id"
			},

			version: {
				primary: "destination_data.destination_specific.add_version_to_id"
				//secondary: undefined // todo:  LLWR-10682
			},

			workflow: {
				primary: "destination_data.destination_specific.workflow_map_id",
				secondary: "outputData.work_id"
			}
		},
		

		// Pre-populate the models required for the status screen:
		_getStatusScreenModels: function() {

			var options = this.statusScreenOptions,
				outputData = options.executeModel.get("data"),
				destination_data = outputData.destination_data,
				self = this,
				deferred = $.Deferred();

			// Get a new node model so we can show the icon/name/default action/etc:
			csui.require( ["csui/utils/contexts/factories/node",
					"workflow/models/workitem/workitem.model.factory"],
				function( NodeFactory, WorkItemModelFactory ){

					var	primaryID,
						secondaryID,
						primaryFactory,
						primaryNode,
						secondaryNode,
						secondaryFactory,
						promises = [],
						target = destination_data.output_destination;


					// If it's a node destination, is this a Version destination or a Node destination with the Add Version option?
					if (target === "node") {
						if ( _.has( destination_data.destination_specific, "add_version_to_id" )) {
							// this is really the version destination:
							target = "version";
						}
					}

					primaryFactory = NodeFactory;
					secondaryFactory = NodeFactory;

					// Always get the primary node model:
					primaryID = eval( self.additionalModelMap[target].primary );

					// Get the right model for the corresponding Destination type:
					if ( destination_data.output_destination === 'workflow') {

						// The WF Attachments id is returned on the WorkItem model.
						// We use the WFMap as the node model so we can get a general WF icon, and get the workItem model so we can get the attachmentsID.
						if ( destination_data.destination_specific.workflow_attach_output === true ) {

							secondaryFactory = WorkItemModelFactory;
							secondaryID = eval( self.additionalModelMap[target].secondary );

						} else {
							secondaryID = undefined;
						}

					} else {

						secondaryID = eval( self.additionalModelMap[target].secondary );

					}

					////////////////////////////////
					// Get the primary model:
					////////////////////////////////
					primaryNode = options.context.getModel(primaryFactory, {attributes: {
						id: primaryID
					} });

					promises.push( primaryNode.fetch() );

					/////////////////////////////////////////
					// Get the secondary model if needed:
					/////////////////////////////////////////
					if ( typeof secondaryID !== "undefined" ) {

						secondaryNode = options.context.getModel(secondaryFactory, {
							attributes: {
								id: secondaryID
							}
						});

						if ( destination_data.output_destination === 'workflow' && destination_data.destination_specific.workflow_attach_output === true ){

							// For WorkItem models we have to set the attributes after, they can't be passed in during construction:
							secondaryNode.set({
								process_id: secondaryID,
								subprocess_id: secondaryID,
								task_id: 1
							},{
								silent: true  // prevent any of the callbacks from running and changing the perspective
							});
						}

						promises.push( secondaryNode.fetch() );

					}

					$.whenAll.apply( $, promises ).then( function(results){

						var dataPackages,
							attachmentsID,
							wfAttachmentsNode;

						options.primaryNode = primaryNode;
						options.secondaryNode = secondaryNode;

						if ( destination_data.output_destination === "workflow" && destination_data.destination_specific.workflow_attach_output === true) {

							// For WF Destinations where the output was attached to the WF, also look up the WF attachments model so we can get its ID:
							if ( secondaryNode.has( "data_packages" ) ){

								dataPackages = secondaryNode.get("data_packages");

								if ( _.isArray( dataPackages )
									&& dataPackages.length > 0
									&& _.has( dataPackages[0], "data")
									&& _.has(dataPackages[0].data, "attachment_folder_id")
									) {

									attachmentsID = dataPackages[0].data.attachment_folder_id;

									wfAttachmentsNode = options.context.getModel(NodeFactory, {
										attributes: {
											id: attachmentsID
										}
									});

									wfAttachmentsNode
										.fetch()
										.then( function() {
											self.options.wfAttachmentsNode = wfAttachmentsNode;
											self._renderStatusScreen();
										});

								} else {

									console.warn( "The dataID for the Workflow Attachments is not available." );
									self._unblockParentActions();

								}

							} else {

								console.log( "Could not get data packages from Worklow model." );
								self._unblockParentActions();

							}

						} else {

							self._renderStatusScreen();

						}


					});

				}, function( error ) {
					// error requiring node models:
					self._unblockParentActions();
				}); // require

		},

		// Shows the Status Screen.
		// Checks to make sure the required models are populated before showing the Status Screen view
		_renderStatusScreen: function() {

			var dialogTitle,
				statusScreenDialog,
				statusScreenView,
				hasSecondaryNode,
				self = this,
				options = this.statusScreenOptions,
				specifics = options.destinationModel.get("destination_specific"),
				outputDestination = options.destinationModel.get("output_destination"),
				deferred = $.Deferred();


			if ( outputDestination === "node" ) {
				// Is this Node destination with Add Version, or the Version destination?
				if ( _.has(specifics, "add_version_to_id")){
					outputDestination = "version";
				}
			}

			dialogTitle = ( options.destinationModel.get("run_in_background") ) ? lang.WebReportExecutingInBackground : lang.WebReportExecutedSuccessfully;

			this._unblockParentActions();

			// Require in the status view to prevent cyclic dependencies:
			csui.require( [
					'csui/controls/dialog/dialog.view',
					'webreports/controls/status.screen/status.screen.view'],
				function( DialogView,
						  StatusScreen ){

					// Create the dialog view first:
					statusScreenDialog = new DialogView({
						title: dialogTitle,
						buttons: [
							{
								label: lang.okLabel,
								close: true,
								click: _.bind(self._unblockParentActions, self)
							}
						]
					});

					// Create the Status Screen view, passing in the dialogView for easy access later:
					statusScreenView = new StatusScreen( _.extend( options, {dialogView: statusScreenDialog}) );

					// Set the Status Screen view as the view for the DialogView:
					statusScreenDialog.options.view = statusScreenView;

					// Listen for when one of the links is clicked in the Status Screen, so we can turn off the blocking view:
					statusScreenView.on( "onClickNodeLink", _.bind( self._unblockParentActions, self) )
									.on( "onClickSecondaryLink", _.bind( self._unblockParentActions, self));

					// Show the DialogView:
					statusScreenDialog.show();

					deferred.resolve();

				},
				function(){
					deferred.reject();
				}

			); // end require


		},


		showStatusScreen: function(){

			var options = this.statusScreenOptions,
				rib = options.runInBackground,
				destination_data = (rib) ? options.destinationModel.toJSON() : options.executeModel.get("data").destination_data // if it's running in background, use the destination info from the runPre forms result since we don't have the actual output yet
				;

			// Check to see if we need to get any additional models for the status screen:
			if (!rib && destination_data.output_destination in this.additionalModelMap ) {
				this._getStatusScreenModels();
			} else {
				// We have all we need:
				this._renderStatusScreen();
			}

		},

		// Evaluates the destination setting and routes accordingly.
		// Used for WRs that DON'T have any prompts, but use the Browser destination:
		_checkExecutionRoute: function(parms){

			var executionRoute,
				destinationModel = this.destinationModel;

			switch (destinationModel.get("output_destination")) {

				// browser and desktop use the classic opener:
				case "browser":
				case "desktop":
					executionRoute = "classic";
					break;

				default:
					// everything else uses the status screen currently:
					executionRoute = "smart_ui";
					break;

			}

			return executionRoute;
		},
		
		

		// Checks the runPre model to see if the WebReport has any prompt-able parameters:
		// Returns 1 of 3 possible states:
		//			- WR has no parameters to prompt (noPrompts)
		//			- WR has parameters that are supported in the smartUI (showSmartPrompts)
		//			- WR has parameters that aren't supported in smartUI OR a custom prompt screen. (showClassicPrompts)
		_checkPrompts: function () {

			var parm,
				currentSchema,
				currentOptions,
				formSchema,
				formOptions,
				promptRoute = "noPrompts",
				parametersModel = this.parametersModel,
				promptFileId = parametersModel.get("prompt_file_id"),
				showPrompts = false,
				hasCustomPromptScreen = false,
				runWRPreModel = this.runWRPreModel,
				self = this;


			if (typeof runWRPreModel !== "undefined") {

				hasCustomPromptScreen = ( typeof promptFileId !== "undefined" && promptFileId !== "" );

				if ( hasCustomPromptScreen ) {

					// There's a custom prompt screen:
					promptRoute = "showClassicPrompts";

				} else {

					// No custom prompt screen, now check each parameter for compatibilty with SmartUI:
					formSchema = runWRPreModel.get("schema");
					formOptions = runWRPreModel.get("options");

					if (typeof formSchema !== "undefined" && typeof formOptions !== "undefined") {

						for (parm in formSchema.properties) {

							if (formSchema.properties.hasOwnProperty(parm)) {

								currentSchema = formSchema.properties[parm];
								currentOptions = formOptions.fields[parm];

								// Do we have any viewable prompt parms?
								if (currentOptions.hidden === false) {

									// Is it a Custom parm?
									if (currentSchema.type === "Custom") {

										// There's a Custom prompt parameter, so we need to show the Classic prompt page:
										promptRoute = "showClassicPrompts";
										break;

									} else {
										// This parameter is supported in the smartUI:
										promptRoute = "showSmartPrompts";
									}
								}

							}

						}

					}

				}


			}


			if (promptRoute === "showSmartPrompts") {
				// Need to show the prompt screen.
				this.switchToPromptView(status, this.options)
					.done(function(){
						self._unblockParentActions();
					});

			} else if (promptRoute === "showClassicPrompts") {

				// Need to prompt in the classic UI:
				this.openInClassic();
				this._unblockParentActions();

			} else {

				// no prompts:
				this.executeWR(this.options.parameters);

			}


			return promptRoute;

		},

		_blockParentActions: function () {
			var origView;
			if (_.has(this, "options") && _.has( this.options, "originatingView") ){
				origView = this.options.originatingView;
				origView && origView.blockActions && origView.blockActions();
				origView && origView.tableView && origView.tableView.blockActions && origView.tableView.blockActions();
			} else {
				// We don't have parent view:
				console.log("Prepping WebReport...");
			}
		},

		_unblockParentActions: function () {
			var origView;
			if (_.has(this, "options") && _.has( this.options, "originatingView") ){
				origView = this.options.originatingView;
				origView && origView.unblockActions && origView.unblockActions();
				origView && origView.tableView && origView.tableView.unblockActions && origView.tableView.unblockActions();
			}
		}

	});

	_.extend(RunWebReportPreController, {version: "1.0"});

	return RunWebReportPreController;

});

/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/parameter.prompt.form/impl/parameter.prompt.layout',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"webreport-parameter-prompt\">\r\n	<div class=\"webreport-parameter-prompt-header-container\"></div>\r\n	<div class=\"webreport-parameter-prompt-content-container\"></div>\r\n	<div class=\"webreport-parameter-prompt-footer-container\"></div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_widgets_parameter.prompt.form_impl_parameter.prompt.layout', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/parameter.prompt.form/impl/parameter.prompt',[],function(){});
csui.define('webreports/widgets/parameter.prompt.form/parameter.prompt.form.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
	'csui/utils/base', 'csui/models/node/node.model',
	'csui/utils/contexts/factories/node',
	'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
	'csui/utils/nodesprites',
	'csui/controls/progressblocker/blocker',
	'webreports/widgets/parameter.prompt.form/impl/header/parameter.prompt.header.view',
	'webreports/widgets/parameter.prompt.form/impl/footer/parameter.prompt.footer.view',
	'csui/utils/commandhelper',
	'csui/utils/commands',
	'webreports/controls/run.webreport.pre/run.webreport.pre.controller',
	'i18n!webreports/widgets/parameter.prompt.form/impl/nls/lang',
	'hbs!webreports/widgets/parameter.prompt.form/impl/parameter.prompt.layout',
	'css!webreports/widgets/parameter.prompt.form/impl/parameter.prompt'
], function (_, $, Marionette, base, NodeModel,
			 NodeModelFactory,
			 ViewEventsPropagationMixin, NodeSpriteCollection,
			 BlockingView,
			 PromptHeaderView,
			 PromptFooterView,
			 CommandHelper,
			 commands,
			 RunWebReportPreController,
			 lang, template) {

	var ParameterPromptLayoutView = Marionette.LayoutView.extend({

		template: template,

		regions: {
			header: ".webreport-parameter-prompt-header-container",
			content: ".webreport-parameter-prompt-content-container",
			footer: ".webreport-parameter-prompt-footer-container"
		},

		constructor: function (options) {
			Marionette.LayoutView.prototype.constructor.call(this, options);

			this.options = options;

			this.RunWRController = ( _.has( options, "RunWRController") ) ? options.RunWRController : new RunWebReportPreController(); //2nd case is for test page scenarios

			BlockingView.imbue(this);
		},

		childEvents: {
			"submitWR": "submitWR",
			"cancelWR": "cancelWR",
			"onClickBackArrow": "_closePromptView",
			"show:prompt:form": "showPromptForm"
		},

		onBeforeShow: function(){

			var self = this,
				options = this.options || {};

			this.blockActions();

			// Get the FormView:
			this.RunWRController.getFormView(options)
				.done(function( formView ){

					if ( typeof formView !== "undefined" ){
						self.showChildView( "content", formView );
					}

					self.unblockActions();
				});

			// Show the Header:
			this.showChildView( "header", new PromptHeaderView( options ));
			
			// Show the footer:
			this.showChildView( "footer", new PromptFooterView( options ));

			// Handle close events:
			this.listenTo(this.getChildView("header"), "promptView:close", function () {
					self.trigger("promptView:close");
				})
				// stops listening, so that the second subscribed event won't do any harm
				.listenTo(options.context, 'request', function () {
					self._closePromptView();
				})
				.listenTo(options.context, 'request:perspective', function () {
					self._closePromptView();
				});
		},

		_blockActions: function () {
			var origView = this.options.originatingView;
			origView && origView.blockActions && origView.blockActions();
		},

		_unblockActions: function () {
			var origView = this.options.originatingView;
			origView && origView.unblockActions && origView.unblockActions();
		},


		submitWR: function() {

			// Gather up the parms and pass them into the classic view:
			var parm,
				parmData,
				schema,
				promptView = this.getRegion("content").currentView,
				parmsOK = promptView.validate();

			if (parmsOK === true) {

				parmData = promptView.getValues(); // The entered values


				// Check for any parms that are Not A Number, which is the value that alpaca returns for Number fields that are empty.
				// This prevents the NaN value being passed into the WR execution instead of a blank value.
				if ( _.has(promptView, "alpaca") && _.has(promptView.alpaca, "schema") && _.has(promptView.alpaca.schema, "properties")){

					schema =  promptView.alpaca.schema.properties;

					for ( parm in schema ) {

						if ( schema[parm].type === "number" ){

							if (isNaN(parmData[parm])) {
								// Empty out the parms value so we don't pass NaN to the WR execution:
								parmData[parm] = "";
							}

						}


					}
				}



				// We have the entered parameter data, now execute the WR:
				this.RunWRController.executeWR( parmData );

				// Go back to the previous view:
				this._closePromptView();
			}

		},

		cancelWR: function() {
			this._closePromptView();
		},

		_closePromptView: function() {

			var node = this.options.model;

			if (node.get('type') === 1 && node.original && node.original.get('type') === 0) {
				this.trigger("promptView:close");
			} else {
				this.trigger('promptView:close:without:animation');
			}
		}

	});

	return ParameterPromptLayoutView;

});


csui.define('json!webreports/widgets/parameter.prompt.form/parameter.prompt.form.manifest.json',{
  "$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
  "title": "{{widgetTitle}}",
  "description": "{{widgetDescription}}",
  "kind": "fullpage",
  "schema": {
    "type": "object",
    "properties": {}
  },
  "options": {}
}
);

csui.define('webreports/widgets/parameter.prompt.form/impl/nls/parameter.prompt.form.manifest',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/widgets/parameter.prompt.form/impl/nls/root/parameter.prompt.form.manifest',{
  "widgetTitle": "Parameter Prompt Widget",
  "widgetDescription": "Displays a form to prompt the user for information based on the WebReports' Parameters settings",
  "idTitle": "ID",
  "idDescription": "The WebReport node for which to show the prompts"
});



csui.define('webreports/utils/commands/defaultactionitems',[],function () {
    'use strict';

    return [
        // WebReports
        {
            equals: {type: [30303]},
            signature: 'OpenWebReport',
            sequence: 30
        }
    ];

});

csui.define('webreports/utils/commands/open.webreport',['require', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
	'csui/utils/command.error', 'csui/utils/commandhelper', 'csui/models/command',
	'csui/models/nodes',
	'webreports/controls/run.webreport.pre/run.webreport.pre.controller'
], function (require, _, $, Marionette,
			 CommandError, CommandHelper, CommandModel,
			 NodeCollection,
			 RunWebReportPreController ) {

	var OpenWebReportCommand = CommandModel.extend({

		constructor: function OpenWebReportCommand() {
			CommandModel.prototype.constructor.call(this);
			this.RunWRController = new RunWebReportPreController();
		},

		defaults: {
			signature: 'OpenWebReport',
			scope: "single"
		},

		enabled: function (status) {
			var node = CommandHelper.getJustOneNode(status);
			return node && node.get('type') === 30303;
		},

		execute: function (status, options) {

			var theForms,
				showPrompts,
				self = this,
				deferred = $.Deferred();


			if ( !(_.has(options, "node") )) {
				options.node = status.nodes.models[0];
			}

			this.RunWRController.commandStatus = status;

			// Hand-off to the controller to determine prompt parameters/destination routes:
			showPrompts = this.RunWRController.checkForPromptParameters(options)
				.done(function(){
					deferred.resolve();
				})
				.fail(function(error){
					deferred.reject();
				});


			return deferred.promise();
		}

	});

	return OpenWebReportCommand;

});

/* START_TEMPLATE */
csui.define('hbs!webreports/controls/status.screen/impl/status.screen',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "\r\n		<div class=\"webreport-status-screen-row webreport-status-screen-data\">\r\n			<div class=\"webreports-destination-icon-container icon_status_task_running_behind\" aria-hidden=\"true\"></div>\r\n			<div class=\"webreports-destination-status-description\">\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.runningInBackground || (depth0 != null ? depth0.runningInBackground : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"runningInBackground","hash":{}}) : helper)))
    + "</p>\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.noFurtherResponse || (depth0 != null ? depth0.noFurtherResponse : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"noFurtherResponse","hash":{}}) : helper)))
    + "</p>\r\n				<br>\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.outputMessage || (depth0 != null ? depth0.outputMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"outputMessage","hash":{}}) : helper)))
    + "</p>\r\n			</div>\r\n		</div>\r\n\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.useConversion : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "\r\n		<div class=\"webreport-status-screen-row webreport-status-screen-data\">\r\n			<div class=\"webreports-destination-icon-container icon_status_task_delayed\" aria-hidden=\"true\"></div>\r\n			<div class=\"webreports-destination-status-description\">\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.sentForConversion || (depth0 != null ? depth0.sentForConversion : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"sentForConversion","hash":{}}) : helper)))
    + "</p>\r\n				<br>\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.outputMessage || (depth0 != null ? depth0.outputMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"outputMessage","hash":{}}) : helper)))
    + "</p>\r\n			</div>\r\n		</div>\r\n\r\n";
},"6":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "\r\n		<div class=\"webreport-status-screen-row webreport-status-screen-data\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.iconClass : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "			<div class=\"webreports-destination-status-description\">\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.destinationMessage || (depth0 != null ? depth0.destinationMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"destinationMessage","hash":{}}) : helper)))
    + "</p>\r\n				"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.primaryData2 : depth0),{"name":"if","hash":{},"fn":this.program(9, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n				<p>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.primaryIsLink : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.program(13, data, 0)})) != null ? stack1 : "")
    + "				</p>\r\n			</div>\r\n		</div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.dualRows : depth0),{"name":"if","hash":{},"fn":this.program(15, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n	";
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "				<div class=\"webreports-destination-icon-container "
    + this.escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconClass","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></div>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var helper;

  return "<br><p>"
    + this.escapeExpression(((helper = (helper = helpers.primaryData2 || (depth0 != null ? depth0.primaryData2 : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"primaryData2","hash":{}}) : helper)))
    + "</p>";
},"11":function(depth0,helpers,partials,data) {
    var helper;

  return "						<a id=\"primaryNodeLink\" href=\"#\">"
    + this.escapeExpression(((helper = (helper = helpers.primaryData || (depth0 != null ? depth0.primaryData : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"primaryData","hash":{}}) : helper)))
    + "</a>\r\n";
},"13":function(depth0,helpers,partials,data) {
    var helper;

  return "						<span class=\"webreports-status-screen-highlighted-text\">"
    + this.escapeExpression(((helper = (helper = helpers.primaryData || (depth0 != null ? depth0.primaryData : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"primaryData","hash":{}}) : helper)))
    + "</span>\r\n";
},"15":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "		<div class=\"webreport-status-screen-row webreport-status-screen-misc-data\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.secondaryIconClass : depth0),{"name":"if","hash":{},"fn":this.program(16, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "			<div class=\"webreports-destination-status-description\">\r\n				<p>"
    + this.escapeExpression(((helper = (helper = helpers.secondaryNodeInfo || (depth0 != null ? depth0.secondaryNodeInfo : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"secondaryNodeInfo","hash":{}}) : helper)))
    + "</p>\r\n				<p><a id=\"secondaryNodeLink\" href=\"#\">"
    + this.escapeExpression(((helper = (helper = helpers.secondaryData || (depth0 != null ? depth0.secondaryData : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"secondaryData","hash":{}}) : helper)))
    + "</a></p>\r\n			</div>\r\n		</div>\r\n";
},"16":function(depth0,helpers,partials,data) {
    var helper;

  return "				<div class=\"webreports-destination-icon-container "
    + this.escapeExpression(((helper = (helper = helpers.secondaryIconClass || (depth0 != null ? depth0.secondaryIconClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"secondaryIconClass","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"webreport-status-screen-container\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.runInBackground : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\r\n\r\n</div>";
}});
Handlebars.registerPartial('webreports_controls_status.screen_impl_status.screen', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/controls/status.screen/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/controls/status.screen/impl/nls/root/lang',{
  genericIsProcessingMessage: "The output of this report will be processed according to the parameters set under the Destination tab for this WebReport.",
  runningInBackground: "This report is being run as a background task.",
  noFurtherResponse: "You will not receive any further response for this report.",
  sentForConversion:  "This report has been sent for conversion.",
  versionDestinationMessage: "WebReport data has been added as a new version to the Content Server Document called:",
  nodeDestinationMessage: "WebReport data has been sent to a new Content Server {0} called:",
  storedInContainer: "Stored in container:",
  emailDestinationMessage: "Report data has been sent as an email successfully.",
  formAppendDestinationMessage: "New rows added to the Form:",
  formOverwriteDestinationMessage: "Existing Form data cleared.",
  formOverwriteDestinationMessage2: "New rows added to the Form:",
  formUpdateDestinationMessage: "Rows updated in the Form:",
  serverDestinationMessage: "The report output has been successfully downloaded to the server.",
  ftpDestinationMessage: "The report output has been successfully sent to the FTP server.",
  workflowDestinationMessage: "The following Workflow was successfully initiated:",
  workflowAttachmentMessage: "The WebReport output was attached and can be found here:",
  unknownWebReportDestination: "Unknown WebReport destination: ",
  document: "Document",
  customView: "Custom View",
  attachments: "Attachments"
});


csui.define('css!webreports/controls/status.screen/impl/status.screen',[],function(){});
csui.define('webreports/controls/status.screen/status.screen.view',[
	'csui/lib/underscore',
	'csui/lib/marionette',
	'csui/controls/node-type.icon/node-type.icon.view',
	'csui/utils/node.links/node.links',
	'csui/behaviors/default.action/default.action.behavior',
	'csui/utils/smart.nodes/smart.nodes',
	'hbs!webreports/controls/status.screen/impl/status.screen',
	'i18n!webreports/controls/status.screen/impl/nls/lang',
	'css!webreports/controls/status.screen/impl/status.screen'
], function( _,
			 Marionette,
			 NodeTypeIconView,
			 NodeLinks,
			 DefaultActionBehavior,
			 SmartNodes,
			 template,
			 lang) {
	
	
	var statusScreenView = Marionette.ItemView.extend({

		className: 'custom-message',
		template: template,

		ui: {
			iconContainer: ".webreport-status-screen-data",
			secondaryContainer: ".webreport-status-screen-misc-data",
			parentLink: ".parentLink"
		},

			events: {
			'click #primaryNodeLink': "onClickNodeLink",
			'click #secondaryNodeLink': "onClickSecondaryLink"
		},

		behaviors: {
			DefaultAction: {
				behaviorClass: DefaultActionBehavior
			}
		},

		onClickNodeLink: function(event){

			// Do not navigate to the URL; it is there to bookmarking only
			event.preventDefault();

			// Trigger the default action and close the dialog:
			this.triggerMethod('execute:defaultAction', this.options.primaryNode);

			// Close the dialog if the node is supported in the SmartUI, otherwise leave it open as the action executes in a new tab.
			if ( SmartNodes.isSupported(this.options.primaryNode) ){
				this.options.dialogView.triggerMethod("click:close", event);
			}

		},

		onClickSecondaryLink: function(event){

			var actionNode,
				openWorkItemCommand,
				wfAssignment,
				assignments,
				wfData,
				destination = this.options.destinationModel.get("output_destination");

			// Do not navigate to the URL; it is there to bookmarking only
			event.preventDefault();

			if ( destination === "workflow" && _.has( this.options, "wfAttachmentsNode" ) ) {

				actionNode = this.options.wfAttachmentsNode;

			} else {

				actionNode = this.options.secondaryNode;

			}

			// Trigger the default action:
			this.triggerMethod('execute:defaultAction', actionNode);

			// Close the dialog if the node is supported in the SmartUI, otherwise leave it open as the action executes in a new tab.
			if ( SmartNodes.isSupported( actionNode ) ){
				this.options.dialogView.triggerMethod("click:close", event);
			}

		},
		

		templateHelpers: function(){

			var primaryNode,
				secondaryNode,
				destinationMessage,
				destinationModel = this.options.destinationModel,
				executionModel = this.options.executeModel,
				outputData = destinationModel.get("run_in_background") ? destinationModel.toJSON() : executionModel.get("data"),
				destination_data = destinationModel.get("run_in_background") ? outputData : outputData.destination_data,
				specifics = destination_data.destination_specific,
				useConversion = destination_data.use_conversion_engine,
				rib = destination_data.run_in_background,
				genericIsProcessingMessage = lang.genericIsProcessingMessage,
				helperData = {
					useConversion: useConversion,
					runInBackground: rib
				};


			if (rib) {

				// Running in background (takes precedence over other settings):
				helperData = _.extend( helperData, {
					runningInBackground: lang.runningInBackground,
					noFurtherResponse: lang.noFurtherResponse,
					outputMessage: genericIsProcessingMessage
				});

			} else if (useConversion){

				// Using conversion:
				helperData = _.extend( helperData, {
					sentForConversion:  lang.sentForConversion,
					outputMessage: genericIsProcessingMessage
				});

			} else {

				// Normal destination:
				switch (destination_data.output_destination.toLowerCase()) {

					case "node":

						// CS Node and CS Version:
						primaryNode = this.options.primaryNode; // resulting output node
						secondaryNode = this.options.secondaryNode; // parent of the output node

						// Update the message wording for new nodes/versions.
						// "Version" destination can be configured 2 ways:
						//   - CS Node destination with the Version export type, or
						//   - CS Node destination with the "Add Version to Original" Duplicate Name Action setting.
						if ( specifics.export_type.toLowerCase() === "version" || specifics.duplicate_name_action.toLowerCase() === "addver" ) {

							helperData = _.extend( helperData, {
								primaryData: primaryNode.get("name"),
								primaryIsLink: true,
								destinationMessage: lang.versionDestinationMessage,
								dualRows: false
							});

						} else {

							helperData = _.extend( helperData, {
								primaryData: primaryNode.get("name"),
								primaryIsLink: true,
								destinationMessage: _.str.sformat(lang.nodeDestinationMessage, (specifics.node_type === "doc") ? lang.document : lang.customView),
								secondaryNodeInfo: lang.storedInContainer,
								parentURL: NodeLinks.getUrl(secondaryNode),
								secondaryData: secondaryNode.get("name"),
								dualRows: true
							});

						}

						break;


					case "email":

						helperData = _.extend( helperData, {
							primaryIsLink: false,
							destinationMessage: lang.emailDestinationMessage,
							primaryData: specifics.email_subject,
							dualRows: false,
							iconClass: "icon_status_email_sent"
						});
						break;


					case "form":

						switch (specifics.append_form) {

							case "append":
								destinationMessage = lang.formAppendDestinationMessage;
								break;

							case "overwrite":
								destinationMessage = lang.formOverwriteDestinationMessage;
								_.extend( helperData, {
									primaryData2:  lang.formOverwriteDestinationMessage2
								});
								break;

							case "update":
								destinationMessage = lang.formUpdateDestinationMessage;
								break;
						}


						helperData = _.extend( helperData, {
							primaryIsLink:false,
							dualRows: false,
							destinationMessage: destinationMessage,
							primaryData: outputData.rows_affected,
							iconClass: "mime_form"
						});

						break;


					case "server":
						// Don't show the output location/path to prevent info disclosure:
						helperData = _.extend( helperData, {
							primaryIsLink: false,
							dualRows: false,
							destinationMessage: lang.serverDestinationMessage,
							iconClass: "icon_status_ftp_server"
						});
						break;


					case "ftp":
						// Don't show the output location/path to prevent info disclosure:
						helperData = _.extend( helperData, {
							primaryIsLink: false,
							destinationMessage: lang.ftpDestinationMessage,
							dualRows: false,
							iconClass: "icon_status_ftp_server"
						});
						break;


					case "workflow":

						primaryNode = this.options.primaryNode; // The dataID of the original WF map
						secondaryNode = this.options.secondaryNode;  // The workID that was initiated

						helperData = _.extend( helperData, {
							primaryIsLink: false,
							dualRows: specifics.workflow_attach_output,
							destinationMessage: lang.workflowDestinationMessage,
							primaryData: specifics.workflow_title
						});


						// WR output was attached to the WF:
						if (specifics.workflow_attach_output === true) {

							// Re-use the primary node, which is the Workflow Attachments dir:
							helperData = _.extend( helperData, {
								secondaryNodeURL: NodeLinks.getUrl(secondaryNode),
								secondaryNodeInfo: lang.workflowAttachmentMessage,
								secondaryData: lang.attachments
							});
						}
						break;


					default:
						console.warn(lang.unknownWebReportDestination + destination_data.output_destination);
						break;
				}

			}


			return helperData;
		},


		onRender: function() {

			// Render the icon view for the targetted node and its parent:
			var primaryIconView,
				secondaryIconView,
				primaryIcon,
				secondaryIcon,
				destinationModel = this.options.destinationModel,
				specifics = destinationModel.get("destination_specific"),
				useConversion = destinationModel.get("use_conversion_engine"),
				rib = destinationModel.get("run_in_background");


			if (!rib && !useConversion) {

				// Normal destination:
				switch (destinationModel.get("output_destination").toLowerCase()) {

					case "node":

						// CS Node and CS Version:

						// We always need a primary icon, add the rendered icons to the beginning of the containers:
						primaryIconView = new NodeTypeIconView({node: this.options.primaryNode});
						primaryIcon = primaryIconView.render();
						this.ui.iconContainer.prepend(primaryIcon.$el);

						// We only need the 2nd model if it's Node Export Type, not for Version Export Type:
						if (_.has(specifics, "export_type") && specifics.export_type.toLowerCase() === "node") {

							secondaryIconView = new NodeTypeIconView({node: this.options.secondaryNode});
							secondaryIcon = secondaryIconView.render();
							this.ui.secondaryContainer.prepend(secondaryIcon.$el);

						}

						break;

					case "workflow":

						// CS Workflow destination, add Attachments icon if the output is attached:
						primaryIconView = new NodeTypeIconView({node: this.options.primaryNode});
						primaryIcon = primaryIconView.render();
						this.ui.iconContainer.prepend(primaryIcon.$el);

						if (destinationModel.get("destination_specific").workflow_attach_output === true) {
							secondaryIconView = new NodeTypeIconView({node: this.options.wfAttachmentsNode}),
								secondaryIcon = secondaryIconView.render();

							// Add the rendered icons to the beginning of the containers:
							this.ui.secondaryContainer.prepend(secondaryIcon.$el);
						}

						break;

				}

			}

		}

	});

	return statusScreenView;
	
});

/* START_TEMPLATE */
csui.define('hbs!webreports/controls/table.report/cells/launch.subwebreport/impl/launch.subwebreport',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<a href=\"#\" class=\"launch-subwebreport\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.icon_label || (depth0 != null ? depth0.icon_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon_label","hash":{}}) : helper)))
    + "\">\r\n    <span class=\"icon "
    + this.escapeExpression(((helper = (helper = helpers.icon_class || (depth0 != null ? depth0.icon_class : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon_class","hash":{}}) : helper)))
    + "\" aria-label=\"Launch SubWebReport\" role=\"button img\"></span>\r\n</a>";
}});
Handlebars.registerPartial('webreports_controls_table.report_cells_launch.subwebreport_impl_launch.subwebreport', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/controls/table.report/cells/launch.subwebreport/impl/nls/launch.subwebreport.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/controls/table.report/cells/launch.subwebreport/impl/nls/root/launch.subwebreport.lang',{
  button_label: 'Launch Sub-WebReport'

});



csui.define('css!webreports/controls/table.report/cells/launch.subwebreport/impl/launch.subwebreport',[],function(){});
csui.define('webreports/controls/table.report/cells/launch.subwebreport/launch.subwebreport.view',['csui/lib/backbone', 'csui/lib/underscore', 'csui/utils/commands', 'csui/controls/table/cells/templated/templated.view',
    'csui/utils/contexts/factories/connector',
    'csui/controls/table/cells/cell.registry',
    'csui/models/node/node.model',
    'hbs!webreports/controls/table.report/cells/launch.subwebreport/impl/launch.subwebreport',
    'i18n!webreports/controls/table.report/cells/launch.subwebreport/impl/nls/launch.subwebreport.lang',
    'css!webreports/controls/table.report/cells/launch.subwebreport/impl/launch.subwebreport'
], function(Backbone, _, commands, TemplatedCellView, ConnectorFactory, cellViewRegistry, NodeModel, template, lang) {

    var LaunchSubWebreportCellView = TemplatedCellView.extend({

        template: template,

		// The original prototype for this is CellView. This extends from Marionette.View
        // and requires the cell content to be rendered by the renderValue function
        renderValue: function () {
            var data = this.getValueData(),
                html = data ? this.template(data) : '';

            this.$el.html(html);
        },

        getValueData: function () {
            var hoverText,
                iconClass,
                column = this.options.column;


            if (column.attributes){
                // If the column has a user-defined hoverText value then use it.
                // This customises the title of the icon.
                if(column.attributes.hoverText){
                    hoverText = column.attributes.hoverText;
                }

                // If the column has a user-defined css value for the icon then use it.
                if(column.attributes.iconClass){
                    iconClass = column.attributes.iconClass;
                }
            }

            return {
                icon_label: hoverText || lang.button_label,
                icon_class: iconClass || 'icon-subwebreport'
            };
        },

        ui: {
            launchSWR: '.launch-subwebreport'
        },

        events: {
            'click @ui.launchSWR': 'onClickLaunchSubWebreport'
        },

        onClickLaunchSubWebreport: function(event) {
            event.preventDefault();

            var connector = this.options.context.getObject(ConnectorFactory),
                WRNode = new NodeModel({
                    id: this.model.get('subwebreportid')
                }, {
                    connector: connector
                });

            WRNode.fetch().done(_.bind(function() {
                this.launchWebReport(WRNode);
            }, this));

        },

        launchWebReport: function(node) {
            var nodeCollection = new Backbone.Collection([node]),
                openWebReport = commands.get('OpenWebReport'),
                status = {
                    nodes: nodeCollection,
                    context: this.options.context
                };

            if (openWebReport && openWebReport.enabled(status)) {
                openWebReport.execute(status, {
                    context: this.options.context,
                    parameters: this.model.attributes
                });
            }
        }

    }, {
        hasFixedWidth: true,
        columnClassName: 'launch-subwebreport-col'
    });

    cellViewRegistry.registerByColumnKey("subwebreportid", LaunchSubWebreportCellView);

    return LaunchSubWebreportCellView;

});
// Placeholder for the build target file; the name must be the same,
// include public modules from this component

csui.define('bundles/webreports-app',[

    // Widgets:
    "webreports/widgets/tilereport/tilereport.view",
    "json!webreports/widgets/tilereport/tilereport.manifest.json",
	"i18n!webreports/widgets/tilereport/impl/nls/tilereport.manifest",
    "webreports/widgets/nodeslistreport/nodeslistreport.view",
    "json!webreports/widgets/nodeslistreport/nodeslistreport.manifest.json",
	"i18n!webreports/widgets/nodeslistreport/impl/nls/nodeslistreport.manifest",
	"webreports/widgets/widget.carousel/widget.carousel.view",
    "json!webreports/widgets/widget.carousel/widget.carousel.manifest.json",
	"i18n!webreports/widgets/widget.carousel/impl/nls/widget.carousel.manifest",
	"webreports/widgets/table.report/table.report.view",
	"json!webreports/widgets/table.report/table.report.manifest.json",
	"i18n!webreports/widgets/table.report/impl/nls/table.report.manifest",
	"webreports/widgets/parameter.prompt.form/parameter.prompt.form.view",
	"json!webreports/widgets/parameter.prompt.form/parameter.prompt.form.manifest.json",
	"i18n!webreports/widgets/parameter.prompt.form/impl/nls/parameter.prompt.form.manifest",
	
    // Models:
    "webreports/models/nodestablereport/nodestablereport.model",
    "webreports/models/tablereport/tablereport.model",
    "webreports/models/wrtext/wrtext.model",
	"webreports/models/widget.carousel/widget.carousel.model",
	"webreports/models/run.webreport.pre/run.webreport.pre.model",
	"webreports/models/run.webreport/run.webreport.model",

    // Commands:
    "webreports/utils/commands/defaultactionitems",
    "webreports/utils/commands/open.webreport",
	"webreports/utils/commands/open.classic.webreport",
	"webreports/utils/commands/execute.webreport",
	
	// Controls:
	"webreports/controls/nodestablereport/nodestablereport.view",
	"webreports/controls/run.webreport.pre/run.webreport.pre.controller",
	"webreports/controls/status.screen/status.screen.view",
	"webreports/controls/table.report/table.report.view",

	// Cells:
    "webreports/controls/table.report/cells/launch.subwebreport/launch.subwebreport.view"


], {});

csui.require(["require", "css"], function (require, css) {

    css.styleLoad(require, "webreports/bundles/webreports-app");

});

