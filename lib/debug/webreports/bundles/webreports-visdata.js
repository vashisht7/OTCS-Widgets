csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanding.behavior',['require', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette', // Third party libraries
    'csui/controls/tile/behaviors/expanding.behavior'
], function (require, _, Backbone, Marionette, TileExpandingBehavior ) {
  "use strict";

  var VisualDataExpandingBehavior = TileExpandingBehavior.extend({

    _expand: function () {
      if ( this.view && this.view.contentView && !this.view.contentView.collection.isEmpty() ){

          var expandedViewValue = this.getOption('expandedView'),
              expandedViewClass = expandedViewValue.prototype instanceof Backbone.View ?
                  expandedViewValue : expandedViewValue.call(this.view),
              requiredModules = ['csui/controls/dialog/dialog.view'],
              self = this;
          if (_.isString(expandedViewClass)) {
              requiredModules.push(expandedViewClass);
          }
          require(requiredModules, function (DialogView) {
              if (_.isString(expandedViewClass)) {
                  expandedViewClass = arguments[1];
              }
              var expandedViewOptions = getOption.call(self, 'expandedViewOptions'),
                  expandedView = new expandedViewClass(expandedViewOptions);

              self._dialog = new DialogView({
                  iconLeft: getOption.call(self, 'titleBarIcon'),
                  imageLeftUrl: getOption.call(self, 'titleBarImageUrl'),
                  imageLeftClass: getOption.call(self, 'titleBarImageClass'),
                  title: getOption.call(self, 'dialogTitle'),
                  iconRight: getOption.call(self, 'dialogTitleIconRight'),
                  className: 'cs-expanded ' + (getOption.call(self, 'dialogClassName') || ''),
                  buttons: expandedViewOptions.data.buttons,
                  largeSize: true,
                  view: expandedView
              });
              self.listenTo(self._dialog, 'hide', function () {
                  self.triggerMethod('collapse');
                  expandedViewOptions.data.isExpanded = false;
              });
              expandedViewOptions.data.isExpanded = true;
              // Destroy the overlay view if its still open on expand.
              if (self.view.overlayVisible){
                  self.view.ui.toggleSettings.trigger('click');
              }
              self._dialog.show();

          });
      }

    }

  });

  // TODO: Expose this functionality and make it generic for other behaviors
  function getOption(property) {
    var options = this.options || {};
    var value = options[property];
    return _.isFunction(value) ? options[property].call(this.view) : value;
  }

  return VisualDataExpandingBehavior;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/filtered.count.facets',['csui/lib/underscore', 'csui/lib/jquery', 'csui/models/facets'
], function (_, $, FacetCollection) {
  'use strict';

  var FilteredCountFacetCollection = FacetCollection.extend({

      constructor: function FilteredCountFacetCollection(models, options) {
        FacetCollection.prototype.constructor.apply(this, arguments);
        this.filters = options && options.filters || [];
      },

      addFilter: function (filter) {
        this.filters.push(filter);
        // return _.union([],this.filters);
        return JSON.parse(JSON.stringify(this.filters));
      },

      removeFilter: function (filterIndex, valueIndex) {
        var filter = this.filters[filterIndex];
        filter.values.splice(valueIndex, 1);

        if (filter.values.length === 0) {
          this.filters.splice(filterIndex, 1);
        }

        // return _.union([],this.filters);
        return JSON.parse(JSON.stringify(this.filters));
      },

      clearFilters: function () {
        if (this.filters && this.filters.length > 0) {
          this.filters = [];
        }
        return [];
      }

  });

  return FilteredCountFacetCollection;

});

csui.define('webreports/utils/url.webreports',['csui/lib/underscore','csui/utils/url','csui/utils/contexts/factories/node'], function (_,Url, NodeModelFactory) {

    var UrlWebReports = _.extend({

        appendWebReportParameters: function (query, parameters) {

            // Append any WebReport parameters to the RestURL if present
            if (!_.isUndefined(parameters)) {
                // Currently supported array format generated by the Perspective Manager
                if (_.isArray(parameters)) {
                    query = this.combineQueryString(query, this._serializeWebReportParameters(parameters));
                } else {
                    // Support parameters in legacy format
                    query = this.combineQueryString(query, parameters);
                }
            }

            return query;
        },

        appendCurrentContainer: function (query, context) {

            var csuiContainerID;

            // Append the containerID parameter to the RestURL if present
            if (!_.isUndefined(context)) {
                csuiContainerID = this.getCurrentContainerID(context);

                if (csuiContainerID){
                    query = this.combineQueryString(query, 'csuiContainerID='+ csuiContainerID );
                }
            }

            return query;
        },

        appendSWRCellID: function (query, options) {

            var subWebReportCellID;

            // Append the containerID parameter to the RestURL if present
            if (options && options.data && options.data.swrLaunchCell && options.data.swrLaunchCell.id) {

                subWebReportCellID = parseInt(options.data.swrLaunchCell.id, 10);

                if (typeof subWebReportCellID === "number" && !isNaN(subWebReportCellID)){
                    query = this.combineQueryString(query, 'subwebreport_id='+ subWebReportCellID );
                }
            }

            return query;
        },

        getCurrentContainerID: function (context) {
            var csuiContainerID,
                node = context.getModel(NodeModelFactory);

            if (!_.isUndefined(node)){
                csuiContainerID = node.get('id');
            }
            return csuiContainerID;
        },

        _serializeWebReportParameters: function(parameters){
            var serializedParms = '';

            _.each(parameters, function (parmPair) {
                if ( parmPair.name !== '' ) {
                    if (serializedParms.length) {
                        serializedParms += '&' + parmPair.name + '=' + parmPair.value;
                    } else {
                        serializedParms += parmPair.name + '=' + parmPair.value;
                    }
                }
            });

            return serializedParms;
        },

        /* Converts parameters in the format:
                parameters: [
                    {
                        name: 'myparm1',
                        value: 'val1'
                    },
                    {
                        name: 'myparm2',
                        value: 'val2'
                    }
                ]

           To the format:

                {
                    myparm1: 'val1',
                    myparm2: 'val2'
                }

           This is used to generate an object to pass in as data to a POST API.
        */

        getWebReportParametersAsData: function(parameters){

            var parmsObject = {};

            if (_.isArray(parameters)) {
                _.each(parameters, function (parmPair) {
                    if ( parmPair.name !== '' ) {
                        parmsObject[parmPair.name] = parmPair.value;
                    }
                });
            }

            return parmsObject;
        },

        /*  The inverse of getWebReportParametersAsData( parameters ).

         Converts parameters in the format:
             {
             myparm1: 'val1',
             myparm2: 'val2'
             }

         To the format:
             [
                 {
                     name: 'myparm1',
                     value: 'val1'
                 },
                 {
                     name: 'myparm2',
                     value: 'val2'
                 }
             ]

         Used to pass parameters from the prompt screen into a WR using Widget destinations.
        */
        getDataAsWebReportParameters: function(parameters){


            var parmsArray = [];

            if ( _.isObject(parameters) ){
                _.mapObject( parameters, function (val, key){
                    parmsArray.push({"name":key, "value": val});
                });
            }

            return parmsArray;
        }

    }, Url);

    return UrlWebReports;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/models/visualdata/visual.data.model',[
  'csui/lib/underscore',
  'csui/lib/backbone',
  'webreports/utils/url.webreports',
  'csui/models/mixins/connectable/connectable.mixin'
], function (_, Backbone, UrlWebReports, ConnectableMixin) {

  var FilteredCountModel = Backbone.Model.extend({

    // Constructor gives an explicit name to the object in the debugger
    constructor: function FilteredCountModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

    }

  });

  return FilteredCountModel;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/overlay.model',[
    'csui/lib/underscore',
    'csui/lib/backbone'
], function (_, Backbone) {

    var OverlayModel = Backbone.Model.extend({

        defaults: {
            // placeholder object for persisting any user settings for visualisation
            vis_type: '',
            active_column: '',
            active_column_formatted: '',
            count_column: '',
            column_names: [],
            column_names_formatted: [],
            sort_by: 'Count',
            sort_order: 'desc',
            view_value_as_percentage: false,
            group_after: 10,
            fc_filters: []
        },

        // Constructor gives an explicit name to the object in the debugger
        constructor: function OverlayModel(attributes, options) {
            Backbone.Model.prototype.constructor.apply(this, arguments);

        }

    });

    return OverlayModel;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.column.model',[
  'csui/lib/backbone'
], function (Backbone) {

  var FilteredCountColumnModel = Backbone.Model.extend({

    defaults: {
      "active_column":false,
      "client_format":{
        "type":"none"
      },
      "column_key":"",
      "count_column":false,
      "data_type":10,
      "id": undefined ,
      "name":"",
      "tag_format":""
    },

    // Constructor gives an explicit name to the object in the debugger
    constructor: function FilteredCountColumnModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

    }

  });

  return FilteredCountColumnModel;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.column.collection',[
    'csui/lib/backbone', // 3rd party libraries
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.column.model'
], function (Backbone, FilteredCountColumnModel) {

    var FilteredCountColumnCollection = Backbone.Collection.extend({

        // Constructor gives an explicit name to the object in the debugger
        constructor: function FilteredCountColumnCollection(models, options) {
            Backbone.Collection.prototype.constructor.apply(this, arguments);

        },

        model: FilteredCountColumnModel

    });

    return FilteredCountColumnCollection;

});

// Lists explicit locale mappings and fallbacks

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

// Defines localizable strings in the default language (English)

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/root/visual.data.lang',{
    dialogTitle: 'Visual Data Filtered Count',
    barChart: 'Bar chart',
    pieChart: 'Pie chart',
    donutChart: 'Donut chart',
    scatterChart: 'Scatter chart',
    areaChart: 'Area chart',
    lineChart: 'Line chart',
    chartType: 'Chart type',
    activeColumn: 'Active column',
    sortBy: 'Sort by',
    total: 'Total',
    count: 'Count',
    totalCount: 'Total Count',
    asc: 'asc',
    desc: 'desc',
    filters: 'Filters',
    showValuesAs: 'Show values as',
    groupAfter: 'Group after',
    dontGroup: 'Don\'t group',
    items: 'items',
    actual: 'Actual',
    percentage: 'Percentage',
    update: 'Update',
    cancel: 'Cancel',
    launchReport: 'Launch WebReport',
    launchReportTooltip: 'Launch a classic WebReport in a new window using the current filter configuration.',
    tooManyRows: 'Please refine your filter further. The maximum number of items that can be processed is ',
    noValue: '(No value)',
    invalidActiveColumn: 'An invalid Active Column was specified.',
	emptyChartText: 'No results found.',
    settings: 'Settings'
});


csui.define('webreports/widgets/visual.data.filtered.count/impl/models/visualdata/visual.data.collection',[
    'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/d3', // 3rd party libraries
    'csui/dialogs/modal.alert/modal.alert',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/filtered.count.facets',
    'csui/models/facettopics',
    'webreports/utils/url.webreports',
    'webreports/widgets/visual.data.filtered.count/impl/models/visualdata/visual.data.model',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/overlay.model',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.column.collection',
    'csui/models/mixins/connectable/connectable.mixin',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',
    'csui/utils/deepClone/deepClone'
], function (_, Backbone, d3, ModalAlert, FilteredCountFacetCollection, FacetTopicCollection, UrlWebReports, FilteredCountModel, OverlayModel, FilteredCountColumnCollection, ConnectableMixin, lang) {

    var FilteredCountCollection = Backbone.Collection.extend({

        // Constructor gives an explicit name to the object in the debugger
        constructor: function FilteredCountCollection(models, options) {
            Backbone.Collection.prototype.constructor.apply(this, arguments);

            if (_.isUndefined(options)){
                options = {};
            }

            //FIXME: is it necessary to do this, or is id an implicit property of options
            if (options && options.id && !this.id) {
                this.id = options.id;
            }

            this.options = options;

            // Enable this model for communication with the CS REST API
            this.makeConnectable(options);

            // Create a new overlay model with the current settings for the visualization
            this.overlayModel = new OverlayModel({
                vis_type: options.type,
                active_column: options.activeColumn,
                sort_by: options.sortBy || 'Count',
                sort_order: options.sortOrder || 'desc',
                view_value_as_percentage: options.viewValueAsPercentage,
                group_after: options.groupAfter,
                fc_filters: options.filters || []
            });

            this.listenTo(this.overlayModel, 'change', this.onOverlayUpdate);
        },

        model: FilteredCountModel,

        // Computes the REST API URL using the connection options
        url: function () {

            return this.connector.connection.url + '/nodes/' + this.id + '/output';

        },

        parse: function (response) {

            if ( response.data && response.data.length > 0 ){
                this._isEmpty = false;
                this._isFetched = true;

                this.grouped_on_server = response.grouped_on_server || false;
                this.sorted_on_server = response.sorted_on_server || false;
                this.setColumns(response.columns);

                if (this._isResponseValid(response)){
                    if(response.grouped_on_server){
                        this.groupedData = response;
                        if (response.fc_filters){
                            // Don't trigger change events, otherwise onOverlayUpdate will go back to the server.
                            // Setting {silent : true} option.
                            this.overlayModel.set({fc_filters:response.fc_filters}, {silent: true});
                        }
                    } else {
                        this.rawCollection = response.data;
                    }

                    this.filteredData = this.sortGroupAndFilter();

                    return this.filteredData;
                }
            } else {
                this._isEmpty = true;
                this._isFetched = true;
                return [];
            }


        },

        _isEmpty: true,

        _isFetched: false,

        isEmpty: function (){
          return  (this._isEmpty && this._isFetched);
        },

        isFetched: function () {
          return this._isFetched;
        },

        _isResponseValid: function(response){
            var ok = true;
            if (!response.grouped_on_server){
                if (!this._isActiveColumnValid(response)) {
                    ModalAlert.showError(lang.invalidActiveColumn);
                    ok = false;
                }
            }
            return ok;
        },

        _isActiveColumnValid: function(response){
            return !_.isUndefined(this._getCaseInsensitiveProperty(_.first(response.data),this.getActiveColumn()));
        },

        filteredData: {},
        rawCollection: {},
        overlayModel: {},

        getFilteredCountParms: function(){
            var parms = {};

            parms.filterable = (this.options.filterable === true);
            parms.expandable = (this.options.expandable === true);

            _.extend(parms, this.overlayModel.attributes);

            if (parms.sort_by === 'ordinal' ){
                parms.sort_by = parms.active_column;
            }

            parms.fc_filters = JSON.stringify(parms.fc_filters);

            return parms;
        },

        getFilteredCountQuery: function(){

            var postData = {},
                csuiContainerID,
                context = this.options.context || undefined,
                wrParameters = this.options.parameters || undefined;

            // Extend the POST data with any WebReport parameters if present
            if (!_.isUndefined(wrParameters)){
                postData = _.extend(postData, UrlWebReports.getWebReportParametersAsData(wrParameters) );
            }

            csuiContainerID = UrlWebReports.getCurrentContainerID(context);

            // Extend the POST data with the current container ID if defined
            if (!_.isUndefined(csuiContainerID)){
                postData = _.extend(postData, {csuiContainerID: csuiContainerID} );
            }

            // Extend the POST data with the current chart state
            postData = _.extend(postData, this.getFilteredCountParms() );

            return postData;
        },

        getActiveColumn: function(){
            var activeColumnName,
                activeColumnModel;

            if (this.columns){
                activeColumnModel = this.columns.findWhere({active_column:true});

                if (activeColumnModel){
                    activeColumnName = activeColumnModel.get("name");
                }
            }

            return activeColumnName;
        },

        getCountColumn: function(){
            var countColumnName,
                countColumnModel;

            if (this.columns){
                countColumnModel = this.columns.findWhere({count_column:true});

                if (countColumnModel){
                    countColumnName = countColumnModel.get("name");
                }
            }

            return countColumnName;
        },

        getFilters: function(){
            // Clone required because backbone doesn't recognise a change event has occurred if the object has the same reference.
            return _.deepClone(this.overlayModel.get('fc_filters'));
        },

        getSortOptions: function(){
            return {
                sortBy: this.overlayModel.get('sort_by'),
                sortOrder: this.overlayModel.get('sort_order')
            };
        },

        getTotalCount: function() {
            return this.models.reduce(function (memo, value) {
                return memo + value.get('value');
            }, 0);
        },

        getPercentageOfTotal: function(value){
            return ((value / this.getTotalCount()) * 100);
        },


        getGroupAfter: function(){
            return this.overlayModel.get('group_after');
        },

        mapFacetData: function(filteredData){

            var availableValues = [],
                facets = this.columns.toJSON(),
                activeColumn = _.findWhere(facets, {active_column:true}),
                activeFacet = {},
                facetObj = {},
                orderedFacets = [];
            activeFacet[activeColumn.id] = _.map(filteredData, _.bind(function(groupedItem){
                return {
                    name: groupedItem.key_formatted || groupedItem.key,
                    value: !_.isUndefined(groupedItem.key) ? groupedItem.key : groupedItem.key_formatted,
                    total: groupedItem.value,
                    percentage: this.getPercentageOfTotal(groupedItem.value)
                };
            }, this ));

            activeFacet[activeColumn.id] = _.reject(activeFacet[activeColumn.id], function(facet){
                return facet.name === "Other";
            });

            availableValues[0] = activeFacet;

            _.each(facets, function(facet){
                facetObj[facet.id] = facet;
            });

            _.each(availableValues, _.bind(function (item) {
                // topics are nested by the facet id as the single key property
                var id = _.keys(item)[0],
                    topics = item[id],
                    object = {},
                    existingFacetIndex = -1,
                    originalFacetNames = [],
                    facetModel;

                if (this.facetFilters && this.facetFilters.filters){

                    originalFacetNames = this._getAppliedFacetNames();

                    existingFacetIndex = originalFacetNames.indexOf(facetObj[id].name);

                }

                object[id] = facetObj[id];
                facetObj[id].name = facetObj[id].name_formatted;

                facetModel = new Backbone.Model(facetObj[id]);

                // Only add the topics if there are no filters applied for this facet already.
                // otherwise the user will be able to select the same filter twice.
                if (existingFacetIndex === -1){
                    facetModel.topics = new FacetTopicCollection(topics);
                } else {
                    facetModel.topics = new FacetTopicCollection();
                }

                orderedFacets.push(facetModel);

            }, this));

            if (this.facetFilters) {
                this.facetFilters.reset(orderedFacets);
            } else {
                this.facetFilters = new FilteredCountFacetCollection(orderedFacets);
            }

        },

        _getAppliedFacetNames: function(){
            return _.map(this.facetFilters.filters, _.bind(function (filter){
                return this.getActiveColumnByFormattedName(filter.facetName);
            }, this));
        },

        // Convert filters to format expected by facet.bar.view.
        mapFilterData: function(filters){

            return _.map(filters, function(filtersToMap){
                    return {
                        facetName: filtersToMap.column ,
                        values: [{topicName: filtersToMap.value}]
                    };
                }
            );
        },

        // Convert filters to format expected by server.
        unmapFilterData: function(filters){

            var values = _.map(filters.values, function(value){
                return value.topicName;
            });

            values = this.resolveToActualValues(values);

            var unMappedFilter = {
                column: this.getActiveColumnByFormattedName(filters.facetName),
                operator: 'IN',
                value: values
            };

            return unMappedFilter;
        },

        resolveToActualValues: function(formattedValues){
            var modelKeys = this.map(function(model){
                    return model.get('key');
                }),
                formattedKeys;

            if (!this.models[0].has("key_formatted")){
                return formattedValues;
            } else {
                formattedKeys = this.map(function(model){
                    return model.get('key_formatted');
                });
            }

            return _.map(formattedValues, _.bind(function(value){
                var index = formattedKeys.indexOf(value);
                if (index !== -1 ){
                    value =  modelKeys[index];
                }
                return value;
            }, this));

        },

        addFilter: function(filter){
            var activeColumnName = this._getNextActiveColumn(),
                filters = this.getFilters();

            filters.push(this.unmapFilterData(filter));

            this.overlayModel.set({
                fc_filters: filters,
                active_column: activeColumnName,
                active_column_formatted: this._getFormattedActiveColumnByName(activeColumnName)
            });
        },

        clearFilters: function(){
                var activeColumnName = this._getNextActiveColumn();

                this.overlayModel.set({
                    fc_filters: [],
                    active_column: activeColumnName,
                    active_column_formatted: this._getFormattedActiveColumnByName(activeColumnName)
            });
        },

        _getNextActiveColumn: function(){
            var activeColumn,
                columnNames = this.overlayModel.get('column_names'),
                columnsInFilter = this._getAppliedFacetNames(),
                columnsNotInFilter = _.difference(columnNames, columnsInFilter);

            // If we've filtered on all columns just show the first column in the filter
            if (columnsNotInFilter.length === 0){
                activeColumn = _.first(columnsInFilter);
            } else if (columnsInFilter.length !== 0) {
                activeColumn = _.first(columnsNotInFilter);
            } else {
                activeColumn = _.first(columnNames);
            }

            return activeColumn;
        },

        getActiveColumnByFormattedName: function(activeColumnFormattedName){
            var activeColumnModel = this.columns.findWhere({name_formatted: activeColumnFormattedName});

            return activeColumnModel.get('name');
        },

        _getFormattedActiveColumnByName: function(activeColumnName){
            var activeColumnModel = this.columns.findWhere({name: activeColumnName});

            return activeColumnModel.get('name_formatted') || activeColumnModel.get('name');
        },

        _getCaseInsensitiveProperty: function(obj, name) {
            if (obj && name){
                return obj[name] || obj[_.find(_.keys(obj), function(key){
                        return key.toLowerCase() === name.toLowerCase();
                    })];
            } else {
                return undefined;
            }
        },

        updateFilters: function(facetName, valueToRemove){
            var activeColumnName,
                filters = this.getFilters(),
                origFilterLength = filters.length,
                newFilters = [],
                triggerNeeded = false,
                push = false,
                valIndex;

            _.each(filters,function(filter){
                push = false;
                if (filter.column === facetName){
                    if (filter.value.length > 1 ){
                        valIndex = filter.value.indexOf(valueToRemove);
                        if (valIndex !== -1){
                            filter.value.splice(valIndex, 1);
                            push = true;
                            triggerNeeded = true;
                        } else {
                            push = true;
                        }
                    }
                } else {
                    push = true;
                }
                if (push){
                    newFilters.push(filter);
                }
            });

            activeColumnName = this._getNextActiveColumn();

            if (newFilters.length > 0 ){
                this.overlayModel.set({
                    fc_filters: newFilters,
                    active_column: activeColumnName,
                    active_column_formatted: this._getFormattedActiveColumnByName(activeColumnName)
                });
                // Updating a sub-key on a model attribute doesn't seem to trigger a change event.
                // Manually triggering one in this specific case.
                if (triggerNeeded && (origFilterLength === newFilters.length)){
                    this.overlayModel.trigger('change', this.overlayModel);
                }
            } else {
                this.overlayModel.set({
                    active_column: activeColumnName,
                    active_column_formatted: this._getFormattedActiveColumnByName(activeColumnName)
                });
            }
        },

        updateColumnModels: function(activeColumn){
            // Update the column collection
            var columnModels = this.columns.models;
            _.each(columnModels, function(columnModel){
                if (columnModel.get("active_column") === true && columnModel.get("name") !== activeColumn){
                    columnModel.set({"active_column":false});
                }

                if (columnModel.get("name") === activeColumn){
                    columnModel.set({"active_column":true});
                }
            });

            this.columns.set(columnModels);

        },

        setColumns: function(columns){
            var activeColumnName,
                activeColumn = _.findWhere(columns, {active_column:true} ),
                countColumn = _.findWhere(columns, {count_column:true} ),
                noActiveOrCountColSet = !activeColumn || !countColumn;

            // If the Active or Count columns aren't set, do a case insensitive check and set them.
            if (noActiveOrCountColSet) {
                columns = _.map(columns, _.bind(function(column){
                    if (this.options.activeColumn && (column.name.toLowerCase() === this.options.activeColumn.toLowerCase())){
                        column.active_column = true;
                    }
                    if (this.options.countColumn && (column.name.toLowerCase() === this.options.countColumn.toLowerCase())){
                        column.active_column = true;
                    }
                    return column;
                }, this));
            }

            this.columns = new FilteredCountColumnCollection(columns);

            this.setColumnNames();

            activeColumnName = this.getActiveColumn();

            this.overlayModel.set({
                active_column: activeColumnName,
                active_column_formatted: this._getFormattedActiveColumnByName(activeColumnName),
                count_column: this.getCountColumn()
            }, {silent: true});

        },

        setColumnNames: function(){
            var columnsExcludingCount = this.columns.filter(function(model){
                return (model.get("count_column") !== true);
            });
            this.overlayModel.set({column_names: _.map(columnsExcludingCount, function(model){
                return model.get("name");
            })}, {silent: true});
            this.overlayModel.set({column_names_formatted: _.map(columnsExcludingCount, function(model){
                return model.get("name_formatted") || model.get("name");
            })}, {silent: true});
        },

        sortGroupAndFilter: function(options){
            var filteredData,
                nestedData;

            if (this.grouped_on_server){
                filteredData = this._mapGroupedData();
                if (!this.sorted_on_server || (options && options.sort)) {
                    filteredData = this.sortNest(filteredData, this.getSortOptions());
                }
            } else {
                nestedData = this.nest(this.filterBy(this.rawCollection, this.getFilters()),this.getActiveColumn());
                filteredData = this.groupOutlyingValues(this.sortNest(nestedData,this.getSortOptions()),this.getGroupAfter());
            }

            this.mapFacetData(filteredData);
            // Ensure any default filters are set in the facet panel and facet bar
            if (!this.facetFilters.filters){
                this.facetFilters.filters = this.mapFilterData(this.getFilters());
                this.facetFilters.trigger('reset');
            }

            return filteredData;
        },

	    _mapGroupedData: function () {
            var mappedData = {};
            if (this.groupedData && this.groupedData.data){
                mappedData = _.map(this.groupedData.data, function(rowData){
                    var activeColumn = this.getActiveColumn(),
                        countColumn = this.getCountColumn(),
                        activeColumnValue = this._getCaseInsensitiveProperty(rowData, activeColumn),
                        countColumnValue = this._getCaseInsensitiveProperty(rowData, countColumn),
                        activeFormatted = this._getCaseInsensitiveProperty(rowData, activeColumn+"_formatted") || activeColumnValue ,
                        countFormatted = this._getCaseInsensitiveProperty(rowData, countColumn+"_formatted") || countColumnValue;
                       
                    return {
                        key: activeColumnValue,
                        key_formatted: this._removeEmptyValues(activeFormatted),
                        value: countColumnValue,
                        value_formatted: countFormatted
                    };
                }, this);
            }
            return mappedData;
        },

        _removeEmptyValues: function(value){
            return (value === null ||value === "" || value === undefined) ? lang.noValue :value;
        },

        nest: function(dataset,activeColumn) {
            // for providing a count of 'values' (col 1) where 'key' (col n) = activeColumn

            var nestedData = [],
                index,
                key,
                count,
                nestedItem = {};

            _.each(dataset, _.bind(function(row){

                key = this._removeEmptyValues(row[activeColumn]);
                // Check if the current value in the Active Column has already been counted
                // and added to nestedData
                index = _.findIndex(nestedData, function(nestedRow){
                    return nestedRow.key === key;
                });

                // If this is a new value, add it to the nestedData, otherwise increment the count of the existing object
                if (index === -1){
                    nestedData.push({
                        key: key,
                        key_formatted: key.toString(),
                        value: 1,
                        value_formatted: "1"
                    });
                } else {
                    nestedItem = nestedData[index];
                    count = nestedItem.value;
                    count = count + 1;
                    nestedItem.value = count;
                    nestedItem.value_formatted = count.toString();
                    nestedData[index] = nestedItem;
                }

            },this));

            return nestedData;
        },

        filterBy: function(dataset,filters) {
            // returns a reduced dataset where activeColumn value == filterBy
            // filters is an array of objects: e.g. [{column: 'habitat',value: 'jungle'},{column: 'legs',value: 4 }] will likely return leopards but not chickens

            var column = null,
                value = null,
                operator = null;

            function dataFiltered(d) {
                var filtered,
                    currentValue = this._removeEmptyValues(d[column]);
                switch(operator) {
                    case '==':
                        filtered = currentValue === value;
                        break;
                    case 'IN':
                        filtered = (value.indexOf(currentValue) !== -1);
                        break;
                    default:
                        filtered = (value.indexOf(currentValue) !== -1);
                }

                return filtered;
            }

            _.each(filters,_.bind(function(item) {
                // iterates through each of the objects in the filters array, returning a new dataset of rows where the filter is true
                value = this._removeEmptyValues(item.value);
                column = item.column;
                operator = item.operator;
                dataset = dataset.filter(_.bind(dataFiltered, this));
            }, this));

            return dataset;
        },

        sortNest: function(dataset,sortOptions) {
            // sorts data that has been nested by this.nest
            var sorted = [],
                sortBy,
                sortDir;

            sortBy = sortOptions.sortBy;
            sortDir = sortOptions.sortOrder;

            dataset = dataset.sort(function(a,b) {
                switch (sortBy.toLowerCase()) {
                    case 'ordinal':
                        if (isNaN(a.key)) {
                            // sort alpha values
                            sorted = d3.ascending(a.key,b.key);
                        }
                        else {
                            sorted = a.key - b.key;
                        }
                        break;
                    case 'count':
                        sorted = a.value - b.value;
                        break;
                    default:
                    // nothing
                }
                return sorted;
            });
            return (sortDir === 'asc') ? dataset : dataset.reverse();
        },

        groupOutlyingValues: function(dataset,maxItems) {
            // returns a new dataset where any values lower than the top n are grouped into 'other'
            // dataset must be sorted first
            if (dataset.length > maxItems+1 && maxItems > -1) { // only sensible to group values if there are more than 2 of them
                var d1 = dataset.slice(0,maxItems),
                    d2 = dataset.slice(maxItems),
                    oValue = _.pluck(d2,'value'),
                    oTotal = _.reduce(oValue,function(memo,item) {
                        return memo + item;
                    },0),
                    others = {
                        // FIXME: this will change when the column definition is retrieved from the server
                        // At the moment we risk name clashes because we are only using a single string as an identifier.
                        key: 'Other',
                        value: oTotal
                    };
                d1.push(others);
                return d1;
            }
            else {
                return dataset;
            }
        },

        onOverlayUpdate: function() {

            var overlayChanges = this.overlayModel.changedAttributes(),
                clientOnlyChanges = (_.keys(_.omit(overlayChanges, ['sort_by','sort_order','view_value_as_percentage'])).length === 0),
                goToServer = (this.grouped_on_server && !clientOnlyChanges);

            if (!_.has(overlayChanges, 'column_names')){

                if (goToServer){
                    this._isFetched = false;
                    this._isEmpty = true;
                    this.fetch({type:"POST"});
                } else if (clientOnlyChanges) {
                    this.reset(this.sortGroupAndFilter({sort: true}));
                } else {
                    if (_.has(overlayChanges,'active_column')){
                        this.updateColumnModels(overlayChanges.active_column);
                    }
                    this.reset(this.sortGroupAndFilter());
                }
            }
        }
    });

    ConnectableMixin.mixin(FilteredCountCollection.prototype);

    var originalFetch = FilteredCountCollection.prototype.fetch;
    FilteredCountCollection.prototype.fetch = function (options) {
        options || (options = {});

        var requestExtensions,
            data = {
                format: 'webreport',
                method: 'GET'
            },
            chartQueryParms = this.getFilteredCountQuery();

        data = _.extend(data, chartQueryParms);

        requestExtensions = {
            type:'POST',
            data: data
        };

        // This collection can have a large payload so we send it as a POST and add &method=GET
        // in the url function. This is converted to a GET by the REST API request handler when
        // the POST reaches the server.
        if (options){
            _.extend(options,requestExtensions);
        } else {
            options = requestExtensions;
        }

        return originalFetch.call(this, options);
    };

    return FilteredCountCollection;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/utils/contexts/factories/visual.data.collection.factory',[
  'module',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/utils/contexts/factories/factory',
  'csui/utils/contexts/factories/connector',
  'webreports/widgets/visual.data.filtered.count/impl/models/visualdata/visual.data.collection'
], function (module,_, Backbone, CollectionFactory, ConnectorFactory, VisualDataCollection) {

  var VisualDataCollectionFactory = CollectionFactory.extend({

    // Unique prefix of the default collection instance, when this collection is assigned
    // to a context it can be shared by multiple widgets
    propertyPrefix: 'visualdata',

    constructor: function VisualDataCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      // Obtain the server connector from the application context to share
      // the server connection with the rest of the application; include
      // the options, which can contain settings for dependent factories
      var connector = context.getObject(ConnectorFactory, options);
      options.connector = connector;
      var visualdata = this.options.visualdata || {};

      if (!(visualdata instanceof Backbone.Collection)) {
        var config = module.config();
        visualdata = new VisualDataCollection(visualdata.models, _.extend({
          connector: connector}, visualdata.attributes, config.options, {
          // Prefer refreshing the entire collection to rendering one row after another.
          autoreset: true
        }));
      }

      // Expose the collection instance in the `property` key on this factory
      // instance to be used by the context
      this.property = visualdata;
    },

    fetch: function (options) {
      // Just fetch the collection exposed by this factory
      return this.property.fetch(options);
    }

  });

  return VisualDataCollectionFactory;

});

csui.define('webreports/mixins/webreports.view.mixin',['csui/lib/underscore', 'webreports/utils/url.webreports'
], function (_, Url) {
    "use strict";

    var WebReportsViewMixin = {

        mixin: function (prototype) {
            return _.extend(prototype, {
                setCommonModelOptions: function(options){

                    var parameters,
                        modelOptions = {};

                    if (options && options.data) {

                        // Widgets can pass in WebReport parameters to append to the URL
                        if (_.has(options.data, 'parameters')) {
                            parameters = options.data.parameters;
                            if(!_.isUndefined(parameters) && typeof parameters === "object") {
                                _.extend(modelOptions,{parameters: parameters});

                                // Flatten the parameters and add them directly to the modelOptions
                                // This is needed so that the unique key generated for the collection in the context takes the parameters into account
                                // Nested objects don't get taken into account.
                                _.extend( modelOptions, Url.getWebReportParametersAsData(parameters));
                            }
                        }

                        // Add the id to the modelOptions
                        if (options.data.id) {
                            _.extend(modelOptions,{id: options.data.id});
                        }

                        // If the widget is loaded in a container context then we can get the id
                        // from the page context
                        if (options.context) {
                            _.extend(modelOptions,{context: options.context});
                        }

                    }

                    return modelOptions;
                }
            });
        }

    };

    return WebReportsViewMixin;
});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.content',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"visual-data-container\"></div>";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_visual.data.content', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.content.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone', 'csui/lib/numeral', 'csui/lib/d3', // 3rd party libraries
    'csui/controls/progressblocker/blocker', 'csui/controls/list/emptylist.view',
    'webreports/widgets/visual.data.filtered.count/impl/utils/contexts/factories/visual.data.collection.factory',
    'webreports/mixins/webreports.view.mixin',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',
    'hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.content',
    'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data'
], function (_, $, Marionette, Backbone, numeral, d3, BlockingView, EmptyView, VisualDataCollectionFactory, WebReportsViewMixin, lang, template) {

    var VisualDataContentView = Marionette.ItemView.extend({

        defaults: {
            marginTop: 20,
            marginRight: 20,
            marginBottom: 100,
            marginLeft: 60,
            groupAfter: 10,
            groupAfterMax: 20 //TODO this needs implementing. The idea is that a pie chart has a different sane groupAfter limit to a bar chart
        },

        groupAfterValidValues: [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],

        ui: {
            dataVisContainer: ' .visual-data-container',
            dataVisOverlay: ' .visual-data-overlay'
        },

        visType: '', // Define a unique name in extended objects to identify your visualization type

        constructor: function VisualDataContentView(options) {

            if (options && options.data) {
                // Check if the header is disabled using `header: false` in the options.
                var header = _.has(options.data, 'header') && _.isBoolean(options.data.header) ? options.data.header : true,
                    // Check if scrolling is disabled using `scroll: false` in the options.
                    scroll = _.has(options.data, 'scroll') && _.isBoolean(options.data.scroll) ? options.data.scroll : true,
                    filterable = _.has(options.data, 'filterable') && _.isBoolean(options.data.filterable) ? options.data.filterable : false,
                    expandable = _.has(options.data, 'expandable') && _.isBoolean(options.data.expandable) ? options.data.expandable : false,
                    viewValueAsPercentage = _.has(options.data, 'viewValueAsPercentage') && _.isBoolean(options.data.viewValueAsPercentage) ? options.data.viewValueAsPercentage : false,
                    groupAfter = ( (_.has(options.data, 'groupAfter') && this.groupAfterValidValues.indexOf(parseInt(options.data.groupAfter, 10)) !== -1)) ? parseInt(options.data.groupAfter, 10) : this.defaults.groupAfter || 5,
                    modelOptions;

                options.data.header = header;
                options.data.scroll = scroll;
                options.data.visType = this.visType;
                options.data.groupAfter = groupAfter;
                options.data.filterable = filterable;
                options.data.expandable = expandable;
                options.data.viewValueAsPercentage = viewValueAsPercentage;

                modelOptions = this.setCommonModelOptions(options);

                _.extend(modelOptions, {
                    visType: options.data.type,
                    type: options.data.type,
                    activeColumn: options.data.activeColumn,
                    filters: options.data.filters,
                    filterable: filterable,
                    expandable: expandable,
                    viewValueAsPercentage: viewValueAsPercentage,
                    sortBy: options.data.sortBy,
                    sortOrder: options.data.sortOrder,
                    groupAfter: groupAfter
                });

                BlockingView.imbue({
                    parent: this
                });

                // Set up the data collection object
                options.collection = options.context.getCollection(VisualDataCollectionFactory, {attributes: modelOptions});

                // Whenever the collection is synced, re-render the view
                // This ensures the visualization is rendered to the view when the data
                // has been fetched.
                this.listenTo(options.collection, 'sync', this.resetAndRender)
                    .listenTo(options.collection, 'reset', this.resetAndRender)
                    .listenTo(options.collection, 'request', this.blockActions)
                    .listenTo(options.collection, 'sync error', this.unblockActions);

            }

            // Call the parent constructor to ensure the object is built with all the inherited features.
            Marionette.ItemView.prototype.constructor.apply(this, arguments);

            // SVG needs to be redrawn when the container is re-sized
            this.onWinRefresh = _.bind(this.resetAndRender, this);
            $(window).on("resize.app", this.onWinRefresh);

            this.model = options.collection.overlayModel;

        },

        template: template,

        className: 'visual-data-wrapper',

        changeChartType: function() {
            // TODO: need to get this working and remove comments
            console.log('change chart!');
            console.log(this);
            this.visType = this.model.get("vis_type");
            this.resetAndRender();
        },

        onDomRefresh: function () {
            if (this.collection.isFetched()) {
                this.draw();
                this.isChartRendered = true;
            }
        },

        callBackAlreadyHit: false,

        appendVisElements: function () {
            // override this stub to append the elements of your visualization
            // underneath the root element
        },

        update: function () {
            // override this stub to implement the code to update your visualization
        },

        isChartRendered: false,

        createRootElement: function () {

            //FIXME: constantly adding and subtracting margins is not the right way. we need a core width property, and a with-margins width property

            var width = (this.width() > 0) ? this.width() : $(this.$el).width() - this.marginLeft() - this.marginRight(),
                height = (this.height() > 0) ? this.height() : $(this.$el).height() - this.marginTop() - this.marginBottom();

            // TODO: consider using getBoundingClientRect() to get a dimensions object for the parent container
            /* // e.g.
            var boundingRect = this.$el[0].getBoundingClientRect(),
                width = boundingRect.width,
                height = boundingRect.height;
            */

            // dom refresh can be called multiple times so we need to remove existing charts when we redraw.
            if (this.uniqueID && $('#'+this.uniqueID).length){
                $('#'+this.uniqueID).remove();
            }

            this.uniqueID = _.uniqueId('vis_');
            //TODO: following line is where new viselement replaces all existing charts
            this.visElement = d3.select(this.ui.dataVisContainer[0]).append(this.rootElementType)
                .attr("id", this.uniqueID)
                .attr("width", width + this.marginLeft() + this.marginRight())
                .attr("height", height + this.marginTop() + this.marginBottom());

        },

        onDestroy: function () {
            $(window).off("resize.app", this.onWinRefresh);
        },

        draw: function () {
            if ( this.collection.isEmpty() ){
                this.renderEmptyView();
            } else {
                this.createRootElement();
                this.appendVisElements();
                this.update();
            }
        },

        renderEmptyView: function () {
            var $tileContentElem = this.ui.dataVisContainer.closest('.tile-content'),
                emptyView = new EmptyView({
					text: lang.emptyChartText
				});
            // Render the empty view
            $tileContentElem.html(emptyView.render().el);
            // Hide the settings button
            $tileContentElem.siblings('.visual-data-btn-settings')
                            .addClass('binf-hidden');
            // Hide the expand button
            $tileContentElem.siblings('.tile-footer')
                            .children('.tile-expand')
                            .addClass('binf-hidden');
        },

        resetAndRender: function () {
            this.render();
        },

        checkSign: function (x) {
            return Math.sign || function(x) {
                    x = +x; // convert to a number
                    if (x === 0 || isNaN(x)) {
                        return Number(x);
                    }
                    return x > 0 ? 1 : -1;
                };
        },

        shortenText: function(t) {
            t = t || '';
            var maxLength = 20;
            t = (t.length >= maxLength) ? t.substr(0, maxLength) + '\u2026' : t;
            return t;
        },

        formatCount: function(n){
            var formattedValue, formatTemplate,
                countColumnModel = this.collection.columns.findWhere({count_column: true}),
                format = countColumnModel.get("client_format").type;

			switch(format) {
				case "si":
					formattedValue = this.shortenNumber(n);
					break;
				case "bytes":
					// determine which format we want:
					formatTemplate = (n < 1024) ? '0b' : '0.0b';
                    // call the function to format it:
					formattedValue = numeral(n).format( formatTemplate );
					break;
				default:
					formattedValue = n.toString();
			}
			return formattedValue;
		},

        shortenNumber: function(n) {
            n = n.toPrecision(3) || 0;
            n = Number(n); // remove precision decimal places for integers
            var formatNumber = d3.format('.3s'),
                displayNumber = (n < 1000 && n > -1000) ? n.toString() : formatNumber(n);

            return displayNumber;
        },

        width: function () {
            return this.$el.parent().width() - this.marginLeft() - this.marginRight();

/*          TODO: fix height issues in expanded view when extra toolbars are loaded.
            if (this.options.data.isExpanded){
                var height = this.$el.parent().height() - this.marginTop() - this.marginBottom(),
                    toolbarHeight = ($(".facetbarview").height() || 0) + $(".visual-data-controls").height() || 0,
                    toolbarPercent = (toolbarHeight / height) * 100;

                width = (width -(width / 100)* toolbarPercent);
            }*/

        },

        height: function () {
            return this.$el.parent().height() - this.marginTop() - this.marginBottom();

/*         //TODO: fix height issues in expanded view when extra toolbars are loaded.
            if (this.options.data.isExpanded){
                height = height -  $(".facetbarview").height() || 0;
                height = height -  $(".visual-data-controls").height() || 0;
                height = height -  $(".binf-modal-footer").height() || 0;
            }*/

        },

        marginTop: function () {
            return this.defaults.marginTop;
        },

        marginBottom: function () {
            return this.defaults.marginBottom;
        },

        marginLeft: function () {
            return this.defaults.marginLeft;
        },

        marginRight: function () {
            return this.defaults.marginRight;
        },

        // Allows dynamic setting of the root element type. For instance, this could be changed to canvas for a particular visualization if required.
        rootElementType: "svg"
    });

    // Add the mixin functionality to the target view
    WebReportsViewMixin.mixin(VisualDataContentView.prototype);

    return VisualDataContentView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.overlay',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "binf-hidden";
},"3":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "                        <option value=\""
    + this.escapeExpression(((helper = (helper = helpers.column || (depth0 != null ? depth0.column : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"column","hash":{}}) : helper)))
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ">"
    + this.escapeExpression(((helper = (helper = helpers.column_formatted || (depth0 != null ? depth0.column_formatted : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"column_formatted","hash":{}}) : helper)))
    + "</option>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "selected=\"selected\"";
},"6":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "                    <option value=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ">"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</option>\r\n";
},"8":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "                    <option value=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ">"
    + this.escapeExpression(((helper = (helper = helpers.display || (depth0 != null ? depth0.display : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"display","hash":{}}) : helper)))
    + "</option>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" class=\"visual-data-controls\">\r\n    <div class=\"visual-data-control-group controls-lhs "
    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.multipleColumns : depth0),{"name":"unless","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n        <ul>\r\n            <li>\r\n                <label for=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-active-column\">"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.activeColumn : stack1), depth0))
    + "</label>\r\n                <select name=\"visual-data-active-column\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-active-column\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.columnnames : depth0),{"name":"each","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "                </select>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n    <div class=\"visual-data-control-group controls-rhs\">\r\n        <ul>\r\n            <li> <label for=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-sort-options\">"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.sortBy : stack1), depth0))
    + "</label><select name=\"visual-data-sort-options\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-sort-options\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.sortOptions : depth0),{"name":"each","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "            </select></li>\r\n            <li><label for=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-value-as-percentage\">"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.showValuesAs : stack1), depth0))
    + "</label><select name=\"visual-data-value-as-percentage\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-value-as-percentage\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.viewValueAsPercentage : depth0),{"name":"each","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "            </select></li>\r\n            <li><label for=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-group-after\">"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.groupAfter : stack1), depth0))
    + "</label> <select name=\"visual-data-group-after\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "_visual-data-group-after\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.groupAfter : depth0),{"name":"each","hash":{},"fn":this.program(8, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "            </select></li>\r\n        </ul>\r\n    </div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_visual.data.overlay', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.overlay.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/lib/backbone', // 3rd party libraries,
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',
    'hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.overlay',
    'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data'
], function (_, $, Marionette, Backbone, lang, template) {

      var VisualDataOverlayView = Marionette.ItemView.extend({

          constructor: function VisualDataOverlayView(options) {

              this.model = options.overlayModel;
              this.uniqueID = _.uniqueId("visual-data-controls_");

              // Call the parent constructor to ensure the object is built with all the inherited features.
              Marionette.ItemView.prototype.constructor.apply(this, arguments);
          },

          ui: function(){
              return {
                  settingsField: '#'+ this.uniqueID +' select'
              };
          },

          template: template,

          events: {
               'change @ui.settingsField': 'onChangeSetting'
          },

          templateHelpers: function () {
              // TODO: generate 'chartSelectOptions' using a chart collection rather than hard-coded values.
              var groupAfter = _.map([2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], function (value) {
                      return {
                          value: value ,
                          display: value ,
                          selected: this.model.get('group_after') === value
                      };
                  }, this),
                  chartSelectOptions = [
                      {visType: 'bar', name: lang.barChart, selected: this.model.get('vis_type') === 'bar'},
                      {visType: 'donut', name: lang.donutChart, selected: this.model.get('vis_type') === 'donut'},
                      {visType: 'pie', name: lang.pieChart, selected: this.model.get('vis_type') === 'pie'}
                  ],
                  viewValueAsPercentage = [
                      {value:"true", selected: this.model.get("view_value_as_percentage"), label: lang.percentage},
                      {value:"false", selected: !this.model.get("view_value_as_percentage"), label: lang.actual}
                  ],
                  sortOptions = [
                        {value:"Count|asc", selected: (this.model.get("sort_by") === "Count" && this.model.get("sort_order") === "asc"), label: lang.count+':'+ lang.asc},
                        {value:"Count|desc", selected: (this.model.get("sort_by") === "Count" && this.model.get("sort_order") === "desc"), label: lang.count+':'+ lang.desc},
                        {value:"ordinal|asc", selected: (this.model.get("sort_by") === "ordinal" && this.model.get("sort_order") === "asc"), label: lang.activeColumn+':'+ lang.asc},
                        {value:"ordinal|desc", selected: (this.model.get("sort_by") === "ordinal" && this.model.get("sort_order") === "desc"), label: lang.activeColumn+':'+ lang.desc}
                  ],
                  columnNames = _.map(this.model.get('column_names'), function (column, index) {
                      return {
                          column: column,
                          column_formatted: this.model.get('column_names_formatted')[index],
                          selected: this.model.get('active_column') === column
                      };
                  }, this);

              return {
                  chartoptions: chartSelectOptions,
                  columnnames: columnNames,
                  groupAfter: groupAfter,
                  viewValueAsPercentage: viewValueAsPercentage,
                  sortOptions: sortOptions,
                  lang: lang,
                  id: this.uniqueID,
                  multipleColumns: (columnNames.length > 1 )
              };

          },

          onChangeSetting: function(event) {
              event.preventDefault();
              this.updateSettings();
          },

          updateSettings: function() {

              var activeColumn,
                  activeColumnFormatted,
                  sortOptions,
                  sortBy,
                  sortOrder,
                  overlayForm = $('#'+ this.uniqueID +' select'),
                  overlayFormData= overlayForm.serializeArray();

              // convert overlayFormData into an object with key/values.
              overlayFormData = _.object(_.map(overlayFormData, _.values));

              activeColumn = overlayFormData['visual-data-active-column'];
              sortOptions = overlayFormData['visual-data-sort-options'];
              sortOptions = sortOptions.split('|');
              sortBy = sortOptions[0];
              sortOrder = sortOptions[1];
              activeColumnFormatted = $("#"+ this.uniqueID +" select[name='visual-data-active-column'] option[value='"+activeColumn+"']").text();

              this.model.set({
                  active_column: activeColumn,
                  active_column_formatted: activeColumnFormatted,
                  sort_by: sortBy,
                  sort_order: sortOrder,
                  view_value_as_percentage: (overlayFormData['visual-data-value-as-percentage'].toLowerCase() === 'true'), // cast string as boolean
                  group_after: +overlayFormData['visual-data-group-after'] //string to number
              });
          }

      });

    return VisualDataOverlayView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.bar',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-header\">"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.header : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n<!--outer/inner wrappers used to size and identify when number of -->\r\n<!--chicklets cannot fit within provided outer wrapper width.-->\r\n<div class=\"csui-facet-list-area\">\r\n  <ol class=\"csui-facet-list\"></ol>\r\n  <div class=\"binf-dropdown dropdown-facet-list csui-hidden\">\r\n    <button type=\"button\" class=\"binf-btn binf-btn-default binf-dropdown-toggle\"\r\n            data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\">\r\n      <span class=\"csui-icon icon-more\"></span>\r\n    </button>\r\n    <ul class=\"binf-dropdown-menu\" role=\"menu\" aria-labelledby=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n    </ul>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"csui-clear-all\" tabindex=\"-1\">\r\n  <div class='cs-icon binf-close'></div>\r\n  <div class='clear-label'>"
    + this.escapeExpression(((helper = (helper = helpers.clearAll || (depth0 != null ? depth0.clearAll : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"clearAll","hash":{}}) : helper)))
    + "</div>\r\n</div>\r\n\r\n\r\n\r\n";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_facet.bar_impl_facet.bar', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "\r\n<li class=\"csui-facet-item zero-height\">\r\n  <a tabindex=\"-1\">\r\n  <span class=\"csui-label\">"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n  <span class=\"csui-icon binf-close\" data-facet=\""
    + this.escapeExpression(((helper = (helper = helpers.facetIndex || (depth0 != null ? depth0.facetIndex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"facetIndex","hash":{}}) : helper)))
    + "\" data-topic=\""
    + this.escapeExpression(((helper = (helper = helpers.topicIndex || (depth0 != null ? depth0.topicIndex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"topicIndex","hash":{}}) : helper)))
    + "\"></span>\r\n  </a>\r\n</li>\r\n";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_facet.bar_impl_facet.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/nls/root/lang',{
  clearAll: 'Clear all'
});



csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.bar',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/facet.bar.view',[
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/backbone",
  "csui/lib/marionette",
  "csui/models/facets",
  "csui/models/facettopics",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  "hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.bar",
  "hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.item",
  "i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/nls/lang",
  "css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/impl/facet.bar"
], function ( $, _, Backbone, Marionette, FacetCollection,
    FacetTopicCollection, TabableRegionBehavior, template, itemTemplate, lang) {

  var FacetBarView =Marionette.ItemView.extend({

    listItemContext: itemTemplate,
    template: template,
    className: 'csui-facet-bar',
    ui:{
      facetListArea : '> div.csui-facet-list-area',
      facetList : '> div.csui-facet-list-area .csui-facet-list',
      facetDropdown: '.dropdown-facet-list',
      facetDropdownList : '.dropdown-facet-list > ul',
      dropdownBtn: '.binf-dropdown button',
      facetHeaderLabel: '> .csui-header',
      clearAll: '.csui-clear-all'
    },

    triggers: {
      'click .csui-clear-all': 'clear:all'
    },

    events: {
      'click .csui-facet-item .binf-close': 'onRemoveFilter',
      'keydown': 'onKeyInView'
    },
    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    templateHelpers:function(){
      var options = this.options;
      return {
        clearAll: lang.clearAll,
        header: options.header,
        label: options.label
      };
    },

    constructor: function FacetBarView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.collection, 'reset', this.render, this);
      this.onWinResize = _.bind(function () {
        this.render();
      }, this);
      $(window).bind("resize.facetview", this.onWinResize);

    },

    currentlyFocusedElement: function () {
      //change the input and icons back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      var dropdownBtn = this.ui.dropdownBtn,
          focusables = this.$('.csui-facet-item > a[tabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
        if (_.isFunction(this.ui.clearAll.prop)){
          this.ui.clearAll.prop('tabindex', 0);
        }
      }
      if (_.isFunction(this.ui.facetDropdown.hasClass)){
        if (this.ui.facetDropdown.hasClass('csui-hidden')) {
          dropdownBtn.prop('tabindex', -1);
        }
        else{
          dropdownBtn.prop('tabindex', 0);
        }
      }
      return $(this.$('[tabindex]')[0]);
    },
    onKeyInView: function (event) {
      var keyCode = event.keyCode,
          retVal = true,
          $target = $(event.target);

      switch (keyCode) {
        //delete key
        case 46:
          if ($target.parent().hasClass('csui-facet-item')) {
            $target = $target.find('.binf-close');
            this.trigger('remove:filter',
                {facetIndex: $target.attr('data-facet'), filterIndex: $target.attr('data-topic')});
            retVal = false;
          }
          break;
        //enter and space bar
        case 13:
          if ($target.hasClass('csui-clear-all')) {
            this.trigger('remove:all');
            retVal = false;
          }
          break;
        //ignore space bar but return false as it appears to affect the facet panel scrolling
        case 32:
          retVal = false;
          break;
      }
      return retVal;
    },

    onDestroy: function(){
      $(window).unbind("resize.facetview", this.onWinResize);
    },

    onRender: function(){
      if ( this.collection.filters.length > 0 ) {
        this.$el.show();
      }
      else{
        this.$el.hide();
      }
    },

   onDomRefresh: function () {
     this.ui.facetList[0].innerHTML = '';
     var filters = this.collection.filters,
       overflowStartIndex = this.addToFacetBar(filters);

     if (overflowStartIndex) {
        this.ui.facetDropdown.removeClass('csui-hidden');
       this.addToOverFlowDropDown(filters, overflowStartIndex);
     }
   },

    addToOverFlowDropDown: function(filters, startIndex) {
      var i = startIndex.startFilter,
        jqDropDownList = this.ui.facetDropdownList;

      for (; i < filters.length; i++) {
        var filter = filters[i],
          values = filter.values,
          j =  (i === startIndex.startFilter) ? startIndex.startValue : 0;

        for(; j < values.length ; j++) {
            var filterName = filter.facetName + ' : ' + values[j].topicName,
              newTopic = $(this.listItemContext({label: filterName, facetIndex: i, topicIndex: j}));

            newTopic.removeClass('zero-height');
            jqDropDownList.append(newTopic);
        }
      }
    },

    addToFacetBar: function(filters){
     var ui = this.ui,
       jqFacetListArea = ui.facetListArea,
       jqFacetList = ui.facetList;

     for (var i = 0; i < filters.length; i++) {
       var filter = filters[i],
         values = filter.values;

       for (var j = 0; j < values.length; j++) {

         var filterName = filter.facetName + ' : ' + values[j].topicName,
           newTopic = $(this.listItemContext({label: filterName, facetIndex: i, topicIndex: j}));

         jqFacetList.append(newTopic);

         var widthOfListArea = jqFacetListArea.width(),
              widthOfMoreIcon = ui.facetDropdown.width(),
           widthOfList = jqFacetList.width() + widthOfMoreIcon;

         if (widthOfList < widthOfListArea) {
           newTopic.removeClass('zero-height');
         }
         else {
           newTopic.remove();
           return {startFilter: i, startValue: j};
         }
       }
     }
   },

    onClearAll: function(){
      this.trigger('remove:all');
    },

    onRemoveFilter: function(e){
      var target = $(e.target);
      this.trigger('remove:filter',
          {facetIndex: target.attr('data-facet'), filterIndex: target.attr('data-topic')});
    },

    applyFilter: function(facet){
      this.trigger('apply:filter', facet.newFilter);
    },

    updateHeaderLabel: function( label ){
      this.options.label = label;
      this.ui.facetHeaderLabel.text(label);
    }
  });


  return FacetBarView;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.key.navigation',['csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var KeyEventNavigation = {

    onKeyInView: function (event) {
      var keyCode = event.keyCode;
      var retVal = false;

      switch (keyCode) {
        //escape
        case 27:
          this.trigger('escape:focus');
          this.activeChild.removeClass('csui-focus');
          break;
        //Enter and space
        case 32:
        case 13:
            this.execute(this.activeChild);
          break;
        //up arrow, page up
        //down arrow, page down
        case 38:
        case 33:
        case 40:
        case 34:
          //ignore up/down arrow keys for sub-facet. Up/down arrow keys is only relevant
          //on the facet panel or with in the individual filter lists.
          if (this.activeChild && this.activeChild.hasClass('csui-focus')) {
            break;
          }
          retVal = true;
          break;
        //tab/shift-tab
        case 9:
          if (this.activeChild && this.$el.hasClass('csui-focus')) {
            retVal = this.tab(event.shiftKey);
            break;
          }
          retVal = true;
          break;
        default:
          retVal = true;
      }
      return retVal;
    },

    execute: function (activeChild) {
      //If this facet is disabled for selection, then on execution expand or collapse
      //the facet group
      this.$el.addClass('csui-focus');
      if (this.$el.find('.facet-disabled').length) {
        this.onShowFacet();
      }
      else {
        this.setfocus(activeChild);
      }
    },
    setfocus : function(activeChild) {
      (activeChild && activeChild.is(':visible')) || (activeChild = this.getActiveChild());

      if (activeChild.hasClass('csui-focus')) {

        switch (activeChild) {
          case this.ui.facetHeaderIcon:
            if(this.ui.facetHeader.hasClass('binf-disabled')){
              break;
            }
            activeChild.trigger('click');
            activeChild.addClass('csui-focus');
            break;

          case this.ui.apply:
          case this.ui.cancel:
            activeChild.trigger('click');
            this.trigger('escape:focus');
            this.activeChild = undefined;
            break;

          case this.ui.facetMore:
            //reset focus to "show more/less" so that
            //scrolled focus is still on the "show more/less" after the
            //default action
            activeChild.trigger('click');
            if (activeChild === this.ui.facetMore) {
              this.activateChild(activeChild);
            }
        }
      }
      else {
        this.activateChild(activeChild);
      }
    },

    tab: function (shiftTab) {
      var facets = this.$el.find('.csui-facet-item:not(.binf-hidden)');

      if (this.activeChild.hasClass('csui-focus')) {
        if (shiftTab) {
          this.activeChild = this._getPrevActiveChild(facets);
        }
        else {
          this.activeChild = this._getNextActiveChild(facets);
        }

        this.activateChild(this.activeChild);
        return false;
      }

      return true;
    },

    activateChild: function (activeChild) {
      activeChild || (activeChild = this.getActiveChild());
      if (this.prevChild) {
        this.prevChild.removeClass('csui-focus');
      }
      activeChild.addClass('csui-focus');
      activeChild.focus();
      this.prevChild = this.activeChild;
    },

    getActiveChild: function () {
      var childViewContainers = this.$el.find('.csui-facet-item:not(.binf-hidden)');
      if (!this.activeChild || !this.activeChild.is(':visible')) {
        if (this.ui.facetHeaderIcon.hasClass('.icon-expandArrowDown')) {
          this.activeChild = this.ui.facetHeaderIcon;
        }
        else {
          this.activeChild = $(childViewContainers[0]).find('span');
          this.activeChildIndex = 0;
        }
      }
      return this.activeChild;
    },


    cursorNextFilter: function (view, keyUp, target) {
      var childViewContainers = this.$el.find('.csui-facet-item:not(.binf-hidden)'),
        numViews = childViewContainers.length - 1;

      if (keyUp) {
        this.activeChildIndex = this.activeChildIndex === 0 ? numViews : --this.activeChildIndex;
      }
      else {
        this.activeChildIndex = this.activeChildIndex === numViews ? 0 : ++this.activeChildIndex;
      }

      if (target.hasClass('icon')) {
        this.activeChild = $(childViewContainers[this.activeChildIndex]).find('span');
      }
      else {
        this.activeChild = $(childViewContainers[this.activeChildIndex]).find('.csui-filter-name');
      }

      this.children.findByIndex(this.activeChildIndex).activeChild = this.activeChild;
      this.activateChild(this.activeChild);
    },

    _getLastFilterFocus: function (facets) {
      var childIndex = this.activeChildIndex;
      this.activeChildIndex = childIndex && childIndex < facets.length ? childIndex : 0;
      return this.children.findByIndex(this.activeChildIndex).activeChild;
    },

    _getNextActiveChild: function (facets) {
      var nextChild = this.activeChild;

      switch (this.activeChild) {
        case this.ui.facetHeaderIcon:
          if (this.ui.facetHeaderIcon.hasClass('icon-expandArrowUp')) {
            nextChild = this._getLastFilterFocus(facets);
          }
          break;
        case this.ui.facetMore:
          if (this.$el.find('.csui-multi-select').length > 0) {
            nextChild = this.ui.apply;
          }
          break;
        case this.ui.cancel:
          break;
        case this.ui.apply:
          nextChild = this.ui.cancel;
          break;
        default:
          if (this.ui.facetMore.length > 0) {
            nextChild = this.ui.facetMore;
          }
          else if (this.$el.find('.csui-multi-select').length > 0) {
            nextChild = this.ui.apply;
          }
      }

      return nextChild;
    },

    _getPrevActiveChild: function (facets) {
      var nextChild = this.activeChild;

      switch (this.activeChild) {
        case this.ui.facetHeaderIcon:
          break;
        case this.ui.facetMore:
          nextChild = this._getLastFilterFocus(facets);
          break;
        case this.ui.cancel:
          nextChild = this.ui.apply;
          break;
        case this.ui.apply:
          if (this.ui.facetMore.length > 0) {
            nextChild = this.ui.facetMore;
          }
          else {
            nextChild = this._getLastFilterFocus(facets);
          }
          break;
        default:
          if(this.ui.facetHeader.hasClass('binf-disabled')){
            break;
          }
          nextChild = this.ui.facetHeaderIcon;
      }

      return nextChild;
    }


  };

  return KeyEventNavigation;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"icon icon-checkbox "
    + this.escapeExpression(((helper = (helper = helpers.showOnHover || (depth0 != null ? depth0.showOnHover : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showOnHover","hash":{}}) : helper)))
    + "\" tabindex=\"-1\">\r\n    <input type=\"checkbox\" />\r\n  </span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.enableCheckBox : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "<div class=\"csui-filter-name\" tabindex=\"-1\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + " ("
    + this.escapeExpression(((helper = (helper = helpers.total || (depth0 != null ? depth0.total : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"total","hash":{}}) : helper)))
    + ")\">\r\n    <div class=\"csui-name\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</div>\r\n    <div class=\"csui-total\">"
    + this.escapeExpression(((helper = (helper = helpers.total || (depth0 != null ? depth0.total : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"total","hash":{}}) : helper)))
    + "</div>\r\n</div>";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_facet.panel_impl_facet_facet.item', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item.view',["csui/lib/jquery", "csui/utils/base", "csui/lib/underscore", "csui/lib/marionette",
  "hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item",
  "css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item"
], function ($, base, _, Marionette, template) {

  var FacetItemView = Marionette.ItemView.extend({

    template: template,
    className: 'csui-facet-item',

    constructor: function FacetItemView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.showInputOnHover =  !base.isTouchBrowser();
		this.uniqueID = _.uniqueId("visual-data-controls_");
    },

    triggers: {
      'click .csui-filter-name': 'single:filter:select'
    },

    events: {
      'click input': 'onCheckBoxSelect',
      'change input': 'onChangeValue',
      'keydown > span': 'onKeyInView',
      'keydown .csui-filter-name': 'onKeyInView'
    },

    ui: {
      icon: '> span',
      checkbox: '> span input',
      filterName: '> .csui-filter-name'
    },

    templateHelpers: function(){
      var showOnHover = this.showInputOnHover? '' : 'csui-showAlways';
      return {
        showOnHover: showOnHover,
          id: this.uniqueID,
        enableCheckBox : this.options.enableCheckBoxes
      };
    },
    onKeyInView: function(event){
      var keyCode = event.keyCode,
        target = $(event.target);
      switch (keyCode) {
        //Enter and space
        case 32:
        case 13:
          if(target.hasClass('icon')){
            this.ui.checkbox.trigger('click');
          }
          else{
            this.trigger('single:filter:select', this);
          }
          break;
        //right/left arrow
        case 39:
        case 37:
          //this.trigger('keyleftright', targetElem);
          this.activeChild = target.hasClass('icon')?
            this.ui.filterName: this.ui.icon;
          this.activeChild.focus();
          break;
        case 38:
        case 40:
          this.trigger('keyupdown', keyCode === 38, target);
          break;
        default:
          return true;
      }
      return false;
    },

    onCheckBoxSelect: function(event){
      this.trigger('multi:filter:select', this);
    },

    onChangeValue: function (event) {
      // TODO: Create some interface for checking/unchecking and
      // enabling/disabling the checkbox.  The parent view does
      // it by jquery and has to trigger the change event to get
      // the UI updated.
      var checkbox = event.target;
      if (checkbox.disabled) {
        this.ui.icon
            .removeClass('icon-checkbox icon-checkbox-selected')
            .addClass('icon-checkbox-disabled');
      } else if (checkbox.checked) {
        this.ui.icon
            .removeClass('icon-checkbox icon-checkbox-disabled')
            .addClass('icon-checkbox-selected');
      } else { // unchecked
        this.ui.icon
            .removeClass('icon-checkbox-selected icon-checkbox-disabled')
            .addClass('icon-checkbox');
      }
    },

    getIndex: function(){
      return this._index;
    }

  });

  return FacetItemView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-filter-more\" tabindex=\"-1\">\r\n        <div class=\"csui-more-text\">"
    + this.escapeExpression(((helper = (helper = helpers.more || (depth0 != null ? depth0.more : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"more","hash":{}}) : helper)))
    + "</div>\r\n        <div class=\"cs-icon "
    + this.escapeExpression(((helper = (helper = helpers['more-icon'] || (depth0 != null ? depth0['more-icon'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"more-icon","hash":{}}) : helper)))
    + "\"></div>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-facet-header\">\r\n  <div class=\"header-label\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</div>\r\n  <div class=\"header-count\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.count || (depth0 != null ? depth0.count : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"count","hash":{}}) : helper)))
    + "\"> ("
    + this.escapeExpression(((helper = (helper = helpers.count || (depth0 != null ? depth0.count : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"count","hash":{}}) : helper)))
    + ")</div>\r\n  <div class=\"cs-icon csui-button-icon icon-expandArrowUp\" tabindex=\"-1\"></div>\r\n  <div class=\"csui-right-shadow\"></div>\r\n</div>\r\n\r\n<div class=\"csui-facet-content "
    + this.escapeExpression(((helper = (helper = helpers['show-content'] || (depth0 != null ? depth0['show-content'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"show-content","hash":{}}) : helper)))
    + "\">\r\n  <div class=\"cs-filter-group\"></div>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.more : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <div class=\"csui-facet-controls "
    + this.escapeExpression(((helper = (helper = helpers['show-controls'] || (depth0 != null ? depth0['show-controls'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"show-controls","hash":{}}) : helper)))
    + "\">\r\n      <button class=\"csui-btn binf-btn binf-btn-primary csui-apply\">"
    + this.escapeExpression(((helper = (helper = helpers.apply || (depth0 != null ? depth0.apply : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"apply","hash":{}}) : helper)))
    + "</button>\r\n      <button class=\"csui-btn binf-btn binf-btn-secondary csui-clear\">"
    + this.escapeExpression(((helper = (helper = helpers.clear || (depth0 != null ? depth0.clear : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"clear","hash":{}}) : helper)))
    + "</button>\r\n</div>\r\n\r\n</div>\r\n";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_facet.panel_impl_facet_facet', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/nls/root/lang',{
  facetTitle: 'Refine by',
  searchIconTooltip: 'Search by {0}',
  searchClearIconTooltip: 'Clear all',
  emptyFacetMessage: 'No filters available.',
  emptyFilteredFacetMessage: 'No more filters available.',
  loadingFacetMessage: 'Loading filters...',
  failedFacetMessage: 'Loading filters failed.',
  noFiles: 'No drop files were provided.',
  addTypeDenied: 'Cannot add documents to {1}.',
  showMore: 'Show more',
  showLess: 'Show less',
  apply: 'Apply',
  clear: 'Cancel'
});



csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.view',["module",
  "csui/lib/underscore",
  "csui/lib/jquery",
  "csui/lib/marionette",
  "csui/models/facettopics",
  'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.key.navigation',
  "csui/utils/log",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  "webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.item.view",
  "hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet",
  "i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/nls/lang",
  "css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet"
], function (module, _, $, Marionette, FacetTopicCollection, KeyEventNavigation, log, TabableRegionBehavior,
             FacetItemView, template, lang) {

  var FacetView = Marionette.CompositeView.extend({

    childView: FacetItemView,
    template: template,
    className: 'csui-facet',

    childViewContainer: '.cs-filter-group',

    ui: {
      facetContent: '.csui-facet-content',
      facetHeader: '.csui-facet-header',
      facetHeaderIcon: '.csui-facet-header > .cs-icon',
      facetSubmitControls: '.csui-facet-controls',
      facetCollapseControls: '.csui-facet-collapse-controls',
      facetMoreText: '.csui-more-text',
      facetMoreIcon: '.csui-filter-more .cs-icon',
      facetMore: '.csui-filter-more',
      apply: '.csui-facet-controls .csui-apply',
      cancel: '.csui-facet-controls .csui-clear',
      selectCount: '.header-count'
    },

    childEvents: {
      'single:filter:select': 'onSingleFilterSelect',
      'multi:filter:select': 'onMultiFilterSelect',
      'keyupdown': 'cursorNextFilter',
      'keyleftright': 'cursorInsideFilter'
    },

    events: {
      'click .csui-filter-more:not(.binf-disabled)': 'onShowMore',
      'click .csui-facet-header': 'onShowFacet',
      'mouseleave': 'onMouseLeave',
      'keydown':  'onKeyInView'
    },

    triggers: {
      'click .csui-clear': 'clear:all',
      'click .csui-apply': 'apply:all'
    },


    templateHelpers: function () {
      var moreLabel = this.showAll ? lang.showLess : lang.showMore;
      return {
        'more': this.collection.length > this.itemsToShow ? moreLabel : undefined,
        'more-icon': this.showAll ? 'icon-expandArrowUp' : 'icon-expandArrowDown',
        'apply': lang.apply,
        'clear': lang.clear,
        'show-controls': this.selectItems.length > 0 ? 'csui-multi-select' : '',
        'show-content': this.showFacet ? '' : 'binf-hidden'
      };
    },

    childViewOptions: function () {
      return {enableCheckBoxes: this.options.enableCheckBoxes};
    },

    constructor: function FacetView(options) {
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.$el.attr('tabindex', 0);
      this.options = options || {};
      this.collection = this.model.topics;
      this.itemsToShow = this.model.get('items_to_show');
      this.showAll = false;
      this.showFacet = true;
      this.selectItems = [];
    },

    onClearAll: function () {
      var checkboxes = this.$el.find('input:checkbox');

      this.selectItems = [];
      this.ui.facetCollapseControls.removeClass('multi-select');
      this.ui.selectCount.text('(0)');
      // Trigger change to inform the facet item view,
      // that the look of the checkbox should change.
      checkboxes.prop('checked', false).trigger('change');
      this._setDisabledFilters(0);
      this.$el.removeClass('multi-select');
      this._updateFacetSubmitControls();
      this.ui.facetHeader.removeClass('binf-disabled');
      this.trigger('activate:facet', this);
    },

    onApplyAll: function () {
      var facet = this.model,
        filters = this._getFilterArray();

      this.newFilter = {
        id: facet.get('id'),
        facetName: facet.get('name'),
        values: filters
      };
      this.trigger('apply:filter');
    },

    onAddChild: function (childView) {
      //Hide all children with index greater than the set number of items to show from server
      if (childView.getIndex() >= this.itemsToShow) {
        var className = this.showAll ? 'more' : 'more binf-hidden';
        childView.$el.addClass(className);
      }
    },

    onRender: function () {
      if (this.collection.length === 0) {
        this.$el.hide();
      }
    },

    onSingleFilterSelect: function (filter) {
      if (!filter.$el.hasClass('binf-disabled')) {
        if (this.$el.hasClass('multi-select')) {
          filter.$el.find('input:checkbox').click();
        }
        else {
          var facet = this.model;
          this.newFilter = {
            id: facet.get('id'),
            facetName: facet.get('name'),
            values: [{
              id: filter.model.get('value'),
              topicName: filter.model.get('name')
            }]
          };
          this.trigger('apply:filter');
        }
      }
    },

    onShowMore: function (event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      this.showAll = !this.showAll;
      this._setMoreLabel(this.showAll);
      this.trigger('facet:size:change');
    },

    onShowFacet: function (event) {
      if (event) {
      event.preventDefault();
      event.stopPropagation();
      }
      this.showFacet = !this.showFacet;
      if (this.showFacet) {
        this.ui.facetContent.removeClass('binf-hidden');
        this.ui.facetCollapseControls.removeClass('multi-select');
        this.ui.facetHeaderIcon[0].className = 'cs-icon csui-button-icon icon-expandArrowUp';
      }
      else {
        var checkItems = this.$el.find("input:checked").length;
        this.ui.facetContent.addClass('binf-hidden');
        this.ui.facetHeaderIcon[0].className = 'cs-icon csui-button-icon icon-expandArrowDown';
        if (checkItems) {
          this.ui.facetCollapseControls.addClass('multi-select');
        }
      }
      this.trigger('facet:size:change');
    },

    onMouseLeave: function (event) {
      event.preventDefault();
      event.stopPropagation();
    },

    getIndex: function () {
      return this._index;
    },

    onMultiFilterSelect: function (childView) {
      var checkItems = this.$el.find("input:checked").length;
      this._updateSelectList(childView);
      this._updateFacetSubmitControls(checkItems);
      this._setDisabledFilters(checkItems);
      this.selectItems = (checkItems === 0) ? [] : this.selectItems;
      this.trigger('activate:facet', this);
    },

    _updateFacetSubmitControls: function () {
      var checkItems = this.$el.find("input:checked").length;

      if (checkItems > 0) {
        this.ui.facetSubmitControls.addClass('csui-multi-select');
        this.$el.addClass('multi-select');
        this.ui.facetHeader.addClass('binf-disabled');
      }
      else {
        this.ui.facetSubmitControls.removeClass('csui-multi-select');
        this.$el.removeClass('multi-select');
        this.ui.facetHeader.removeClass('binf-disabled');
      }
    },

    _updateSelectList: function (childView) {
      var childIndex = childView.getIndex();
      if (this.selectItems[childIndex]) {
        delete this.selectItems[childIndex];
      }
      else {
        this.selectItems[childIndex] = childView;
      }
    },

    _setDisabledFilters: function (checkItems) {
      var unselectedItems = this.$el.find("input:not(:checked)"),
        headerCount = checkItems;

      if (checkItems < 5) {
        // Trigger change to inform the facet item view,
        // that the look of the checkbox should change.
        unselectedItems.prop('disabled', false).trigger('change');
        unselectedItems.parent().parent().removeClass('binf-disabled');
      }
      else {
        unselectedItems.prop('disabled', true).trigger('change');
        unselectedItems.parent().parent().addClass('binf-disabled');
      }

      this.ui.selectCount.text(headerCount);
    },

    _setMoreLabel: function (showAll) {
      var moreItems = this.$el.find('.csui-facet-item.more');
      if ( this.ui.facetMoreIcon[0]){
      if (showAll) {
        moreItems.removeClass('binf-hidden');
        this.ui.facetMoreIcon[0].className = 'cs-icon icon-expandArrowUp';
        this.ui.facetMoreText.text(lang.showLess);
      }
      else {
        moreItems.addClass('binf-hidden');
        this.ui.facetMoreIcon[0].className = 'cs-icon icon-expandArrowDown';
        this.ui.facetMoreText.text(lang.showMore);
      }
      }
      this.trigger('facet:size:change');
    },

    _getFilterArray: function () {
      var filters = [];
      _.each(this.selectItems, function (item) {
        if (item) {
          filters.push({
            id: item.model.get('value'),
            topicName: item.model.get('name')
          });
        }
      });
      return filters;
    }

  });
  FacetView.version = '1.0';


  _.extend(FacetView.prototype, KeyEventNavigation);
  return FacetView;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel.key.navigation',['csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var KeyEventNavigation = {

    currentlyFocusedElement: function () {
      //change facet group items back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      var focusables = this.$('.cs-list-group .csui-facet[tabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
      }
      return this.getActiveChild();
    },
    onSetNextChildFocus: function(childView){
      this.activeChildIndex = childView.getIndex();
    },
    accActivateTabableRegion: function () {
      $(document).unbind('mousedown', this._onRemoveKeyboardFocus);
      $(document).bind('mousedown', this._onRemoveKeyboardFocus);

    },

    _removeKeyboardFocus: function () {
      this.$el.find('.csui-focus').removeClass('csui-focus');
      $(document).unbind('mousedown', this._onRemoveKeyboardFocus);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode;
      var retVal = false;

      switch (keyCode) {
        case 38:
        case 33:
          var prevChild = this._getPrevActiveChild();
          prevChild.focus();
          break;
        //down arrow, page down
        case 40:
        case 34:
          var nextChild = this._getNextActiveChild();
          nextChild.focus();
          break;
        default:
          return true;
      }
      return retVal;
    },

    resetFacetFocus: function(childView){

        childView.$el.focus();
    },



    getActiveChild: function () {
      // FIXMWE: How is it possible, that $childViewContainer is undefined,
      // but somebody called this method?
      if (!this.$childViewContainer) {
        return $();
      }
      if (!this.activeChild){
      var childViewContainer = this.$childViewContainer[0];
        if (childViewContainer && childViewContainer.childNodes[0]) {
        this.activeChild = $(childViewContainer.childNodes[0]);
        this.activeChildIndex = 0;
      }


      }
      return this.activeChild;
    },

    _getNextActiveChild: function(){
      var childNodes = this.$childViewContainer[0].childNodes;
      if(childNodes.length - 1 > this.activeChildIndex){
        this.activeChildIndex++;
      }
      else{
        this.activeChildIndex = 0;
      }

      return $(childNodes[this.activeChildIndex]);
    },

    _getPrevActiveChild: function(){
      var childNodes = this.$childViewContainer[0].childNodes;
      if(this.activeChildIndex > 0){
        this.activeChildIndex--;
      }
      else {
        this.activeChildIndex = childNodes.length - 1;
      }

      return $(childNodes[this.activeChildIndex]);
    }


  };

  return KeyEventNavigation;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"cs-header binf-panel-heading\">\r\n  <span class=\"cs-title\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</span>\r\n</div>\r\n\r\n<!--<div class=\"csui-horizontal-separator\"></div>-->\r\n<div class=\"cs-content\">\r\n  <div class=\"cs-list-group\"></div>\r\n</div>\r\n\r\n<!--Need one shadow strip over the header and one over cs-content. The reason why one over the entire\r\n    simple list will not work, is because cs-content has a z-index of 5 with a scroll index of 8. If\r\n    we had one shadow strip with an index higher than cs-content, the scroll-bar will not show.-->\r\n<div class=\"csui-right-shadow\"></div>\r\n\r\n";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_facet.panel_impl_facet.panel', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/facet.panel.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/models/facets', 'csui/models/facettopics',
  'csui/controls/list/simplelist.view',
  'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet/facet.view',
  'csui/behaviors/collection.state/collection.state.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel.key.navigation',
  'csui/controls/progressblocker/blocker',
  'hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel',
  'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/nls/lang',
  'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/impl/facet.panel'
], function (_, $, Backbone, FacetCollection, FacetTopicCollection,
    SimpleListView, FacetView, CollectionStateBehavior,
    TabableRegionBehavior, KeyEventNavigation, BlockingView, template, lang) {
  'use strict';

  var FacetPanelView = SimpleListView.extend({

    template: template,

    className: 'cs-simplelist csui-facet-panel',

    behaviors: {

      CollectionState: {
        behaviorClass: CollectionStateBehavior,
        stateMessages: function () {
          return {
            empty: _.isEmpty(this.collection.filters) ?
                   lang.emptyFacetMessage :
                   lang.emptyFilteredFacetMessage,
            loading: lang.loadingFacetMessage,
            failed: lang.failedFacetMessage
          };
        }
      },

      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }

    },

    childView: FacetView,

    childViewOptions: function () {
      return {enableCheckBoxes: this.options.enableCheckBoxes};
    },

    childEvents: {
      'apply:filter': 'applyFilter',
      'activate:facet': 'setActiveFacet',
      'facet:size:change': '_updateScrollbar',
      'escape:focus': 'resetFacetFocus'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    onAddChild: function (childView) {
      var $child = childView.$el,
          self = this;
      //Hide all children with index greater than the set number of items to show from server
      if (childView.getIndex() === (this.collection.length - 1)) {
        $child.css('border-bottom', '0px');
      }
      $child.on('focus', function () {
        self.onSetNextChildFocus(childView);
      });
    },

    constructor: function FacetPanelView(options) {
      SimpleListView.prototype.constructor.apply(this, arguments);

      this.options.data.title = lang.facetTitle;
      //This function is used in the keyevent.navigation to remove focus from a facet group once focus
      //falls outside the Facet Filter. Within keyevent.navigation 'onRemoveKeyboardFocus' is bound to the
      //browser Documents 'mousedown' event at the time of Tab entry.
      this._onRemoveKeyboardFocus = _.bind(this._removeKeyboardFocus, this);
      if (this.options.blockingParentView) {
        BlockingView.delegate(this, this.options.blockingParentView);
      } else {
        BlockingView.imbue({
          parent: this,
          local: this.options.blockingLocal
        });
      }
    },

    isTabable: function () {
      return !this.$el.parent().hasClass('binf-hidden');
    },

    onRenderCollection: function () {
      this.trigger('refresh:tabindexes');
    },

    onBeforeDestroy: function () {
      $(document).unbind('mousedown', this._onRemoveKeyboardFocus);
    },

    applyFilter: function (facet) {
      this.trigger('apply:filter', facet.newFilter);
    },

    //Set active facet and disable all others.
    setActiveFacet: function (facet) {
      if (facet.selectItems.length > 0) {
        this.children.each(function (view) {
          if (view.getIndex() !== facet.getIndex()) {
            view.$el.find('.csui-facet-content').addClass('facet-disabled');
          }
        });
      }
      else {
        this.$el.find('.csui-facet-content').removeClass('facet-disabled');
      }
    },

    _updateScrollbar: function () {
      this.triggerMethod('update:scrollbar', this);
    }

  });

  _.extend(FacetPanelView.prototype, KeyEventNavigation);
  return FacetPanelView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanded',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"visual-data-expanded-view-wrapper\">\r\n    <div class=\"csui-facet-table-container\">\r\n        <div id=\"facetview\"></div>\r\n        <!--outer div is needed in order to float table contents right to accommodate  facets-->\r\n        <div id=\"outertablecontainer\" class=\"reduce-for-facets\">\r\n            <!--inner div is needed in order to have tableview sized to remaining height of container-->\r\n            <div id=\"innertablecontainer\">\r\n                <div class=\"facetbarview\"></div>\r\n                <div class=\"visual-data-controls-parent\"></div>\r\n                <div class=\"visual-data-visualization\"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_visual.data.expanded', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanded',[],function(){});
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.expanded.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.bar/facet.bar.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/facet.panel/facet.panel.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.overlay.view',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',
    'hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanded',
    'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanded'
], function (_, $, Backbone, Marionette, FacetBarView, FacetPanelView, VisualDataControls, lang, template) {

    var VisualDataExpandedView = Marionette.LayoutView.extend({

        className: 'expanded-visualization-container',

        template: template,

        regions: {
            chicklets: '.facetbarview',
            facetRegion: '#facetview',
            visualizationControls: '.visual-data-controls-parent', // these are the same setting controls as used in the overlay in tile view, but shown differently
            visualization: '.visual-data-visualization'
        },

        constructor: function VisualDataExpandedView(options) {
            var filters;
            Marionette.LayoutView.prototype.constructor.apply(this, arguments);

            this.contentView = options.data.expandedContentView; //FIXME maybe some error checking here
            this.facetFilters = this.contentView.collection.facetFilters;
            filters = this.contentView.collection.getFilters();
            // If we have default filters passed in with the widget options set them here
            if ((this.facetFilters.filters.length === 0) && (filters.length > 0)) {
                this.facetFilters.filters = this.contentView.collection.mapFilterData(filters);
            }
        },

        callBackAlreadyHit: false,

        onDomRefresh: function() {

            if (this.callBackAlreadyHit) {
                this._renderFacetBar();
                this._renderFacetPanel();
                this._renderExpandedControls();
                this._renderChart();
            }
            this.callBackAlreadyHit = true;

        },

        _clearFilters: function(){
            this.facetFilters.clearFilters();
            this.contentView.collection.clearFilters();
        },

        _addToFacetFilter: function(filter){

            this.facetFilters.addFilter(filter);
            this.contentView.collection.addFilter(filter);

            // Render the facet bar
            this._renderFacetBar();
            // Update the controls so the user can see the Active Column has changed
            this._renderExpandedControls();
            // Update the Facet Panel
            this._renderFacetPanel();
        },

        _renderChart: function(){
            this.getRegion('visualization').show(this.contentView);
            this.contentView.resetAndRender();
        },

        _renderFacetBar: function(){
                this.facetBarView = new FacetBarView({
                    collection: this.facetFilters
                });

                this.listenTo(this.facetBarView, 'remove:filter', this._removeFacetFilter, this)
                    .listenTo(this.facetBarView, 'remove:all', this._removeAll, this)
                    .listenTo(this.contentView, 'apply:filter', this._addToFacetFilter, this);

                if (this.facetFilters.filters.length > 0){
                    this.getRegion('chicklets').show(this.facetBarView);
                }
        },

        _renderFacetPanel: function(){

            this.getRegion('facetRegion').empty();
            this._setFacetView();
            this.getRegion('facetRegion').show(this.facetView);

         },

        _setFacetView: function () {
            this.facetView = new FacetPanelView({
                collection: this.facetFilters,
                enableCheckBoxes: true,
                blockingLocal: true
            });

            this.listenTo(this.facetView, 'apply:filter', this._addToFacetFilter);
        },

        _renderExpandedControls: function(){
            this.expandedControls = new VisualDataControls({
                overlayModel: this.contentView.collection.overlayModel
            });
            this.getRegion('visualizationControls').show(this.expandedControls);
        },

        _removeFacetFilter: function (filter) {
          var facetName = this.contentView.collection.getActiveColumnByFormattedName(this.facetFilters.filters[filter.facetIndex].facetName),
              valueToRemove = this.facetFilters.filters[filter.facetIndex].values[filter.filterIndex].id,
              newFacetFilters = this.facetFilters.removeFilter(filter.facetIndex, filter.filterIndex);

            // We need to clear the facets out if there are no values after this chicklet has been removed.
            if (newFacetFilters.length === 0){
                this.contentView.collection.clearFilters(facetName, valueToRemove);
                this.getRegion('chicklets').empty();
            } else {
                // Sync the changes with the filtered count filters
                this.contentView.collection.updateFilters(facetName, valueToRemove);
            }

            // Update the controls so the user can see the Active Column has changed
            this._renderExpandedControls();
        },

        _removeAll: function () {
            this._clearFilters();
            this.getRegion('chicklets').empty();
            // Update the controls so the user can see the Active Column has changed
            this._renderExpandedControls();
        }
    });

    return VisualDataExpandedView;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.bar.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/d3', // 3rd party libraries
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.content.view',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang'	
], function (_, $, d3, VisualDataContentView, lang) {

    var VisualDataBarContentView = VisualDataContentView.extend({

        constructor: function VisualDataBarContentView(options) {

            // Call the parent constructor to ensure the object is built with all the inherited features.
            VisualDataContentView.prototype.constructor.apply(this, arguments);
        },

        visType: 'bar',

        defaults: {
            marginTop: 20,
            marginRight: 20,
            marginBottom: 100,
            marginLeft: 80,
            groupAfter: 15
        },

        appendVisElements: function () {
            this.visElement = this.visElement.append('g')
                .attr('transform', 'translate(' + this.marginLeft() + ',' + this.marginTop() + ')')
                .attr('class', 'bar-chart');
        },

        update: function () {
            var contentView = this,
                visElement = contentView.visElement,
                chartData = contentView.collection.models,
                sum = chartData.reduce(function (memo, value) {
                    return memo + value.get('value');
                }, 0),
                width = this.width(),
                height = this.height(),
                colors = d3.schemeCategory20,
                color = d3.scaleOrdinal(colors),
                colorOpacity = 0.9;

            var x = d3.scaleBand()
                    .range([0, width])
                    .round(true)
                    .padding(0.1),
                y = d3.scaleLinear(),
                extent = d3.extent(chartData.map(function (d) {
                    return d.get('value');
                })),
                xAxis = d3.axisBottom(x).tickFormat(contentView.shortenText),
                yAxis = d3.axisLeft(y).tickFormat(_.bind(contentView.formatCount, contentView));

            // generally the yaxis should start from 0, unless it has negative values
            extent = (extent[0] > 0) ? [0, extent[1]] : extent;

            y.domain(extent)
                .range([height, 0])
                .nice(); // extend range to nearest nice value

            function barLabel(d) {
                if (contentView.collection.overlayModel.get('view_value_as_percentage')) {
                    return ((d.get('value') / sum) * 100).toFixed(1) + '%'; // percentage of whole
                }
                else {
                    return contentView.formatCount(d.get('value'));
                }
            }

            function Y0() {
                return y(0);
            }

            function Y(d) {
                return y(d.get('value'));
            }

            // Scale the range of the data in the domains
            x.domain(chartData.map(function (d) {
                return (contentView.collection.grouped_on_server) ? d.get('key_formatted') : d.get('key');
            }));
            //y.domain([0, d3.max(chartData, function(d) { return Math.ceil(d.get('value')/10)*10; })]);

            // bars
            var bars = visElement.selectAll('.bar')
                .data(chartData)
                .enter().append('rect')
                .attr('class', function () {
                    var myClasses = 'bar';
                    return myClasses;
                })
                .attr('fill-opacity', colorOpacity)
                .style('fill', function (d, i) {
                    return color(i);
                })
                .style('stroke', function (d, i) {
                    return color(i);
                })
                .attr('x', function (d) {
                   return (contentView.collection.grouped_on_server) ? x(d.get('key_formatted')) : x(d.get('key'));
                })
                .attr('y', function (d) {
                    //return y(d.get('value'));
                    return d.get('value') < 0 ? Y0() : Y(d);
                })
                .attr('width', x.bandwidth())
                .attr('height', function (d) {
                    return Math.abs(Y(d) - Y0());
                });

            // labels on bars
            var barLabels = visElement.append('g')
                .attr('class', 'chart-labels')
                .selectAll('text')
                .data(chartData)
                .enter();

            barLabels
                .append('text')
                .style('text-anchor', 'middle')
                .text(barLabel)
                .attr('class', function() {
                    // only show labels if they can fit within bar
                    return (this.getBoundingClientRect().width <= x.bandwidth()) ? 'chart-label' : 'chart-label hidden';
                })
                .attr('x', function (d) {
                    return (contentView.collection.grouped_on_server) ? x(d.get('key_formatted')) + (x.bandwidth() / 2) : x(d.get('key')) + (x.bandwidth() / 2);
                })
                .attr('y', function (d) {
                    var offset = Math.abs(height - Y(d)),
                        zeroline = Y0() - Y(d),
                        labelOffset = 0;

                    if (contentView.checkSign(d.get('value')) === -1) {
                        // negative values - show value just above zero line.
                        if (zeroline < -24) {
                            labelOffset = -6;
                            d3.select(this).classed('outside', false);
                        }
                        else {
                            labelOffset = 16;
                            d3.select(this).classed('outside', true);
                        }
                        return (height + labelOffset - offset);
                    }
                    else {
                        if (zeroline > 24) {
                            labelOffset = 16;
                            d3.select(this).classed('outside', false);
                        }
                        else {
                            labelOffset = -6;
                            d3.select(this).classed('outside', true);
                        }
                        return (height + labelOffset - offset);
                    }

                });

            var rotateTicks = false; // set a flag so we can rotate ALL tick labels, rather than have a mix of some rotated and others not, which looks messy.
            // x axis
            visElement.append('g')
                .attr('class', 'x axis')
                .attr('transform', 'translate(0,' + height + ')')
                .call(xAxis)
                .selectAll('text')
                .style('text-anchor', 'middle')
                .attr('dy', '6')
                .attr('class',function() {
                    if (this.getBoundingClientRect().width >= x.bandwidth()) {
                        // rotates text if it's wider than width of bar
                        rotateTicks = true;
                    }
                    return null;
                });

            if (rotateTicks) {
                // second pass to rotate tick labels if the flag was set
                visElement.select('.x.axis')
                    .selectAll('text')
                    .attr('transform','rotate(-30)')
                    .style('text-anchor', 'end');
            }

            // zero line
            visElement.append('g')
                .attr('class', 'x axis zero')
                .attr("transform", "translate(0," + Y0() + ")")
                .call(xAxis.tickFormat('').tickSize(0));

            // y axis
            visElement.append('g')
                .call(yAxis)
                .attr('class', 'y axis');

            // gridlines
            visElement.append('g')
                .call(yAxis.tickFormat('').tickSize(-width))
                .selectAll('line')
                .attr('class', 'gridline');

            visElement.append('text')
                .attr('class', 'y-label')
                .text(lang.totalCount)
                .attr('transform', 'rotate(-90)')
                .attr('y', -this.marginLeft() + 15)
                .attr('x', -(height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle');

            visElement.append('text') // x-axis label
                .attr('class', 'x-label')
                .text(this.model.get('active_column_formatted'))
                .attr('y', height + this.marginBottom() - 15)
                .attr('x', (width / 2))
                .attr('dx', '1em')
                .style('text-anchor', 'middle');

            visElement.append('text')
                .attr('class', 'total')
                .attr('text-anchor', 'left')
                .attr('alignment-baseline', 'baseline')
                .attr('y', height + this.marginBottom() - 15)
                .attr('x', 0 - this.marginLeft() + 20)
                .text(lang.total + ': ' + contentView.formatCount(sum));

        }

    });

    return VisualDataBarContentView;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.pie.view',[
    'csui/lib/underscore', 'csui/lib/d3', // 3rd party libraries
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.content.view',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang'
], function (_, d3, VisualDataContentView, lang) {

    var VisualDataPieContentView = VisualDataContentView.extend({

        constructor: function VisualDataPieContentView(options) {

            // Call the parent constructor to ensure the object is built with all the inherited features.
            VisualDataContentView.prototype.constructor.apply(this, arguments);
        },

        defaults: {
            marginTop: 40,
            marginRight: 30,
            marginBottom: 40,
            marginLeft: 30,
            groupAfter: 5
        },

        visType: 'pie',

        appendVisElements: function () {
            var minPadding = 40; // minimum padding between chart and legend when widget width is reduced

            this.visElement.append('g')
                .attr('transform', 'translate(' + this.marginLeft() + ',' + this.marginTop() + ')')
                .attr('class', 'vis-wrapper');

            this.visElement.select('.vis-wrapper')
                .append('g')
                .attr('class', 'pie-chart')
                .attr('transform', 'translate(' + this.width() / 3 + ',' + this.height() / 2 + ')'); // center at 1/3

            this.visElement.select('.vis-wrapper')
                .append('g')
                .attr('class', 'pie-legend-container')
                .attr('height', this.height())
                .attr('transform', 'translate(' + ((this.width() / 3 ) * 2 + minPadding) + ',' + this.height() / 2 + ')'); // center at 2/3 + padding
        },

        update: function () {

            var contentView = this,
                visElement = contentView.visElement,
                colors = d3.schemeCategory20,
                color = d3.scaleOrdinal(colors),
                chartData = contentView.collection.models,
                sum = chartData.reduce(function (memo, value) {
                    return memo + value.get('value');
                }, 0),
                //width = this.$el[0].clientWidth - this.marginLeft() - this.marginRight(), // this.width() or this.height() does not work in expanded view
                //height = this.$el[0].clientHeight - this.marginTop() - this.marginBottom(),
                width = this.width(),
                height = this.height(),
                radius = Math.min(width / 3, height / 2), // 1/3 of width or half of height
                colorOpacity = 0.9;

            function pieLabel(d, i) {
                var actual = chartData[i].get('value'),
                    percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100).toFixed(1),
                    arcSize = d.endAngle - d.startAngle, // in radians
                    minRadius = 100, // minimum radius for labels to appear
                    minArcLength = 44, // ratio of radius to arcSize to determine if label will appear on this arc (arcSize / minArcSizeRatio)
                    label = (contentView.collection.overlayModel.get('view_value_as_percentage')) ? percentage + ' %' : contentView.formatCount(actual);

                label = ((radius * arcSize >= minArcLength) && (radius >= minRadius)) ? label : '';
                return label;
            }

            function explode(d, i, offset) {
                var radial = (d.startAngle + d.endAngle) / 2,
                    offsetX = Math.sin(radial) * offset,
                    offsetY = -Math.cos(radial) * offset;
                return 'translate(' + offsetX + ',' + offsetY + ')';
            }

            function extractSlice(d, i) {
                visElement.selectAll('.arc path,.pie-legend rect,.pie-legend text')
                    .filter(function (d2, i2) {
                        return (d2.index !== d.index);
                    });
                return explode(d, i, 15);
            }

            function replaceSlice(d, i) {
                visElement.selectAll('.arc path,.pie-legend rect').attr('fill-opacity', colorOpacity);
                return explode(d, i, 0);
            }

            function calculateLegendHeight() {
                // returns a dynamic height for each legend swatch, according to how many swatches are needed
                var n = chartData.length || 1,
                    minSwatchSize = 14, // smallest legible size (font is half this size)
                    maxSwatchSize = 24,
                    swatchSize;

                swatchSize = ((height *2) / n) / 2;
                swatchSize = (swatchSize < minSwatchSize) ? minSwatchSize : swatchSize;
                swatchSize = (swatchSize > maxSwatchSize) ? maxSwatchSize : swatchSize;

                return swatchSize;
            }

            var arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);

            var labelArc = d3.arc() // needed to position labels near outer edge of pie. Not required for donut
                .innerRadius(radius - 10)
                .outerRadius(radius + 30);

            var pie = d3.pie()
                .sort(null)
                .value(function (d) {
                    return d.get('value');
                });

            var segments = visElement.select('.pie-chart').selectAll('.arc')
                .data(pie(chartData))
                .enter().append('g')
                .attr('class', function () {
                    var myClasses = 'arc';
                    return myClasses;
                });

            segments.append('path')
                .attr('d', arc)
                .attr('fill-opacity', colorOpacity)
                .style('fill', function (d, i) {
                    return color(i);
                });
            /*
             // Pie animation
             .transition()
             .duration(2000)
             .attrTween('d', function (b) {
             var i = d3.interpolate({startAngle: 0, endAngle: 0}, b);
             return function(t) { return arc(i(t)); };
             });
             */
            // FIXME: using the enter() method on a selection only applies to data elements that are NEW. If the elements already exist in the SVG DOM, they need to be updated too. This becomes apparent when dynamically changing data

            // Add the labels to the pie chart
            // do the d3 selection again, to ensure all labels are overlaid on segments

            segments.append('text')
                .attr('class', 'chart-label outside')
                .attr('transform', function (d) {
                    return 'translate(' + labelArc.centroid(d) + ')';
                })
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('font-size', 14)
                .text(pieLabel);

            // populate the legend container
            var pieLegendContainer = visElement.select('.pie-legend-container');

            var legends = pieLegendContainer.selectAll('.pie-legend')
                .data(pie(chartData))
                .enter().append('g')
                .attr('class', 'pie-legend')
                .on('mouseover', function (d) {
                    visElement.selectAll('.arc')
                        .filter(function (d2, i2) {
                            return (d2.index === d.index);
                        })
                        .attr('transform', extractSlice);
                })
                .on('mouseout', function (d) {
                    visElement.selectAll('.arc')
                        .filter(function (d2, i2) {
                            return (d2.index === d.index);
                        })
                        .attr('transform', replaceSlice);
                });

            var legendHeight = calculateLegendHeight();

            pieLegendContainer.style('font-size',(legendHeight / 2) + 'px');

            // Add the legend to the pie chart
            legends.append('text')
                .attr('class', 'pie-legend-text')
                .attr('dy','1.2em') // individual offset to center text vertically
                .attr('transform', function (d, i) {
                    var offset = legendHeight * chartData.length / 2,
                        x = legendHeight + 10, // swatch + 10px margin
                        y = (i * legendHeight) - offset;
                    return 'translate(' + x + ',' + y + ')';
                })
                .text(function (d, i) {
                    return contentView.collection.grouped_on_server ? d.data.get('key_formatted') : d.data.get('key');
                });

            legends.append('rect')
                .attr('class', 'pie-legend-swatch')
                .attr('width','2em')
                .attr('height', legendHeight - 4) // 4px padding
                .attr('fill-opacity', colorOpacity)
                .attr('transform', function (d, i) {
                    var offset = legendHeight * chartData.length / 2,
                        x = 0,
                        y = (i * legendHeight) - offset;
                    return 'translate(' + x + ',' + y + ')';
                })
                .attr('fill', function (d, i) {
                    return color(i);
                });

            // FIXME: problem here is that we can't get the dimensions of the BBox until the text is rendered, but we want the dimensions to govern how the text is truncated...
            //console.log(visElement.select('.pie-legend-container').node().getBBox());

            var pieTotal = visElement.select('.vis-wrapper')
                .append('g')
                .attr('class', 'pie-total-container');

            pieTotal.append('text')
                .attr('class', 'total')
                .attr('text-anchor', 'left')
                .attr('alignment-baseline', 'baseline')
                .attr('y', height + this.marginBottom() - 15)
                .attr('x', 0 - this.marginLeft() + 20)
                .text(lang.total + ': ' + contentView.formatCount(sum));

            pieLegendContainer.append('text')
                .attr('class', 'pie-legend-active-column')
                .attr('transform', 'rotate(-90)')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('y', 0)
                .attr('x', 0)
                .attr('dy', -20)
                .text(this.model.get('active_column_formatted'));

        }

    });

    return VisualDataPieContentView;

});

csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.donut.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/d3', // 3rd party libraries
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.content.view',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang'
], function (_, $, d3, VisualDataContentView, lang) {

    var VisualDataDonutContentView = VisualDataContentView.extend({

        constructor: function VisualDataPieContentView(options) {

            // Call the parent constructor to ensure the object is built with all the inherited features.
            VisualDataContentView.prototype.constructor.apply(this, arguments);
        },

        defaults: {
            marginTop: 30,
            marginRight: 30,
            marginBottom: 30,
            marginLeft: 30,
            groupAfter: 5
        },

        visType: 'donut',

        appendVisElements: function () {
            var minPadding = 40; // minimum padding between chart and legend when widget width is reduced

            this.visElement.append('g')
                .attr('transform', 'translate(' + this.marginLeft() + ',' + this.marginTop() + ')')
                .attr('class', 'vis-wrapper');

            this.visElement.select('.vis-wrapper')
                .append('g')
                .attr('class', 'pie-chart')
                .attr('transform', 'translate(' + this.width() / 3 + ',' + this.height() / 2 + ')'); // center at 1/3

            this.visElement.select('.vis-wrapper')
                .append('g')
                .attr('class', 'pie-legend-container')
                .attr('transform', 'translate(' + ((this.width() / 3 ) * 2 + minPadding) + ',' + this.height() / 2 + ')'); // center at 2/3 + padding
        },

        update: function () {

            var contentView = this,
                visElement = contentView.visElement,
                colors = d3.schemeCategory20,
                color = d3.scaleOrdinal(colors),
                chartData = contentView.collection.models,
                sum = chartData.reduce(function (memo, value) {
                    return memo + value.get('value');
                }, 0),
                donutWidth = 1.5, // thickness of donut ring
                width = this.$el[0].clientWidth - this.marginLeft() - this.marginRight(), // this.width() or this.height() does not work in expanded view
                height = this.$el[0].clientHeight - this.marginTop() - this.marginBottom(),
                radius = Math.min(width / 3, height / 2), // 1/3 of width or half of height
                colorOpacity = 0.9;

            function pieLabel(d, i) {
                var actual = chartData[i].get('value'),
                    percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100).toFixed(1),
                    arcSize = d.endAngle - d.startAngle, // in radians
                    minRadius = 100, // minimum radius for labels to appear
                    minArcLength = 44, // ratio of radius to arcSize to determine if label will appear on this arc (arcSize / minArcSizeRatio)
                    label = (contentView.collection.overlayModel.get('view_value_as_percentage')) ? percentage + ' %' : contentView.formatCount(actual);

                label = ((radius * arcSize >= minArcLength) && (radius >= minRadius)) ? label : '';
                return label;
            }

            function explode(d, i, offset) {
                var radial = (d.startAngle + d.endAngle) / 2,
                    offsetX = Math.sin(radial) * offset,
                    offsetY = -Math.cos(radial) * offset;
                return 'translate(' + offsetX + ',' + offsetY + ')';
            }

            function extractSlice(d, i) {
                visElement.selectAll('.arc path,.pie-legend rect,.pie-legend text')
                    .filter(function (d2, i2) {
                        return (d2.index !== d.index);
                    });
                return explode(d, i, 15);
            }

            function replaceSlice(d, i) {
                visElement.selectAll('.arc path,.pie-legend rect').attr('fill-opacity', colorOpacity);
                return explode(d, i, 0);
            }

            function calculateLegendHeight() {
                // returns a dynamic height for each legend swatch, according to how many swatches are needed
                var n = chartData.length || 1,
                    minSwatchSize = 14, // smallest legible size (font is half this size)
                    maxSwatchSize = 24,
                    swatchSize;

                swatchSize = ((height *2) / n) / 2;
                swatchSize = (swatchSize < minSwatchSize) ? minSwatchSize : swatchSize;
                swatchSize = (swatchSize > maxSwatchSize) ? maxSwatchSize : swatchSize;

                return swatchSize;
            }

            function fontSizeForTotal(innerDiscSize) {
                var stringLength = (contentView.formatCount(sum).length),
                    fontRatios = [1.4, 1.6, 1.8, 2, 2.2, 2.4, 2.6, 2.8], // a hash is faster than Math ;-)
                    fontRatio = (stringLength <= fontRatios.length) ? fontRatios[stringLength - 1] : 12; // 12 is smallest size possible
                return innerDiscSize / fontRatio;
            }

            var arc = d3.arc()
                .innerRadius(radius / donutWidth)
                .outerRadius(radius);

            var pie = d3.pie()
                .sort(null)
                .value(function (d) {
                    return d.get('value');
                });

            var segments = visElement.select('.pie-chart').selectAll('.arc')
                .data(pie(chartData))
                .enter().append('g')
                .attr('class', function () {
                    var myClasses = 'arc';
                    return myClasses;
                });

            segments.append('path')
                .attr('d', arc)
                .attr('fill-opacity', colorOpacity)
                .style('fill', function (d, i) {
                    return color(i);
                });
            /*
             // Pie animation
             .transition()
             .duration(2000)
             .attrTween('d', function (b) {
             var i = d3.interpolate({startAngle: 0, endAngle: 0}, b);
             return function(t) { return arc(i(t)); };
             });
             */
            // FIXME: using the enter() method on a selection only applies to data elements that are NEW. If the elements already exist in the SVG DOM, they need to be updated too. This becomes apparent when dynamically changing data

            // Add the labels to the pie chart

            segments.append('text')
                .attr('class', 'chart-label')
                .attr('transform', function (d) {
                    return 'translate(' + arc.centroid(d) + ')';
                })
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('font-size', 14)
                .text(pieLabel);

            // populate the legend container
            var pieLegendContainer = visElement.select('.pie-legend-container');

            var legends = pieLegendContainer.selectAll('.pie-legend')
                .data(pie(chartData))
                .enter().append('g')
                .attr('class', 'pie-legend')
                .on('mouseover', function (d) {
                    visElement.selectAll('.arc')
                        .filter(function (d2, i2) {
                            return (d2.index === d.index);
                        })
                        .attr('transform', extractSlice);
                })
                .on('mouseout', function (d) {
                    visElement.selectAll('.arc')
                        .filter(function (d2, i2) {
                            return (d2.index === d.index);
                        })
                        .attr('transform', replaceSlice);
                });

            var legendHeight = calculateLegendHeight();

            pieLegendContainer.style('font-size',(legendHeight / 2) + 'px');

            // Add the legend to the pie chart
            legends.append('text')
                .attr('class', 'pie-legend-text')
                .attr('dy','1.2em') // individual offset to center text vertically
                .attr('transform', function (d, i) {
                    var offset = legendHeight * chartData.length / 2,
                        x = legendHeight + 10, // swatch + 10px margin
                        y = (i * legendHeight) - offset;
                    return 'translate(' + x + ',' + y + ')';
                })
                .text(function (d, i) {
                    return contentView.collection.grouped_on_server ? d.data.get('key_formatted') : d.data.get('key');
                });

            legends.append('rect')
                .attr('class', 'pie-legend-swatch')
                .attr('width','2em')
                .attr('height', legendHeight - 4) // 4px padding
                .attr('fill-opacity', colorOpacity)
                .attr('transform', function (d, i) {
                    var offset = legendHeight * chartData.length / 2,
                        x = 0,
                        y = (i * legendHeight) - offset;
                    return 'translate(' + x + ',' + y + ')';
                })
                .attr('fill', function (d, i) {
                    return color(i);
                });

            var donutTotal = visElement.select('.pie-chart')
                .append('g')
                .attr('class', 'pie-total-container');

            var minFontSize = 10,
                valueFontSize = (fontSizeForTotal(radius / donutWidth) >= minFontSize) ? fontSizeForTotal(radius / donutWidth) : minFontSize,
                labelRatio = 2.3,
                valueOffsetRatio = 10,
                labelOffsetRatio = 1.5,
                innerDiscMargin = 10;

            donutTotal.append('g')
                .attr('class', 'pie-total-label-disc')
                .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', (radius / donutWidth) - innerDiscMargin);

            donutTotal.append('text')
                .attr('transform', 'translate(0,' + (-(valueFontSize / labelOffsetRatio)) + ')')
                .attr('class', 'pie-total-label')
                .attr('text-anchor', 'middle')
                .attr('font-size', valueFontSize / labelRatio)
                .text(function () {
                    // only show label if font is big enough
                    return (valueFontSize / labelRatio >= 8) ? lang.total : '';
                });

            donutTotal.append('text')
                .attr('class', 'total')
                .attr('transform', 'translate(0,' + (valueFontSize / valueOffsetRatio) + ')')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('font-size', valueFontSize) // pass in the inner disc radius to get the right font size
                .text(contentView.formatCount(sum));

            pieLegendContainer.append('text')
                .attr('class', 'pie-legend-active-column')
                .attr('transform', 'rotate(-90)')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('y', 0)
                .attr('x', 0)
                .attr('dy', -20)
                .text(this.model.get('active_column_formatted'));

        }

    });

    return VisualDataDonutContentView;

});


/* START_TEMPLATE */
csui.define('hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.tile',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"tile-type-icon\">\r\n            <span class=\"icon title-icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></span>\r\n        </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"tile-type-image "
    + this.escapeExpression(((helper = (helper = helpers.imageClass || (depth0 != null ? depth0.imageClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageClass","hash":{}}) : helper)))
    + "\">\r\n                <img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageUrl","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\">\r\n            </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "<!-- Note: the options button must be available even when there is no header. In the case of no header, it will be positioned absolute -->\r\n<div class=\"csui-favorite csui-acc-tab-region visual-data-btn-settings\">\r\n    <span class=\"binf-glyphicon binf-glyphicon-cog\" role=\"button\" tabindex=\"0\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.settings || (depth0 != null ? depth0.settings : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"settings","hash":{}}) : helper)))
    + "\"></span>\r\n</div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\r\n    <div class=\"tile-title\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\">\r\n        <h2 class=\"csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n    </div>\r\n\r\n    <div class=\"tile-controls\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\"></div>\r\n\r\n</div>\r\n\r\n<div class=\"tile-content\"></div>\r\n\r\n<div class=\"tile-footer\"></div>\r\n\r\n<div class=\"visual-data-overlay-clip\">\r\n    <div class=\"visual-data-overlay\">\r\n        <div class=\"visual-data-overlay-content binf-modal-dialog\">\r\n        <form class=\"csui-inlineform-group visual-data-settings-form\">\r\n            <div class=\"binf-modal-content\">\r\n                <div class=\"binf-modal-body\">\r\n                    <div class=\"visual-data-controls-parent\"></div>\r\n                </div>\r\n            </div>\r\n        </form>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.filterable : depth0),{"name":"if","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('webreports_widgets_visual.data.filtered.count_impl_controls_visualdata_impl_visual.data.tile', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!webreports/style/webreports',[],function(){});
// WebReports VisualData widget view. This renders a standard csui tile with HTML content returned from a WebReport.
csui.define('webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.view',[
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette','csui/lib/backbone', // 3rd party libraries
    'csui/controls/tile/tile.view',
    'csui/utils/contexts/factories/connector',
    'csui/utils/url',
    'csui/utils/base',
    'csui/dialogs/modal.alert/modal.alert',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.expanding.behavior',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.content.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.overlay.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.expanded.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.bar.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.pie.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.donut.view',
    'i18n!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/nls/visual.data.lang',
    'hbs!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data.tile',
    'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data',
    'css!webreports/style/webreports.css'
], function (_, $, Marionette, Backbone, TileView, ConnectorFactory, Url, base, ModalAlert, ExpandingBehavior, VisualDataContentView, VisualDataOverlay, VisualDataExpanded, VisualDataBarView, VisualDataPieView, VisualDataDonutView,  lang, template) {

      var VisualDataView = TileView.extend({

          contentView: VisualDataContentView,

          ui: {
              overlayClip: '.visual-data-overlay-clip',
              toggleSettings: '.visual-data-btn-settings span',
              overlay: '.visual-data-overlay'
          },

          constructor: function VisualDataView(options) {

              if (options.data && options.data.contentView){
                  this.contentView = options.data.contentView;
              }

              // Set the options for ContentView so the main content pane has the context when it renders.
              // These options are checked and loaded in the _renderContentView function of TileView
              // before show is called for the view.
              this.contentViewOptions = options;

              if (options.context){
                  this.connector = options.context.getObject(ConnectorFactory, options);
              }

            // Call the parent constructor to ensure the object is built with all the inherited features.
             TileView.prototype.constructor.apply(this, arguments);
          },

          behaviors: function () {
              var behaviors = {},
                  launchButtonConfig = this.options.data.launchButtonConfig ;

              this.launchable = (this.options.data.expandable && launchButtonConfig && launchButtonConfig.launchButtons && (launchButtonConfig.launchButtons.length > 0));

              if (this.options.data.expandable){
                  behaviors.Expanding = {
                      behaviorClass: ExpandingBehavior,
                      titleBarIcon: function () {
                          return this.options.data.titleBarIcon;
                      },
                      dialogTitle: function () {
                          var title = base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle);
                          return title;
                      },
                      dialogTitleIconRight: "icon-tileCollapse",
                      dialogClassName: 'webreports-visual-data',
                      expandedView: function (){
                          return VisualDataExpanded;
                      },
                      expandedViewOptions: function () {
                          var expandedOptions = this.options,
                              VisTypeView; // generic pointer to one of several different specific visualisation views

                          switch (this.options.data.type) {
                              case 'bar':
                                  VisTypeView = VisualDataBarView;
                                  break;
                              case 'pie':
                                  VisTypeView = VisualDataPieView;
                                  break;
                              case 'donut':
                                  VisTypeView = VisualDataDonutView;
                                  break;
                              default:
                                  return false;
                          }
                          if (this.launchable){
                              this.rowLimit = launchButtonConfig.rowLimit;
                              expandedOptions.data.buttons = _.map(launchButtonConfig.launchButtons, _.bind(function(button){
                                  return {
                                      "label": base.getClosestLocalizedString(button.launchButtonLabel, lang.launchReport),
                                      "toolTip": base.getClosestLocalizedString(button.launchButtonTooltip, lang.launchReportTooltip),
                                      "click" : _.bind(function(){
                                          if (this.checkRowLimit(this.contentView.collection.getTotalCount(), this.rowLimit)){
                                              this._launchReport(button.launchButtonID);
                                          } else {
                                              ModalAlert.showError(lang.tooManyRows + this.rowLimit);
                                          }
                                      }, this)
                                  };
                              },this));
                          }
                          expandedOptions.data.isExpanded = true;
                          expandedOptions.data.expandedContentView = new VisTypeView(this.contentView.options);

                          return expandedOptions;
                      }
                  };
              }

              return behaviors;
          },

          regions: function() {
              var regions = _.extend({
                  visualizationControls: '.visual-data-controls-parent'
              }, TileView.prototype.regions);
              return regions;
          },

          events: {
              'click @ui.toggleSettings': 'toggleSettings',
			  'keyup @ui.toggleSettings': 'toggleSettings'
          },

          checkRowLimit: function(numRows, userDefinedLimit){
              // Use the user-defined row limit to prevent users stressing the system.
              // If this is undefined use the default of 5000 rows.
              // If this is greater than the hard limit of 50000 then use the hard limit.
              var rowLimit,
                  defaultLimit = 5000,
                  hardLimit = 50000;

              if (!userDefinedLimit) {
                  rowLimit = defaultLimit;
              } else if (userDefinedLimit <= hardLimit){
                  rowLimit = userDefinedLimit;
              } else {
                  rowLimit = hardLimit;
              }

              this.rowLimit = rowLimit;

              return numRows <= rowLimit;
          },

          toggleSettings: function(event) {
			  
			  event.preventDefault();
              if(event.type === "click" || (event.type === "keyup" && (event.keyCode===13 || event.keyCode === 32) )) {
				  if (this.overlayVisible) {
					  $('.visual-data-overlay', this.$el).removeClass('visible');
					  this.overlayVisible = false;
				  } else {
					  var overlayView = new VisualDataOverlay({
						  overlayModel: this.contentView.collection.overlayModel
					  });

					  this.getRegion('visualizationControls').show(overlayView);
					  $('.visual-data-overlay', this.$el).addClass('visible');
					  this.overlayVisible = true;
				  }
			  }
          },

          template: template,

          templateHelpers: function () {

              var helpers = {
                  title: base.getClosestLocalizedString(this.options.data.title, lang.dialogTitle),
                  icon: this.options.data.titleBarIcon || 'title-webreports',
                  activeColumn: this.options.data.activeColumn || '',
                  filterable: this.options.data.filterable,
				  settings: lang.settings
              };

              // Check if the header is disabled using `header: false` in the options.
              if (this.options.data.header === true){
                  _.extend(helpers,{header:this.options.data.header});
              }

              return helpers;

          },

          // Dynamically builds up a form to POST to a classic WebReport with the current configuration
          _launchReport: function(webreportID){

              var input,
                  cgiUrl = new Url(this.connector.connection.url).getCgiScript(),
                  wrClassicForm = $('<form></form>'),
                  fcParms = this.contentView.collection.getFilteredCountParms(),
                  runReportFields = {
                      func: 'll',
                      objAction: 'RunReport',
                      objId: webreportID,
                      nexturl: location.href
                  },
                  formFields = _.extend(runReportFields, fcParms);

              formFields.total_count = this.contentView.collection.getTotalCount();

              wrClassicForm.attr("method", "POST")
                      .attr("action",cgiUrl)
                      .attr("target","_blank")
                      .attr("id", "launch-webreport-form");

              _.each(_.keys(formFields), function(parmName){
                  input = $("<input>")
                      .attr("type", "hidden")
                      .attr("name", parmName)
                      .val(formFields[parmName]);
                  wrClassicForm.append(input);
              });

              // Firefox and IE require that the form be added to the DOM before they will allow the form to be submitted.
              $('.binf-modal-footer').append(wrClassicForm);
              wrClassicForm.submit();
              // Removing form from DOM after submission to avoid multiple forms being appended to the footer if the users clicks the button more than once.
              $('#launch-webreport-form').remove();
          }
      });

    return VisualDataView;

});

csui.define('webreports/widgets/visual.data.filtered.count/visual.data.filtered.count.view',[
    'csui/lib/underscore',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visual.data.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.donut.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.bar.view',
    'webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/visualizations/visual.data.pie.view',
    'css!webreports/widgets/visual.data.filtered.count/impl/controls/visualdata/impl/visual.data'
], function (_, VisualDataView, DonutContentView, BarContentView, PieContentView) {

      var VisualDataFilteredCountView = VisualDataView.extend({

          constructor: function VisualDataFilteredCountView(options) {

              options.data.titleBarIcon = ( _.has(options.data, 'titleBarIcon')) ? 'title-icon '+ options.data.titleBarIcon : 'title-icon title-webreports';

              this.contentView = this._getContentView(options);
              // Set the options for ContentView so the main content pain has the context when it renders.
              // These options are checked and loaded in the _renderContentView function of TileView
              // before show is called for the view.
              this.contentViewOptions = options;

              // Call the parent constructor to ensure the object is built with all the inherited features.
              VisualDataView.prototype.constructor.apply(this, arguments);

          },
          _getContentView: function (options) {
              var contentView = BarContentView;
              var chartType;
              if (options && options.data && options.data.type){
                  chartType = options.data.type;
                  switch(chartType) {
                      case "donut":
                          contentView = DonutContentView;
                          break;
                      case "pie":
                          contentView = PieContentView;
                          break;
                      default:
                          contentView = BarContentView;
                  }
              }

              return contentView;
          }

      });

    return VisualDataFilteredCountView;

});


csui.define('json!webreports/widgets/visual.data.filtered.count/visual.data.filtered.count.manifest.json',{
    "$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
    "title": "{{widgetTitle}}",
    "description": "{{widgetDescription}}",
    "kind": "header",
    "supportedKinds": ["tile", "header"],
    "schema": {
        "type": "object",
        "properties": {
            "title": {
                "title": "{{tileTitle}}",
                "description": "{{tileDescription}}",
                "type": "object"
            },
            "type": {
                "title": "{{typeTitle}}",
                "description": "{{typeDescription}}",
                "type": "string",
                "enum": ["bar","donut","pie"],
                "default": "bar"
            },
            "id": {
                "title": "{{sourceTitle}}",
                "description": "{{sourceDescription}}",
                "type": "integer"
            },
            "activeColumn": {
                "title": "{{activeTitle}}",
                "description": "{{activeDescription}}",
                "type": "string"
            },
            "viewValueAsPercentage": {
                "title": "{{percentTitle}}",
                "description": "{{percentDescription}}",
                "type": "boolean",
                "enum": [
                    true,
                    false
                ],
                "default": false
            },
            "groupAfter": {
                "title": "{{groupTitle}}",
                "type": "integer",
                "description": "{{groupDescription}}",
                "enum": [-1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
                "default": -1
            },
            "sortBy": {
                "title": "{{sortTitle}}",
                "description": "{{sortDescription}}",
                "type": "string",
                "enum": ["ordinal","Count"],
                "default": "Count"
            },
            "sortOrder": {
                "title": "{{directionTitle}}",
                "description": "{{directionDescription}}",
                "type": "string",
                "enum": ["desc","asc"],
                "default": "desc"
            },
            "filterable": {
                "title": "{{optionsTitle}}",
                "description": "{{optionsDescription}}",
                "type": "boolean",
                "enum": [
                    true,
                    false
                ],
                "default": false
            },
            "expandable": {
                "title": "{{expandedTitle}}",
                "description": "{{expandedDescription}}",
                "type": "boolean",
                "enum": [
                    true,
                    false
                ],
                "default": false
            },
            "launchButtonConfig": {
                "type": "object",
                "title": "{{buttonTitle}}",
                "description": "{{buttonDescription}}",
                "properties": {
                    "rowLimit": {
                        "title": "{{maxTitle}}",
                        "description": "{{maxDescription}}",
                        "type": "integer"
                    },
                    "launchButtons": {
                        "type": "array",
                        "title": "{{customButtonTitle}}",
                        "description": "{{customButtonDescription}}",
                        "items": {
                            "type": "object",
                            "title": "{{addButtonTitle}}",
                            "description": "{{addButtonDescription}}",
                            "properties": {
                                "launchButtonID": {
                                    "title": "{{reportButtonTitle}}",
                                    "description": "{{reportButtonDescription}}",
                                    "type": "integer"
                                },
                                "launchButtonLabel": {
                                    "title": "{{labelButtonTitle}}",
                                    "description": "{{labelButtonDescription}}",
                                    "type": "object"
                                },
                                "launchButtonTooltip": {
                                    "title": "{{buttonToolTitle}}",
                                    "description": "{{buttonToolDescription}}",
                                    "type": "object"
                                }
                            }
                        }
                    }
                }
            },
            "parameters": {
                "type": "array",
                "title": "{{paramSourceTitle}}",
                "description": "{{paramSourceDescription}}",
                "items": {
                    "type": "object",
                    "title": "{{paramPairTitle}}",
                    "description": "{{paramPairDescription}}",
                    "properties": {
                        "name": {
                            "type": "string",
                            "title": "{{paramNameTitle}}",
                            "description": "{{paramNameDescription}}"
                        },
                        "value": {
                            "type": "string",
                            "title": "{{paramValueTitle}}",
                            "description": "{{paramValueDescription}}"
                        }
                    }
                }
            }
        },
        "required": ["activeColumn","id"]
    },    
    "options": {
        "fields": {
            "id": {
                "type": "otcs_node_picker",
                "type_control": {
                    "parameters": {
                        "select_types": [30303]
                    }
                }
            },
			"title": {
				"type": "otcs_multilingual_string"
			},
            "launchButtonConfig": {
                "fields": {
                    "launchButtons": {
                        "items": {
                            "fields": {
                                "launchButtonID": {
                                    "type": "otcs_node_picker",
                                    "type_control": {
                                        "parameters": {
                                            "select_types": [30303]
                                        }
                                    }
                                },
								"launchButtonLabel": {
									"type": "otcs_multilingual_string"
								},
								"launchButtonTooltip": {
									"type": "otcs_multilingual_string"
								}
                            }
                        }
                    }
                }
            },
            "type": {
                "type": "select",
                "optionLabels": ["{{optionsTypeBar}}", "{{optionsTypeDonut}}", "{{optionsTypePie}}"]
            },
            "groupAfter": {
                "type": "select",
                "optionLabels": ["{{optionsGroupAfterDefault}}","2","3","4","{{optionsPieDonutDefault}}","6","7","8","9","10","11","12","13","14","{{optionsBarDefault}}","16","17","18","19","20"]
            },
            "sortBy": {
                "type": "select",
                "optionLabels": ["{{optionsSortByActive}}", "{{optionsSortByCount}}"]
            },
            "sortOrder": {
                "type": "select",
                "optionLabels": ["{{optionsSortOrderDsc}}", "{{optionsSortOrderAsc}}"]
            }
        }
    }
});

csui.define('webreports/widgets/visual.data.filtered.count/impl/nls/visual.data.filtered.count.manifest',{
	// Always load the root bundle for the default locale (en-us)
	"root": true,
	// Do not load English locale bundle provided by the root bundle
	"en-us": false,
	"en": false
});

csui.define('webreports/widgets/visual.data.filtered.count/impl/nls/root/visual.data.filtered.count.manifest',{
    "widgetTitle": "Visual Count",
    "widgetDescription": "This widget visualizes the total count of values matching given criteria.",
    "tileTitle": "Title",
    "tileDescription": "Enter the title for the widget. This title appears in the Tile header.",
    "typeTitle": "Chart Type",
    "typeDescription": "Select the type of chart appropriate for your data.",
    "sourceTitle": "Source WebReport",
    "sourceDescription": "Browse to select the WebReport that retrieves the data that you want to visualize.",
    "activeTitle": "Active Column",
    "activeDescription": "Enter the name of the data source column that provides the matching values to be counted.",
    "optionsTitle": "Chart Options",
    "optionsDescription": "Choose whether end users have access to chart filtering options in the Tile view.",
    "expandedTitle": "Expanded View",
    "expandedDescription": "Choose whether end users have access to the Expanded view of the chart.",
    "percentTitle": "Values as Percentage",
    "percentDescription": "Choose whether to show the chart values as percentages of the total count or as the actual count.",
    "groupTitle": "Group After",
    "groupDescription": "Select the threshold for the number of discrete values whose total count will appear in the chart. Values above the threshold will be grouped as \'Other\' and the combined total will appear. The Chart Default is a threshold value appropriate to the chart type.",
    "sortTitle": "Sort By",
    "sortDescription": "Select whether to sort the chart by the value names in the Active Column or by the count of the values.",
    "directionTitle": "Sort Direction",
    "directionDescription": "Select whether to sort the chart in Ascending or Descending order.",
    "buttonTitle": "Button WebReports",
    "buttonDescription": "Configure the options for Button WebReports launched by Custom Buttons in the Expanded view",
    "maxTitle": "Maximum Items to Process",
    "maxDescription": "Enter the maximum number of data items to pass to the Button WebReport.",
    "customButtonTitle": "Custom Buttons",
    "customButtonDescription": "Set the properties for the Custom Button that appears in the Expanded View, then click the \'Add To Array\' button. Repeat as required to add multiple buttons.",
    "addButtonTitle": "Add Custom Buttons",
    "addButtonDescription": "Configure custom buttons that will appear in the Expanded view and which will launch Button Webreports.",
    "reportButtonTitle": "Button WebReport",
    "reportButtonDescription": "Browse to select the WebReport that will open when you click the button.",
    "labelButtonTitle": "Button Label",
    "labelButtonDescription": "Enter a custom label for the button.",
    "buttonToolTitle": "Button Tooltip",
    "buttonToolDescription": "Enter a tool tip for the button.",
    "paramSourceTitle": "Source Parameters",
    "paramSourceDescription": "Specify one or more Key/Value pairs of parameters to pass into the Source WebReport, as required.",
    "paramPairTitle": "Source Parameters",
    "paramPairDescription": "Specify one or more Key/Value pairs of parameters to pass into the Source WebReport, as required.",
    "paramNameTitle": "Parameter Name",
    "paramNameDescription": "The name of the URL parameter.",
    "paramValueTitle": "Parameter Value",
    "paramValueDescription": "The value of the URL parameter.",
    "optionsTypeBar": "Bar",
 	"optionsTypeDonut": "Donut",
	"optionsTypePie": "Pie",
	"optionsGroupAfterDefault": "Use Chart Default",
	"optionsPieDonutDefault": "5 - Pie and Donut default",
	"optionsBarDefault": "15 - Bar default",
	"optionsSortByActive": "Active Column",
	"optionsSortByCount": "Count",
	"optionsSortOrderDsc": "Descending",
	"optionsSortOrderAsc": "Ascending"
});

// Placeholder for the build target file; the name must be the same,
// include public modules from this component

csui.define('bundles/webreports-visdata',[

    // Widgets:
    "webreports/widgets/visual.data.filtered.count/visual.data.filtered.count.view",
    "json!webreports/widgets/visual.data.filtered.count/visual.data.filtered.count.manifest.json",
	'i18n!webreports/widgets/visual.data.filtered.count/impl/nls/visual.data.filtered.count.manifest'

], {});

csui.require(['require', 'css'], function (require, css) {

    css.styleLoad(require, 'webreports/bundles/webreports-visdata');

});

